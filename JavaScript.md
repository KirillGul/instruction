# [Ссылка на code.mu - JavaScript](http://code.mu/ru/javascript/book/prime/)  
# [Ссылка на javascript.ru](https://learn.javascript.ru/hello-world)
# [Ссылка на MDN Mozilla](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference)
# Добавление JavaScript кода в HTML
1. код должен быть внутри тегов `<script> ... </script>`
1. или подключён из внешнего файла `<script scr="путь/до/файла.js"></script>`
	> Примечание: нельзя в один тег скрипт объединять два вида добавления файлов, т.е. если атрибут src установлен, содержимое тега script будет игнорироваться.

# Строгий режим (`use strict`)
`"use strict";`
* отключает старую функциональность в JavaScript  
* для вкл. режима необходимо первой строчкой поставить: `"use strict";`
* перед(до) могут быть записаны только комментарии
* вместо включение строго режима во всём скрипте, можно поставить в начале большинства видов функций и тогда он будет работать только для функции
* современный JS поддерживает «классы» и «модули» — продвинутые структуры языка (и мы, конечно, до них доберёмся), которые автоматически включают строгий режим

# Коментарии в JavaScript
* // - однострочный
	> нажав комбинацию клавиш Ctrl+/ для однострочного комментария 
* /* ... */ - многострочный
	> Нельзя вкладывать коментарии друг в друга
	
# Переменные
1. Переменная должна состоять из [a-zA-Z0-9$_] латинских букв, чисел, символа $ и знака подчеркивания.
1. Первый символ не должен быть цифрой.
1. Регистр имеет значение
1. Нелатинские буквы разрешены, но не рекомендуются
1. [список зарезервированных слов](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Lexical_grammar#%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D1%8B%D0%B5_%D1%81%D0%BB%D0%BE%D0%B2%D0%B0), которые нельзя использовать в качестве имён переменных, потому что они используются самим языком 
> Пример именования переменных: str, my_str, myStr, a1, $, $a, $$a.

Несколько хороших правил именования переменных:
1. Используйте легко читаемые имена, такие как userName или shoppingCart.
1. Избегайте использования аббревиатур или коротких имён, таких как a, b, c, за исключением тех случаев, когда вы точно знаете, что так нужно.
1. Делайте имена максимально описательными и лаконичными. Примеры плохих имён: data и value. Такие имена ничего не говорят. Их можно использовать только в том случае, если из контекста кода очевидно, какие данные хранит переменная.
1. Договоритесь с вашей командой об используемых терминах. Если посетитель сайта называется «user», тогда мы должны называть связанные с ним переменные currentUser или newUser, а не, к примеру, currentVisitor или newManInTown.

## Областью видимости переменных
---
Объявленные переменный внутри фигурных скобок, являетюся областью видимости только внутри фигурных скобок. Однако, если переменная объявлена снаружи фигурных скобок, то видна и внутри, и снаружи.

## Объявление переменных
---
1. Используется оператор `let` или `var`(устарело) 
	1. `let` - имеет блочную область видимости
	1. `var`:
		* переменные `var` не имеют блочной области видимости, они ограничены, как минимум, телом функции.
		* объявление(инициализация) переменных `var` производится в начале исполнения функции (или скрипта для глобальных переменных).
1. Повторное объявление той же переменной является ошибкой.  
`let имя_переменной;`  
> Пример: let a; let a = 3;

## Глобальные объекты
---
Глобальный объект хранит переменные, которые должны быть доступны в любом месте программы.  
Это включает в себя как встроенные объекты, например, Array, так и характерные для окружения свойства, например, window.innerHeight – высота окна браузера.  
Глобальный объект имеет универсальное имя – `globalThis`.  
…Но чаще на него ссылаются по-старому, используя имя, характерное для данного окружения, такое как `window` (браузер) и `global` (Node.js).  
Следует хранить значения в глобальном объекте, только если они действительно глобальны для нашего проекта. И стараться свести их количество к минимуму.  
В браузерах, если только мы не используем модули, глобальные функции и переменные, объявленные с помощью `var`, становятся свойствами глобального объекта.  
Для того, чтобы код был проще и в будущем его легче было поддерживать, следует обращаться к свойствам глобального объекта напрямую, как `window.x`.

# Константы
* const - в них можно записывать данные только один раз, а затем их значения нельзя изменять.  
* Широко распространена практика использования констант в качестве псевдонимов для трудно запоминаемых значений, которые известны до начала исполнения скрипта.  
* Названия таких констант пишутся с использованием заглавных букв и подчёркивания   
`const PI = 3.14;`

# Типы данных
* семь примитивных типов данных: string, number, boolean, null, undefined, symbol, bigint.
* и один не примитивный: object (массивы то же объекты, это объект, у которого прототипом является Array)

## Возврат типа переменной(аргумента)
---
`typeof переменная; : String` - возвращает тип переменной.  
Это полезно, когда мы хотим обрабатывать значения различных типов по-разному или просто хотим сделать проверку.  
```javascript
// Обычный синтаксис
typeof 5 // Выведет "number"
// Синтаксис, напоминающий вызов функции (встречается реже)
typeof(5) // Также выведет "number"
typeof undefined // "undefined"
typeof 0 // "number"
typeof 10n // "bigint"
typeof true // "boolean"
typeof "foo" // "string"
typeof Symbol("id") // "symbol"
typeof Math // "object"  (1)
typeof null // "object"  (2)
typeof alert // "function"  (3)
```
> Для `null` возвращается "`object`" – это ошибка в языке, на самом деле это не объект.

## number (число)
---
* числовой тип данных (`number`) представляет как целочисленные значения, так и числа с плавающей точкой
* операции с числами математические: +-*/ и %
* преобразование к числу: `Number(строка)` или перед строкой ставят знак `+строка`. Если строка не может быть явно приведена к числу, то результатом преобразования будет `NaN`.

Правила численного преобразования:  
|Значение|Преобразуется в…|
|-|-|
|undefined|NaN|
|null|0|
|true / false|1 / 0
|string|Пробельные символы (пробелы, знаки табуляции \t, знаки новой строки \n и т. п.) по краям обрезаются. Далее, если остаётся пустая строка, то получаем 0, иначе из непустой строки «считывается» число. При ошибке результат NaN. 

Кроме обычных чисел, существуют так называемые «специальные числовые значения», которые относятся к этому типу данных: `Infinity`, `-Infinity` и `NaN`:
* `NaN` (Not-A-Number) - обозначает не число. Такое значение получается тогда, когда вы пытаетесь делать математические операции не с числами, а с чем-то другим. Если где-то в математическом выражении есть NaN, то оно распространяется на весь результат (есть только одно исключение: `NaN ** 0` равно `1`).  
К примеру, такое значение даст попытка умножить строку на число: 
`alert('abc' * 3); // выведет NaN`  
	> Любые операции с NaN приводят к тому, что результатом все равно остается NaN:  
	> `alert(NaN + 1); // выведет NaN`

	`isNaN(value) : Boolean` - преобразует значение в число и проверяет является value значением NaN.

* `Infinity` и `-Infinity` - обозначают соответственно бесконечность и минус бесконечность. Такие значения получаются, если какое-то число поделить на ноль - в этом случает JavaScript не выдает ошибку, как в других языках программирования, а возвращает эти значения.

	`isFinite(value) : Boolean` - преобразует аргумент в число и возвращает true, если оно является обычным числом, т.е. не NaN/Infinity/-Infinity

* `Number.isNaN(value)` и `Number.isFinite(value)` – это более «строгие» версии функций `isNaN` и `isFinite`. Они не преобразуют аргумент в число, а наоборот – первым делом проверяют, является ли аргумент числом (принадлежит ли он к типу `number`).
	* `Number.isNaN(value) : Boolean` - возвращает true только в том случае, если аргумент принадлежит к типу number и является NaN. Во всех остальных случаях возвращает false.
	* `Number.isFinite(value) : Boolean` возвращает true только в том случае, если аргумент принадлежит к типу number и не является NaN/Infinity/-Infinity. Во всех остальных случаях возвращает false.

* `Object.is` - специальный метод Object.is, который сравнивает значения примерно как `===`, но более надёжен в двух особых ситуациях:
	* Работает с `NaN: Object.is(NaN, NaN) === true`, здесь он хорош.
	* Значения 0 и -0 разные: `Object.is(0, -0) === false`, это редко используется, но технически эти значения разные.
	* Во всех других случаях `Object.is(a, b)` идентичен `a === b`.

### Дополнительные способы записи числа
---
* можно использовать символ нижнего подчёркивания _ в качестве разделителя
	```javascript
	let billion = 1_000_000_000 //1000000000
	```
* чтобы укоротить запись числа, мы можем добавить к нему букву "e" и указать необходимое количество нулей
	```javascript
	let billion = 1e9;  //1 миллиард, буквально: 1 и 9 нулей
	let num = 1.23e-6 === 1.23 / 1000000 //0.00000123
	```

### Глобальные методы получения числа из строки (к типу `number`)
---
Чтение числа из строки:  `parseInt` и `parseFloat`.  
Если в процессе чтения возникает ошибка, они возвращают полученное до ошибки число, вернут NaN, если не смогли прочитать ни одну цифру.
* `parseInt('строка') : int|NaN` - выделяет целую часть числа из строки.
	```javascript
	let num = parseInt('12px'); 
	alert(num); // выведет 12`
	```
* `parseFloat('строка') : int|NaN` - выделяет целую и дробную часть числа из строки.

### Шестнадцатеричные, двоичные и восьмеричные числа
---
* 0xЗначение - шестнадцатеричные
* 0oЗначение - восьмеричные
* 0bЗначение - двоичные

`num.toString(base)` - возвращает строковое представление числа num в системе счисления base. base может варьироваться от 2 до 36 (по умолчанию 10).  
```javascript
let num = 255;
alert(num.toString(16));  // ff
alert(num.toString(2));   // 11111111
```

## bigint (большое число)
---
Тип `BigInt` был добавлен в JavaScript, чтобы дать возможность работать с целыми числами произвольной длины.  
Чтобы создать значение типа `BigInt`, необходимо добавить `n` в конец числового литерала:
```javascript
// символ "n" в конце означает, что это BigInt
const bigInt = 1234567890123456789012345678901234567890n;
```

## string (строка)
---
* '...' и "..." - кавычки могут быть не только одинарными ('...'), но и двойными ("...") (нет ни какой разницы), а также ```<code>`...`</code>``` - обратными в которые можно втавлять переменные `${переменная}`
* конкатенация (сложение) строк "+"
	> с числом будет складывать как строка
* `length` - в свойстве содержится длина строки:  
	`let str = 'abcde';alert(str.length); // выведет 5`
 * \` ... \` -  специальный тип кавычек - обрытные кавычки (косые), в косых кавычках можно выполнять вставку переменных. Для этого имя переменной нужно написать в конструкции `${имя_переменной}`, также косые кавчки поддерживают многострочность
* `строка[индекс_по_порядку]` - при необходимости можно получить доступ к определенному символу строки по его номеру. Для этого пишется имя переменной, после этого имени ставятся квадратные скобки и в этих скобках указывается номер символа.  
`let str = 'abcde'; alert(str[0]); // выведет 'a'`  
Символы строк можно читать, но нельзя изменять. Следующий пример кода выдаст ошибку (в строгом режиме).  
`let str = 'abcde'; str[0] = '!';`
* так же к символу в строке можно получить доступ с помощью методв `строка.at(pos)`, он допускает отрицательную позицию
* преобразование к строке: `String(значение или переменная)`  
Преобразование происходит очевидным образом. false становится "false", null становится "null" и т.п.
* Внутренний формат для строк — всегда UTF-16, вне зависимости от кодировки страницы.

|Символ|Описание|
|-|-|
|\n|Перевод строки|
|\r|В текстовых файлах Windows для перевода строки используется комбинация символов \r\n, а на других ОС это просто \n. Это так по историческим причинам, ПО под Windows обычно понимает и просто \n.|
|\', \", \` |Кавычки|
|\\ |Обратный слеш|
|\t|Знак табуляции|
|\b, \f, \v|Backspace, Form Feed и Vertical Tab — оставлены для обратной совместимости, сейчас не используются.|

## Boolean (логический тип)
---
* во всех логических операциях значения вначале преобразуются к числу
* `Boolean(значение)` - преобразование к логическому типу, true или false

Правило преобразования:
1. Значения, которые интуитивно «пустые», вроде 0, пустой строки, null, undefined и NaN, становятся false.
1. Все остальные значения становятся true.

## Специальные значения undefined
---
`undefined` - обозначает неопределенность. Такое значение будет у переменной, если мы объявили ее, но не записали в нее значение. Также это значение можно присвоить переменной явно.

## Специальные значения null
---
`null` - обычно используется для присвоения переменной «пустого» или «неизвестного» значения, а undefined – для проверок, была ли переменная назначена.  
`null` - обозначает "ничего". К примеру, мы можем присвоить переменной такое значение в знак того, что там ничего не лежит.

## Symbol (символ)
---
`symbol` - данный тип используется для уникальных идентификаторов в объектах.

## Объект (object)
---
`object` - объект хранят коллекции данных или более сложные структуры.  

# Взаимодействие: alert, prompt, confirm
Все эти методы являются модальными: останавливают выполнение скриптов и не позволяют пользователю взаимодействовать с остальной частью страницы до тех пор, пока окно не будет закрыто.
На все указанные методы распространяются два ограничения:
1. Расположение окон определяется браузером. Обычно окна находятся в центре.
1. Визуальное отображение окон зависит от браузера, и мы не можем изменить их вид.

Такова цена простоты. Есть другие способы показать более приятные глазу окна с богатой функциональностью для взаимодействия с пользователем, но если «навороты» не имеют значения, то данные методы работают отлично.

## `alert`
---
`alert('text');`  
`alert` - показывает сообщение и ждёт, пока пользователь нажмёт кнопку «ОК».  
## `prompt`
---
`result = prompt('title', [default]); :String|''|null`   
`prompt` - этот код отобразит модальное окно с текстом, полем для ввода текста и кнопками OK/Отмена.  
title - текст для отображения в окне  
default - необязательный второй параметр, который устанавливает начальное значение в поле для текста в окне  
Вызов prompt возвращает текст, указанный в поле для ввода, или null
## `confirm`
---
`result = confirm('question'); :Boolean`  
`confirm` - отображает модальное окно с текстом вопроса question и двумя кнопками: OK и Отмена.  
Результат – `true`, если нажата кнопка OK. В других случаях – `false`.

# Математические операции
* +, -, *, /, а также операция % - остаток от деления
* приоритет операций, как в математике (плюс можно регулировать с помощью скобок)
* ** - операция возведения в степень имеет приоритет перед умножением и делением
* сокращенные операции: +=, -=, *=, /=, ++, --

## Операторы сравнения
---
Результат сравнения имеет логический тип, т.е. все операторы сравнения возвращают значение логического типа:
* `true` – означает «да», «верно», «истина».
* `false` – означает «нет», «неверно», «ложь».

В JavaScript они записываются так:
1. Больше/меньше: a > b, a < b.
1. Больше/меньше или равно: a >= b, a <= b.
1. Равно: a == b. Обратите внимание, для сравнения используется двойной знак равенства ==. Один знак равенства a = b означал бы присваивание.
1. Не равно. В математике обозначается символом ≠, но в JavaScript записывается как a != b.  
1. Оператор строгого равенства === проверяет равенство без приведения типов.
1. Сравнение с null и undefined между собой:  
	* При строгом равенстве === - эти значения различны, так как различны их типы. 
	* При нестрогом равенстве == - эти значения равны друг другу и не равны никаким другим значениям. Это специальное правило языка.
1. Сравнение с null и undefined между другими аргументами:
	* при сравнения (>, <, >=, <=) преобразуют null в число, рассматривая его как 0, а при == преобразования не происходит
	* значение undefined несравнимо с другими значениями, т.к. undefined преобразуется в NaN (NaN всегда равно false).
> При сравнении строк используется кодировка Unicode, а не настоящий алфавит

## Логические операторы || (ИЛИ), && (И) и ! (НЕ), ?? (Оператор нулевого слияния)
---
1. Если значение не логического типа, то оно к нему приводится в целях вычислений. 
	* Число 0, пустая строка "", null, undefined и NaN становятся false. Из-за этого их называют «ложными» («falsy») значениями.
	* Остальные значения становятся true, поэтому их называют «правдивыми» («truthy»).
1. Значения возвращаются в исходном виде, без преобразований.

### || (ИЛИ)
---
Традиционно в программировании `ИЛИ(||)` предназначено только для манипулирования булевыми значениями.  
Оператор `||` выполняет следующие действия:
1. Вычисляет операнды слева направо.
1. Каждый операнд конвертируется в логическое значение, если результат `true`, останавливается и возвращает исходное значение этого операнда.
1. Если все операнды являются ложными `false`, возвращает последний из них.
	> Значение возвращается в исходном виде, без преобразования (не Boolean тип).

## ||= (логическое присваивание ИЛИ) (альтернатива if)
---
Новая возможность языка.  
```a ||= b;```, т.е. ```a || (a = b);```
Оператор ||= принимает два операнда и выполняет следующие действия:
1. Вычисляет операнды слева направо.
1. Конвертирует a в логическое значение.
1. Если a ложно, присваивает a значение b.  
т.е. ```a || (a = b);```  
эта конструкция "синтаксический сахар", который служит альтернативой `if`  
	```javascript
	if (manufacturer == false) {
		manufacturer = "Неизвестный производитель";
	}
	```

### && (И)
---
В традиционном программировании `И(&&)` возвращает `true`, если оба аргумента истинны, а иначе – `false`.  
Оператор `&&` выполняет следующие действия:
1. Вычисляет операнды слева направо.
1. Каждый операнд преобразуется в логическое значение, если результат `false`, останавливается и возвращает исходное значение этого операнда.
1. Если все операнды были истинными, возвращается последний.

> Другими словами:  
> * && возвращает первое ложное значение (или последнее истинное), а  
> * || возвращает последнее ложное, если ничего не найдено (или первое истинное)

> Приоритет оператора && больше, чем у ||

## &&= (логическое присваивание И) (альтернатива if)
---
Новая возможность языка.  
```a &&= b;```, т.е. ```a && (a = b);```  
`&&=` присвоит a значение b только в том случае, если a истинно.  
т.е. ```a && (a = b);```    
эта конструкция "синтаксический сахар", который служит альтернативой `if`  
```javascript
	let greeting == true
	if (greeting) {
		greeting = "пользователь!"
	}
```

## ! (НЕ)
---
Оператор принимает один аргумент и выполняет следующие действия:
1. Сначала приводит аргумент к логическому типу `true/false`.
1. Затем возвращает противоположное значение.

В частности, двойное НЕ `!!` используют для преобразования значений к логическому типу:
```javascript
alert( !!"non-empty string" ); // true
alert( !!null ); // false
```
То есть первое НЕ преобразует значение в логическое значение и возвращает обратное, а второе НЕ снова инвертирует его. В конце мы имеем простое преобразование значения в логическое.
> Приоритет НЕ ! является наивысшим из всех логических операторов, поэтому он всегда выполняется первым, перед && или ||.

## ?? (Оператор нулевого слияния) (альтернатива if)
---
Новая возможность языка.  
```a ?? b;```  
Оператор `??` возвращает первый аргумент, если он не `null/undefined`, иначе второй. 
Результат выражения `a ?? b` будет следующим:
1. если a определено, то a,
1. если a не определено, то b.  
т.е.
```javascript
result = a ?? b
//используя уже знакомые нам операторы:
result = (a !== null && a !== undefined) ? a : b;
```
Важное различие между (`||` и `??`) заключается в том, что:
* `||` возвращает первое истинное значение.
* `??` возвращает первое определённое значение.

> Приоритет оператора ?? такой же, как и у ||. Они оба равны 3 в таблице на MDN.  

> По соображениям безопасности JavaScript запрещает использование оператора ?? вместе с && и ||, если приоритет явно не указан при помощи круглых скобок.

## ??= (Оператор нулевого присваивания) (альтернатива if)
---
```x ??= y;```  
Оператор `??=` присвоит x значение y только в том случае, если x не определено (null/undefined).  
```javascript
let userAge = null;

userAge ??= 18;

//или

if (userAge === null || userAge === undefined) {
  userAge = 18;
}
```

# Ветвления
## Конструкция IF-ELSE:
---
`if (логическое условие) {}` - интсрукция вычисляет выражение в скобках и преобразует результат к логическому типу.  
Давайте вспомним правила преобразования типов из главы Преобразование типов:
1. Число 0, пустая строка "", null, undefined и NaN становятся false. Из-за этого их называют «ложными» («falsy») значениями.
1. Остальные значения (в т.ч. строк "0" в отличии от PHP) становятся true, поэтому их называют «правдивыми» («truthy»).
```javascript
if (логическое условие) {
    /* код */
} else {
    /* код */
}
```  
Конструкция else if позволяет задавать условия в блоке else:  
```javascript
} else if (num == 2) {
    /* код */
}
```

## Тернарный оператор "?:" как альтернатива if...else в коротких выражениях
---
`условие ? значение1 : значение2` - смысл оператора «вопросительный знак» ? – вернуть то или иное значение, в зависимости от условия. Пожалуйста, используйте его именно для этого. А когда вам нужно выполнить разные ветви кода – используйте `if...else`.
```javascript
let переменная = условие ? значение1 : значение2;
```

## Конструкция SWITCH-CASE:
---
Переменная `x` проверяется на <u>строгое равенство (`===`)</u> первому значению `value1`, затем второму `value2` и так далее:
1. Если соответствие установлено – `switch` начинает выполняться от соответствующей директивы `case` и далее, до ближайшего `break` (или до конца `switch`).  
1. Если ни один `case` не совпал – выполняется (если есть) вариант `default`.  
1. Если `break` нет, то выполнение пойдёт ниже по следующим `case`, при этом остальные проверки игнорируются.
1. Любое выражение может быть аргументом для `switch/case`.
1. Несколько вариантов case, использующих один код, можно группировать.
```javascript
switch (x) { 
    case 'value1': //x === 'value1'
        /* код */
        break;
    case 'value2': //x === 'value2'
        /* код */
        break;
    case 'value3': //x === 'value3'
        /* код */
        break;
    default:
        /* код */
        break;
}
```

# Циклы
## Общие значения в циклах JavaScript
---
* для счетчиков принято использовать буквы `i, j и k`
* `break` - озволяет досрочно завершать цикл и перейти к следующей строке после цикла  
	> Обратите внимание, что эти синтаксические конструкции не являются выражениями и не могут быть использованы с тернарным оператором ?. В частности, использование директив break/continue с тернарным оператором, вызовет ошибку.
	* `labelName`
		Бывает, нужно выйти одновременно из нескольких уровней цикла сразу.  
		```javascript
			labelName: for (...) {
  				for (...) {
					break lebalName;
  				}
			}
		```
* `continue` - переход к следующей итерации
	* Директива `continue` также может быть использована с меткой `labelName`. В этом случае управление перейдёт на следующую итерацию цикла с меткой.

> ВАЖНО: метки не прыгают на код расположенный ниже.  

> ВАЖНО: директива `break` должна находиться внутри блока кода.

## WHILE
---
```javascript
while ( пока выражение истинно ) {
    выполняем этот код циклически;
    в начале каждого цикла проверяем выражение в круглых скобках
}
```

## DO…WHILE
---
```javascript
do {
  // тело цикла
} while ( пока выражение истинно);
```

## FOR
---
```javascript
for ( начальные команды; условие окончания; команды после прохода ) {
    /* тело цикла */
}
```

## FOR-OF (для массивов)
---
```javascript
for (let переменнаяДляЭлемента of массив) {
    /* тело */
}
```
```javascript
let arr = [1, 2, 3, 4, 5];

for (let elem of arr) {
    console.log(elem);
}
```

## FOR-IN (для объектов)
---
```javascript
for (let переменнаяДляКлюча in объект) {
    /* тело */
}
```
```javascript
let obj = {
	a: 1, 
	b: 2, 
	c: 3,
};

for (let key in obj) {
    console.log(key); // выведет 'a', 'b', 'c'
}

for (let key in obj) {
    console.log(obj[key]); // выведет 1, 2, 3
}
```

# Функции в JavaScript
Функция – это значение, представляющее «действие».  
* Обычные значения, такие как строки или числа представляют собой данные.  
* Функции, с другой стороны, можно воспринимать как действия.  

Мы можем передавать их из переменной в переменную и запускать, когда захотим.

## Стандартное определение(объявление) функции (Function Declaration)
---
```javascript
function имя(параметры) {
  ...тело...
} //точка с запятой не ставиться
имя(); // вызов функции без параметров
```

## Свойства функций
---
* Переменные, объявленные внутри функции, видны только внутри этой функции.
* Параметры:
	* Параметр – это переменная, указанная в круглых скобках в объявлении функции.
    * Аргумент – это значение, которое передаётся функции при её вызове.
* Параметры функций можно делать не обязательными. Для этого параметрам нужно задать значения по умолчанию.
* Функция может возвращать значение. Если этого не происходит, тогда результат равен undefined.
* В JavaScript (в других языках чаще всего не так) переменные, определенные снаружи функции, будут видны внутри этой функции.
* Внешняя переменная (лексическое окружение функций) используется, только если внутри функции нет такой локальной.
	* <u>Лексическое окружение функций</u>: все внешние, доступные функции переменные, называются ее лексическим окружением (англ. LexicalEnvironment).
	В следующем примере функции доступны две переменные: `num1 и num2`, которые и являются лексическим окружением нашей функции:
		```javascript
		let num1 = 1;
		let num2 = 2;

		function func() {
			// функция знает про переменные num1 и num2
		}
		```

		> Когда мы пытаемся обратится к какой-либо переменной внутри функции, эта переменная вначале ищется среди локальных переменных функции и, если такой переменной там нет, то ищется в лексическом окружении функции.
* Так как любая из функций легко может поменять глобальную переменную, то их использование представляет собой рассадник трудноуловимых ошибок. По этой причине использование глобальных переменных в скрипте нужно сводить к минимуму. Желательно, чтобы их вообще не было или было самое минимальное количество.
* Параметры(примитивы) функции являются локальными переменными внутри нее.
* Контекст выполнения:
	<u>Контекст выполнения</u> – специальная внутренняя структура данных, которая содержит информацию о вызове функции. Она включает в себя конкретное место в коде, на котором находится интерпретатор, локальные переменные функции, значение `this` и прочую служебную информацию.
* Объекты, в отличие от примитивов, передаются по ссылке. Это значит, что изменение объекта внутри функции приведет к тому, что он поменяется и снаружи функции.
* Обратившись к функции без круглых скобок, мы получаем ее исходный код  
	```javascript
	function func() {
		return '!';
	}
	console.log(func); // увидим код функции function func() {return '!';} `
	```
* return - значение, которое возвращает функция. После того, как выполнится инструкция `return` - функция закончит свою работу и никакой код дальше не выполнится. Это не значит, что в функции должен быть один `return`. Но выполнится только один из них.
* Результат функции с пустым `return` или без него – `undefined`
* в JavaScript функции ведут себя, будто строки или числа. В частности, можно сделать массив или объект, состоящий из функций.
	```javascript
	let arr = [
		function() {console.log('1')},
		function() {console.log('2')},
		function() {console.log('3')},
	];
	```

## Советы по созданию функций
---
1. Функция – это действие. Поэтому имя функции обычно является глаголом.
1. Имя каждой функции должно точно отражать то, что функция делает.
1. Используйте общепринятые префиксы в именах функций: 
    1. "get…" – возвращают значение,
    1. "calc…" – что-то вычисляют,
    1. "create…" – что-то создают,
    1. "check…" – что-то проверяют и возвращают логическое значение, и т.д.
1. Функция должна делать только то, что явно подразумевается её названием, и не делать другого.
1. Каждая функция должна выполнять только одно действие.
1. Используйте внутри функций вспомогательные функции.
1. Код функций лучше не делать длиннее 10-15 строк.
1. Длинные функции лучше разбивать на ряд вспомогательных.
1. Выносите дублирующийся код в функции.

## Функция как переменная в JavaScript
---
Давайте посмотрим на примере. Пусть у нас есть, например, функция func:
```javascript
function func() {
    console.log('!');
}
```
На самом деле у нас нет функции func. У нас есть переменная func, хранящая в себе исходный код функции. Запись функции в другую переменную в JavaScript:
```javascript
let test = func; // теперь test такая же функция, как и func.
```

### Совпадение имени функции и переменной
---
Из описанного выше следует, что существование переменной и функции с одинаковым именем легко может привести к проблеме.
```javascript
function func() {
    return '!';
}

func = 'string'; // затрем переменную с функцией строкой
func(); // получим ошибку, т.к. func - не функция
```
Чтобы такого не происходило, следует придерживаться правила, общего для всех языков программирования:
1. функции должны быть глаголами, 
1. а переменные - существительными. 

## Function Expression (функциональное выражение)
---
```javascript
let func = function() {
    console.log('!');
};

func(); // выведет '!'
```
Поскольку создание функции происходит в контексте выражения присваивания (с правой стороны от =), это Function Expression.  
После закрывающей фигурной скобки "}" обязательно ставится точка с запятой ";".

### Разница Function Expression, и Function Declaration:
---
* функции, объявленные как Function Declaration, будут доступны, даже если обратится к ним до того, как они были объявлены, Function Expression создаются в момент выполнения кода и недоступны выше.  
    * еще раз: функция, являющаяся функциональным выражением не может быть вызвана по ее имени. Такая функция может быть вызвана только с использованием переменной, в которую была записана эта функция.  
    * но тем не менее, функциональное выражение может иметь имя функции, это будет синтаксически корректно. Зачем такое нужно, см. ниже по тексту.  
* Function Expression создаётся, когда выполнение доходит до него, и затем уже может использоваться.
* Function Declaration может быть вызвана раньше, чем она объявлена. (Другими словами, когда движок JavaScript готовится выполнять скрипт или блок кода, прежде всего он ищет в нём Function Declaration и создаёт все такие функции. Можно считать этот процесс «стадией инициализации». И только после того, как все объявления Function Declaration будут обработаны, продолжится выполнение.)
* Ещё одна важная особенность Function Declaration заключается в их блочной области видимости. В строгом режиме, когда Function Declaration находится в блоке {...}, функция доступна везде внутри блока. Но не снаружи него.

### Общие свойства Function Expression, и Function Declaration:
---
* независимо от того, как создаётся функция – она является значением.

> Подведем итог: функции являются Function Declaration или Function Expression не потому, что имеют имя или не имеют, а потому, что являются участниками выражений или не являются. Функция без имени может быть воспринята как Function Declaration, а функции с именем может быть Function Expression. Такие Function Expression с именем функции называются именованными функциональными выражениями.

## Функции-callback
---
Функции можно передавать параметрами в другие функции. Такие функции-параметры называются callback-функциями.  
Коллбэки не обязательно должны быть анонимными функциями.

Ключевая идея в том, что мы передаём функцию и ожидаем, что она вызовется обратно (от англ. «call back» – обратный вызов) когда-нибудь позже, если это будет необходимо.  
Пример:
```javascript
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

function showOk() {
  alert( "Вы согласны." );
}

function showCancel() {
  alert( "Вы отменили выполнение." );
}

// использование: функции showOk, showCancel передается код функции в качестве аргументов ask и вызывается по ходу выполнения функции
ask("Вы согласны?", showOk, showCancel);
```

## Стрелочные функции (arrow functions)
---
Это функции, упрощающие синтаксис Function Expression.
* нет собственного this
* нет своего объекта arguments

В следующем примере кода первой написана Function Expression, а второй - соответствующая ей стрелочная (обе функции делают одно и тоже):
```javascript
let func1 = function(num1, num2) {
    let result = num1 * num2;
    return result;
}

let func2 = (num1, num2) => {
    let result = num1 * num2;
    return result;
}
```
   
* Если в функции одна строка кода, то в стрелочных функциях можно не писать `return` и фигурные скобки:
```javascript
let func1 = function(num1, num2) {
    return num1 * num2
}

let func2 = (num1, num2) => num1 * num2;
```

* Если параметр стрелочной функции один - круглые скобки можно не писать:
```javascript
let func1 = function(num) {
    return num * num;
}

let func2 = num => num * num;
```

* Если в функции вообще нет параметров - нужно писать пустые круглые скобки:
```javascript    
let func1 = function() {
    console.log('!!!');
}

let func2 = () => console.log('!!!');
```

## Замыкания в JavaScript
---
<u>Замыкание</u> - это функция вместе со всеми внешними переменными, которые ей доступны. Или, другими словами, замыкание - это функция вместе со своим лексическим окружением. То есть они автоматически запоминают, где были созданы, с помощью скрытого свойства `[[Environment]]`, и все они могут получить доступ к внешним переменным.  

В JavaScript у каждой выполняемой функции, блока кода {...} и скрипта есть связанный с ними внутренний (скрытый) объект, называемый лексическим окружением LexicalEnvironment.  
Объект лексического окружения состоит из двух частей:
* <u>Environment Record</u> – объект, в котором как свойства хранятся все локальные переменные (а также некоторая другая информация, такая как значение this).
* <u>Ссылка на внешнее лексическое окружение</u> – то есть то, которое соответствует коду снаружи (снаружи от текущих фигурных скобок).

Когда код хочет получить доступ к переменной – сначала происходит поиск во внутреннем лексическом окружении, затем во внешнем, затем в следующем и так далее, до глобального.  
Переменная обновляется в том лексическом окружении, в котором она существует.

## Вызов функции на месте в JavaScript (Immediately Invoked Function Expression (IIFE))
---
Давайте посмотрим на примере. Пусть у нас есть вот такое функциональное выражение:
```javascript
let func = function() {
    console.log('!');
};

func(); //выведет '!'
```

Давайте теперь не будем присваивать нашу функцию в переменную, а вызовем ее сразу же, "на месте". Для этого после функции поставим круглые скобки:
```javascript
+function() {
    console.log('!'); //выведет '!'
}();
```

> Наличие плюса в данном случае является обязательным условием, так как без него функция станет Function Declaration, а их на месте (да еще без имени) вызывать нельзя. Конечно же, вместо плюса может быть все, что угодно, - главное, чтобы наша функция была функциональным выражением. 

Давайте вызовем нашу функцию на месте, передав ей строку для вывода в консоль:
```javascript
(function(str) {
    console.log(str); //выведет '!!!'
})('!!!');
```
             
Чтобы избежать проблем c чтением кода интерпретатором, перед вызовом функции на месте всегда необходимо ставить точку с запятой, вот так:
```javascript
let num = 1

;(function() {
    console.log(num); // выведет 1
})();
```

## Объект функции, NFE (углубленние в функции)
---
Как мы уже знаем, в JavaScript функция – это значение и занчение это Object.  
Можно представить функцию как «объект, который может делать какое-то действие». Функции можно не только вызывать, но и использовать их как обычные объекты: добавлять/удалять свойства, передавать их по ссылке и т.д.  
* свойство `name` - содержит имя функции
	```javascript
	function sayHi() {
  		alert("Hi");
	}
	```
	Бывает, что корректное имя определить невозможно. В таких случаях свойство name имеет пустое значение.
	```javascript
	// функция объявлена внутри массива
	let arr = [function() {}];
	alert( arr[0].name ); // <пустая строка>
	// здесь отсутствует возможность определить имя, поэтому его нет
	alert(sayHi.name); // sayHi
	```

* свойство `length` - содержит количество параметров функции в её объявлении.
	```javascript
	function f1(a) {}
	function f2(a, b) {}
	function many(a, b, ...more) {}

	alert(f1.length); // 1
	alert(f2.length); // 2
	alert(many.length); // 2 троеточие не считается
	```

* свойство `Environment` - хранит ссылку на лексическое окружение, в котором была создана функция (см. замыкания).
Так функция запоминает, где она была создана, независимо от того, где она вызывается. Ссылка на `[[Environment]]` устанавливается один раз и навсегда при создании функции.

* пользовательские свойства - можем добавить свои собственные свойства.
	```javascript
	function sayHi() {
		alert("Hi");
		// давайте посчитаем, сколько вызовов мы сделали
		sayHi.counter++;
	}
	
	sayHi.counter = 0; // начальное значение

	sayHi(); // Hi
	sayHi(); // Hi

	alert( `Вызвана ${sayHi.counter} раза` ); // Вызвана 2 раза
	```
	> Мы можем использовать функцию как объект, хранить в ней свойства, но они никак не влияют на её выполнение. Переменные – это не свойства функции и наоборот. Это два параллельных мира.

* Named Function Expression (NFE)
`Named Function Expression` или `NFE` – это термин для Function Expression, у которого есть имя.  
Если функция объявлена как Function Expression (вне основного потока кода) и имеет имя, тогда это называется Named Function Expression (Именованным Функциональным Выражением). Это имя может быть использовано для ссылки на себя же, для рекурсивных вызовов и т.п.  
```javascript
let sayHi = function func(who) {
  if (who) {
    alert(`Hello, ${who}`);
  } else {
    func("Guest"); // Теперь всё в порядке
  }
};

let welcome = sayHi;
sayHi = null;

welcome(); // Hello, Guest (вложенный вызов работает)
```

Есть две важные особенности имени `func`(или другое) (это название своего рода `this` для функциё), ради которого оно даётся:
* Оно позволяет функции ссылаться на себя же.
* Оно не доступно за пределами функции.

> NFE не работает с Function Declaration

## Работа с рекурсией в JavaScript
---
В программировании есть такое понятие, как рекурсия - это когда функция вызывает сама себя.

<u>База рекурсии</u> - то место где рекурсия прерывается.  
<u>Шаг рекурсии</u> - это сводение задачи к более простому действию.
<u>Глубина рекурсии</u> - общее количество вложенных вызовов (включая первый). Обычно максимум 100000.  

```javascript
function pow(x, n) {
  if (n == 1) { //база рекурсии
    return x;
  } else { //шаг рекурсии
    return x * pow(x, n - 1);
  }
}

alert( pow(2, 3) ); // 8
```

> Итак, рекурсию используют, когда вычисление функции можно свести к её более простому вызову, а его – к ещё более простому и так далее, пока значение не станет очевидно.

<u>Рекурсивная (рекурсивно определяемая) структура данных</u> – это структура, которая повторяет саму себя в своих частях.  
Например: Связанный список:

Элемент связанного списка определяется рекурсивно как объект с:
* value,
* next – свойство, ссылающееся на следующий элемент связанного списка или null, если это последний элемент.

```javascript
let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};
```

Списки могут быть улучшены:
* Можно добавить свойство prev в дополнение к next для ссылки на предыдущий элемент, чтобы легко двигаться по списку назад.
* Можно также добавить переменную tail, которая будет ссылаться на последний элемент списка (и обновлять её при добавлении/удалении элементов с конца).
…Возможны другие изменения: главное, чтобы структура данных соответствовала нашим задачам с точки зрения производительности и удобства.

## Остаточные параметры (...) и оператор расширения в функциях
---
### Остаточные параметры (...)
---
* Вызывать функцию можно с любым количеством аргументов независимо от того, как она была определена.
* Лишние аргументы не вызовут ошибку. Но, посчитаются только определенные в функции.
* Остаточные параметры могут быть обозначены через три точки `...`. Буквально это значит: «собери оставшиеся параметры и положи их в массив».
* Остаточные параметры должны располагаться в конце.
* Все аргументы функции находятся в псевдомассиве `arguments` под своими порядковыми номерами.
	```javascript
	function showName() {
		alert( arguments.length );
		alert( arguments[0] );
		alert( arguments[1] );

		// Объект arguments можно перебирать
		// for (let arg of arguments) alert(arg);
	}

	// Вывод: 2, Юлий, Цезарь
	showName("Юлий", "Цезарь");

	// Вывод: 1, Илья, undefined (второго аргумента нет)
	showName("Илья");
	```
	> `arguments` похож на массив, и его тоже можно перебирать, это всё же не массив. Он не поддерживает методы массивов.

	> `arguments` всегда содержит все аргументы функции — мы не можем получить их часть. А остаточные параметры позволяют это сделать.
* Стрелочные функции не имеют `arguments`

### Оператор расширения функции
---
`...` - работает с любым перебираемым объектом (массив, строка и др.)
```javascript
let arr = [3, 5, 1];
alert( Math.max(...arr) ); // 5 (оператор "раскрывает" массив в список аргументов)
```

## new Function
`new Function` - ещё один вариант объявления функции. Он используется крайне редко.  

```javascript
let func = new Function([arg1, arg2, ...argN], functionBody);
```

* Функция создаётся с заданными аргументами `arg1...argN` и телом `functionBody`.
* `new Function` позволяет превратить любую строку в функцию.
* `new Function`, в её `[[Environment]]` записывается ссылка не на внешнее лексическое окружение, в котором она была создана, а на глобальное. Поэтому такая функция имеет доступ только к глобальным переменным.

## setTimeout
---
`setTimeout(func|code, [delay], [arg1], [arg2], ...) : Int(timerId)` - позволяет вызвать функцию один раз через определённый интервал времени.

> Любой вызов `setTimeout` будет выполнен только после того, как текущий код завершится.

```javascript
let timerId = setTimeout(func|code, [delay], [arg1], [arg2], ...);
```
* `func|code` - функция или строка кода для выполнения. Обычно это функция. По историческим причинам можно передать и строку кода, но это не рекомендуется.
* `delay` - задержка перед запуском в миллисекундах (1000 мс = 1 с). Значение по умолчанию – 0.
* `arg1, arg2…` - аргументы, передаваемые в функцию
* `timerId` - возвращает «идентификатор таймера», который можно использовать для отмены дальнейшего выполнения.

```javascript
function sayHi(phrase, who) {
  alert( phrase + ', ' + who );
}

setTimeout(sayHi, 1000, "Привет", "Джон"); // Привет, Джон
```

### Отмена через clearTimeout
---
`clearTimeout(timerId);` - отмены дальнейшего выполнения.

### Вложенный setTimeout
---
```javascript
/** вместо:
let timerId = setInterval(() => alert('tick'), 2000);
*/

let timerId = setTimeout(function tick() {
  alert('tick');
  timerId = setTimeout(tick, 2000); // (*)
}, 2000);
```

### setTimeout с нулевой задержкой
---
Особый вариант использования: `setTimeout(func, 0)` или просто `setTimeout(func)`.  
Это планирует вызов func настолько быстро, насколько это возможно. Но планировщик будет вызывать функцию только после завершения выполнения текущего кода.  
Так вызов функции будет запланирован сразу после выполнения текущего кода.  
Аналогичное происходит при использовании `setInterval` вместо `setTimeout: setInterval(f)` запускает f несколько раз с нулевой задержкой, а затем с задержкой 4+ мс.

## setInterval
---
` setInterval(func|code, [delay], [arg1], [arg2], ...); : Int(timerId)` - позволяет вызывать функцию регулярно, повторяя вызов через определённый интервал времени.

```javascript
let timerId = setInterval(func|code, [delay], [arg1], [arg2], ...);
```
* `func|code` - функция или строка кода для выполнения. Обычно это функция. По историческим причинам можно передать и строку кода, но это не рекомендуется.
* `delay` - интервал запуска в миллисекундах (1000 мс = 1 с). Значение по умолчанию – 0.
* `arg1, arg2…` - аргументы, передаваемые в функцию
* `timerId` - возвращает «идентификатор таймера», который можно использовать для отмены дальнейшего выполнения.
Чтобы остановить дальнейшее выполнение функции, необходимо вызвать `clearInterval(timerId)`.

### Отмена через clearInterval
---
`clearInterval(timerId);` - отмены дальнейшего выполнения.

## Декораторы и переадресация вызова, call/apply
JavaScript предоставляет исключительно гибкие возможности по работе с функциями: 
* они могут быть переданы в другие функции, 
* использованы как объекты,  
и сейчас мы рассмотрим, как перенаправлять вызовы между ними и как их декорировать.

<u>Декоратор</u> – это обёртка вокруг функции, которая изменяет поведение последней. Основная работа по-прежнему выполняется функцией, но также добавляется дополнительная функциональность. Другими словами: <u>декоратор</u> - это специальная функция, которая принимает другую функцию и изменяет её поведение.

> Обычно безопасно заменить функцию или метод декорированным, за исключением одной мелочи. Если исходная функция предоставляет свойства, такие как func.calledCount или типа того, то декорированная функция их не предоставит. Потому что это обёртка. Так что нужно быть осторожным в их использовании. Некоторые декораторы предоставляют свои собственные свойства. Декораторы можно рассматривать как «дополнительные возможности» или «аспекты», которые можно добавить в функцию. Мы можем добавить один или несколько декораторов. И всё это без изменения кода оригинальной функции!

```javascript
function slow(x) {
  // здесь могут быть ресурсоёмкие вычисления
  alert(`Called with ${x}`);
  return x;
}

function cachingDecorator(func) {
  let cache = new Map();

  return function(x) {
    if (cache.has(x)) {    // если кеш содержит такой x,
      return cache.get(x); // читаем из него результат
    }

    let result = func(x); // иначе, вызываем функцию

    cache.set(x, result); // и кешируем (запоминаем) результат
    return result;
  };
}

slow = cachingDecorator(slow);

alert( slow(1) ); // slow(1) кешируем
alert( "Again: " + slow(1) ); // возвращаем из кеша

alert( slow(2) ); // slow(2) кешируем
alert( "Again: " + slow(2) ); // возвращаем из кеша
```

### Передача контекста вызываемой функции через аргумент context
---
`func.call(context, arg1, arg2…)` – вызывает `func` с данным контекстом и аргументами. (`...args` - разворачивает массив в аргументы)  
`func.apply(context, args)` – вызывает `func`, передавая context как `this` и псевдомассив(индексы и свойство length) `args` как список аргументов.

> Передача всех аргументов вместе с контекстом другой функции называется «перенаправлением вызова» (`call forwarding`).

```javascript
let wrapper = function(original, arguments) {
  return original.apply(this, arguments);
};
```

Есть только одна небольшая разница:
* Оператор расширения ... позволяет передавать перебираемый объект args в виде списка в call.
* А apply принимает только псевдомассив args.

<u>Заимствования метода</u> - это когда мы вызываем метод у объекта в контексте другого объекта. Весьма распространено заимствовать методы массива и применять их к arguments. В качестве альтернативы можно использовать объект с остаточными параметрами ...args, который является реальным массивом.

## Привязка контекста с помощью bind
---
`let bound = func.bind(context, [arg1], [arg2], ...);` - синтаксис `bind` исправляет только `this`, а аргументы передаются как есть (или опционально тоже привязываються) т.е. результатом вызова `func.bind(context)` является особый «экзотический объект» (термин взят из спецификации), который вызывается как функция и прозрачно передаёт вызов в `func`, при этом устанавливая `this=context`.

Передача только `this`:
```javascript
let user = {
  firstName: "Вася",
  say(phrase) {
    alert(`${phrase}, ${this.firstName}!`);
  }
};

let say = user.say.bind(user);

say("Привет"); // Привет, Вася (аргумент "Привет" передан в функцию "say")
say("Пока"); // Пока, Вася (аргумент "Пока" передан в функцию "say")
```

Передача только `this` + аргументы:
```javascript
function mul(a, b) {
  return a * b;
}

let double = mul.bind(null, 2);

alert( double(3) ); // = mul(2, 3) = 6
alert( double(4) ); // = mul(2, 4) = 8
alert( double(5) ); // = mul(2, 5) = 10
```

Вызов `mul.bind(null, 2)` создаёт новую функцию `double`, которая передаёт вызов `mul`, фиксируя `null` как контекст, и 2 – как первый аргумент. Следующие аргументы передаются как есть.  
> Обратите внимание, что в данном случае мы на самом деле не используем `this`. Но для `bind` это обязательный параметр, так что мы должны передать туда что-нибудь вроде `null`.

# Объекты
<u>Объект</u> - объектом в JavaScript называют ассоциативный массив или хеш данных.  
* имеет свой тип данных, `object`  
* объекты несколько отличаются от остальных примитивных типов данных. Отличие в том, что переменная, хранящая объект, на самом деле не содержит его, а просто ссылается на него  

## Создание объекта
---
Объекты создаются с помощью фигурных скобок `{}`, внутри которых пишутся элементы этого объекта в формате `ключ:значение`:
```javascript
let user = new Object(); // синтаксис "конструктор объекта"
let user = {};  // синтаксис "литерал объекта"

let obj = {1: 'a', 2: 'b', 3: 'c'}; //при использованиее "литерала" можно сразу добавить свойтсва
```

## Ключи объекта
---
1. Ключ объекта всегда строкового (`String`) или символьного(`Sybmol`) типа.
	* могут содержать несколько слов
1. При обращении к ключу без кавычек можно писать, не все ключи, а только те, которые удовлетворяют следующим ограничениям: 
	1. они не могут начинаться с цифры
	1. не могут содержать внутри себя дефис, пробел и тому подобные вещи
	```javascript
	let obj = {'1key': 'a', 'key-2': 'b', key3: 'c'}; //только в кавычках
	```

## Свойства объекта
---
* к значению(свойству) объекта можно обращаться через квадратные скобки `[]` или через точку `.`  
	1. через «точку» `.`
		```javascript
		console.log(obj.key1);
		```
	1. для ключей объекта которые состоят из нескольких слов, доступ к значению «через точку» не работает и нужно обращаться через `[]`
		```javascript
		console.log(obj['1 key']);
		console.log(obj['key 2']);
		```
* при обращении к свойству объекта через "точку" имя этого свойства не может хранится в переменной, а при обращении через синтаксис массива может, `[value]` - можно в качестве ключа подставить переменную
* в отличие от многих других языков, особенность JavaScript-объектов в том, что можно получить доступ к любому свойству. Даже если свойства не существует – ошибки не будет!!!
	* при обращении к свойству, которого нет, возвращается undefined. Это позволяет просто проверить существование свойства
	* но свойство может быть задано значением `undefined` и в таком случае лучше осуществлять проверку существования свойства: `"key" in obj` (оператор `in` см. ниже)
* свойства упорядочены особым образом: свойства с целочисленными ключами сортируются по возрастанию, остальные располагаются в порядке создания. Термин «целочисленное свойство» означает строку, которая может быть преобразована в целое число и обратно без изменений.  
* объекты хранятся и копируются «по ссылке»
* объекты объявленные как константы, JavaScript не разрешает изменять значения этих констант, но изменять свойств объектов можно.
* два объекта равны только в том случае, если это один и тот же объект

Доп.сведения:  
 * Объект называется «простым объектом» («plain object») или просто `Object`.  
 * В JavaScript есть много других типов объектов:
	* Array для хранения упорядоченных коллекций данных
	* Date для хранения информации о дате и времени
	* Error для хранения информации об ошибке  
	… и так далее.

## Добавление элементов(свойств) в объекты
---
В объекты можно добавлять новые элементы ("на лету"), записывая их в нужные ключи. Давайте посмотрим, как это делается. Пусть у нас есть следующий объект:
```javascript
let obj = {};
```

Добавим в него новые элементы:
```javascript
obj['a'] = 1;
obj['b'] = 2;
obj['c'] = 3;
```
или
```javascript
obj.a = 1;
obj.b = 2;
obj.c = 3;
```

## Флаги свойств и методов
---
Помимо значения `value`, свойства объекта имеют три специальных атрибута (так называемые «флаги»).
* `writable` – если `true`, свойство можно изменить, иначе оно только для чтения.
* `enumerable` – если `true`, свойство перечисляется в циклах, в противном случае циклы его игнорируют.
* `configurable` – если `true`, свойство можно удалить, а эти атрибуты можно изменять, иначе этого делать нельзя.

1. Для изменения флагов у одного свойства:
	1. `Object.getOwnPropertyDescriptor(obj, propertyName) :Object` - метод позволяет получить полную информацию о свойстве.
		* `obj` - объект, из которого мы получаем информацию
		* `propertyName` - имя свойства

		```javascript
		let user = {
			name: "John"
		};

		let descriptor = Object.getOwnPropertyDescriptor(user, 'name');

		alert( JSON.stringify(descriptor, null, 2 ) );
		/* дескриптор свойства:
		{
		"value": "John",
		"writable": true,
		"enumerable": true,
		"configurable": true
		}
		*/
		```

	1. `Object.defineProperty(obj, propertyName, {descriptorName: value}) :Object` - метод чтобы изменить флаги.  
	Если свойство существует, `defineProperty` обновит его флаги. В противном случае метод создаёт новое свойство с указанным значением и флагами; если какой-либо флаг не указан явно, ему присваивается значение `false`.
		* `obj, propertyName` - объект и его свойство, для которого нужно применить дескриптор
		* `{descriptorName: value}` - объект применяемых дескрипторов - свойств и значений

1. Для изменения флагов сразу у нескольких свойств:
	1. `Object.defineProperties` - метод чтобы изменить флаги у множества свойств сразу
		```javascript
		Object.defineProperties((obj, {
			propertyName: {descriptorName1: value, descriptorName2: value, ...},
			propertyName: {descriptorName1: value, descriptorName2: value, ...},
			...,
		}) :Object)
		```

	1. `Object.getOwnPropertyDescriptors(obj); :Object` - получить все дескрипторы свойств сразу
	`Object.getOwnPropertyDescriptors` возвращает дескрипторы всех свойств.

### Глобальное запечатывание объекта
---
Дескрипторы свойств работают на уровне конкретных свойств.  
Но ещё есть методы, которые ограничивают доступ ко всему объекту:
* `Object.preventExtensions(obj)` - запрещает добавлять новые свойства в объект.
* `Object.seal(obj)` - запрещает добавлять/удалять свойства. Устанавливает configurable: false для всех существующих свойств.
* `Object.freeze(obj)` - запрещает добавлять/удалять/изменять свойства. Устанавливает configurable: false, writable: false для всех существующих свойств.

А также есть методы для их проверки:
* `Object.isExtensible(obj)` - возвращает false, если добавление свойств запрещено, иначе true.
* `Object.isSealed(obj)` - возвращает true, если добавление/удаление свойств запрещено и для всех существующих свойств установлено configurable: false.
* `Object.isFrozen(obj)` - возвращает true, если добавление/удаление/изменение свойств запрещено, и для всех текущих свойств установлено configurable: false, writable: false.

На практике эти методы используются редко.

## Cвойства-аксессоры (геттеры и сеттеры)
---
<u>Cвойства-аксессоры (accessor properties)</u> - по своей сути это функции, которые используются для присвоения и получения значения, но во внешнем коде они выглядят как обычные свойства объекта.

```javascript
let obj = {
  get propName() {
    // геттер, срабатывает при чтении obj.propName
  },

  set propName(value) {
    // сеттер, срабатывает при записи obj.propName = value
  }
};

//Например
let user = {
  	name: "John",
  	surname: "Smith",

  	get fullName() {
    	return `${this.name} ${this.surname}`;
  	},
	set fullName(value) {
    	[this.name, this.surname] = value.split(" ");
  }
};

alert(user.fullName); // John Smith
```

### Дескрипторы свойств-аксессоров get и set
---
Свойства-аксессоры не имеют `value` и `writable`, но взамен предлагают функции `get` и `set`.

То есть, дескриптор аксессора может иметь:
* `get` – функция без аргументов, которая сработает при чтении свойства,
* `set` – функция, принимающая один аргумент, вызываемая при присвоении свойства,
* `enumerable` – то же самое, что и для свойств-данных,
* `configurable` – то же самое, что и для свойств-данных.

```javascript
let user = {
  name: "John",
  surname: "Smith"
};

Object.defineProperty(user, 'fullName', {
  get() {
    return `${this.name} ${this.surname}`;
  },

  set(value) {
    [this.name, this.surname] = value.split(" ");
  }
});

alert(user.fullName); // John Smith

for(let key in user) alert(key); // name, surname
```

* У аксессоров есть интересная область применения – они позволяют в любой момент взять «обычное» свойство и изменить его поведение, поменяв на геттер и сеттер.

## Методы объектов
---
```javascript
// эти объекты делают одно и то же
user = {
  sayHi: function() {
    alert("Привет");
  }
};

// сокращённая запись выглядит лучше, не так ли?
user = {
  sayHi() { // то же самое, что и "sayHi: function(){...}"
    alert("Привет");
  }
};
```

|Свойство|Синтаксис|Пример|
|-|-|-|
|`keys` (массив ключей объекта)|Object.keys(объект) : Array|<code>let obj = {a: 1, b: 2, c: 3};<br>let keys = Object.keys(obj);<br>console.log(keys); //a, b, c</code>
|`in` (проверка наличия свойства в объекте)|'свойство' in 'объект' : Boolean|<code>let obj = {a: 1, b: 2, c: 3};<br>console.log('b' in obj); //выведет true</code>
|`delete` (удаление элементов объектов)|'delete Объект.свойство : null|<code>let obj = {a: 1, b: 2, c: 3};<br>delete obj.b;<br>console.log(obj); // выведет {a: 1, c: 3}</code>
---

## Клонирование и объединение объектов Object.assign
---
`Object.assign(dest, [src1, src2, src3...]) : object`
1. Первый аргумент `dest` — целевой объект.
1. Остальные аргументы `src1, ..., srcN` (может быть столько, сколько необходимо) являются исходными объектами
1. Метод копирует свойства всех исходных объектов `src1, ..., srcN` в целевой объект `dest`. Другими словами, свойства всех аргументов, начиная со второго, копируются в первый объект. Если скопированное имя свойства уже существует, оно будет перезаписано.
1. Возвращает объект `dest`.

Для того чтобы избежать одинаковых ссылок на объект внутри текущего и копируемого объекта необходимо реализовать глубокое клонирование, используя рекурсию. Или, чтобы не изобретать велосипед заново, возьмите готовую реализацию, например `_.cloneDeep(obj)` из библиотеки JavaScript `lodash`.  
Также мы можем использовать глобальный метод `structuredClone()`, который позволяет сделать полную копию объекта. К сожалению он поддерживается только современными браузерами.

## Методы объекта this
---
Для доступа к информации внутри объекта метод может использовать ключевое слово `this`.  
Значение `this` – это объект «перед точкой», который используется для вызова метода(свойства).  

Свойства работы с `this`:
* `this` инициализируется во время выполненния
* Вызов без объекта: `this == undefined` в строгом режиме, в нестрогом режиме значением this в таком случае будет глобальный объект (window в браузерe).  
* У стрелочных функций нет «this». Стрелочные функции особенные: у них нет своего «собственного» this. Если мы ссылаемся на this внутри такой функции, то оно берётся из внешней «нормальной» функции.

## Функция конструктор new
---
Функции-конструкторы или просто конструкторы, являются обычными функциями, но существует общепринятое соглашение именовать их с !!!заглавной буквы!!!.  
Функции-конструкторы следует вызывать только с помощью `new`. Такой вызов подразумевает создание пустого `this` в начале и возврат заполненного в конце.  
Обычный синтаксис создания объекта `{...}` позволяет создать только один объект. Но зачастую нам нужно создать множество похожих, однотипных объектов, таких как пользователи, элементы меню и так далее.  
Это можно сделать при помощи функции-конструктора и оператора `"new"`.
Другими словами, `new User(...)` делает что-то вроде:
```javascript
function User(name) {
  // this = {};  (неявно)

  // добавляет свойства к this
  this.name = name;
  this.isAdmin = false;

  // return this;  (неявно)
}
```
Давайте ещё раз отметим – технически любая функция (кроме стрелочных функций, поскольку у них нет `this`) может использоваться в качестве конструктора. Его можно запустить с помощью `new`, и он выполнит выше указанный алгоритм. Подобные функции должны начинаться с заглавной буквы – это общепринятое соглашение, чтобы было ясно, что функция должна вызываться с помощью `«new»`.
> Другими словами new означает вернуть this

### <u>`new function() { … }`</u>
Если в нашем коде присутствует большое количество строк, создающих один сложный объект, то мы можем обернуть их в функцию-конструктор, которая будет немедленно вызвана, вот так:
```javascript
// создаём функцию и сразу же вызываем её с помощью new
let user = new function() {
  this.name = "John";
  this.isAdmin = false;

  // ...другой код для создания пользователя
  // возможна любая сложная логика и инструкции
  // локальные переменные и так далее
};
```

### <u>`new.target`</u> - проверка на вызов в режиме конструктора
Используя специальное свойство `new.target` внутри функции, мы можем проверить, вызвана ли функция при помощи оператора `new` или без него.  

В случае обычного вызова функции `new.target` будет `undefined`. Если же она была вызвана при помощи `new`, `new.target` будет равен коду самой функции.

### <u>`return`</u> - возврат значения из конструктора, 
Обычно конструкторы не имеют оператора `return`. Их задача – записать все необходимое в `this`, и это автоматически становится результатом.  
Но если return всё же есть, то применяется простое правило:
* При вызове `return` с объектом, вместо `this` вернётся объект.
* При вызове `return` с примитивным значением, оно проигнорируется.

Другими словами, `return` с объектом возвращает этот объект, во всех остальных случаях возвращается `this`.  
Обычно у конструкторов отсутствует `return`. Здесь мы упомянули особое поведение с возвращаемыми объектами в основном для полноты картины.

## Опциональная цепочка ?.
---
Новая возможность языка.  
Опциональная цепочка имеет три формы:
* `obj?.prop` – возвращает obj.prop если obj существует, в противном случае undefined.
* `obj?.[prop]` – возвращает obj[prop] если obj существует, в противном случае undefined.
* `obj.method?.()` – вызывает obj.method(), если obj.method существует, в противном случае возвращает undefined.

Опциональная цепочка ?. останавливает вычисление и возвращает undefined, если значение перед ?. равно undefined или null и позволяет продолжить вычисление, если это не так.

Цепочка `?.` позволяет безопасно получать доступ к вложенным свойствам.

Тем не менее, мы должны использовать `?.` осторожно, только там, где по логике кода допустимо, что левая часть не существует. Чтобы он не скрывал от нас ошибки программирования, если они возникнут.

## Преобразование объектов в примитивы
---
<u>Правила преобразования:</u>
1. `Boolean` - К логическому типы нельзя преобразовать, т.к. все объекта `true`.
1. `Integer` - Числовое преобразование происходит, когда мы вычитаем объекты или применяем математические функции. Например, объекты `Date` (которые будут рассмотрены в главе Дата и время) могут быть вычтены, и результатом `date1 - date2` будет разница во времени между двумя датами.
1. `String` - Что касается преобразований к строке – оно обычно происходит, когда мы выводим на экран объект при помощи `alert(obj)` и в подобных контекстах.
1. Мы можем реализовать свои преобразования к строкам и числам, используя специальные объектные методы см. ниже.

### Хинты
---
Существует три варианта преобразования типов, которые происходят в различных ситуациях. Они называются «хинтами», как описано в спецификации.  

Преобразование объекта в примитив вызывается автоматически многими встроенными функциями и операторами, которые ожидают примитив в качестве значения.

Существует всего 3 типа (хинта) для этого:
* `"string"` (для alert и других операций, которым нужна строка)
* `"number"` (для математических операций)
* `"default"` (происходит редко, когда оператор «не уверен», какой тип ожидать? для некоторых других операторов, обычно объекты реализуют его как "number".
	* Например, бинарный плюс + может работать как со строками (объединяя их в одну), так и с числами (складывая их). Поэтому, если бинарный плюс получает объект в качестве аргумента, он использует хинт "default" для его преобразования.
	* Также, если объект сравнивается с помощью == со строкой, числом или символом, тоже неясно, какое преобразование следует выполнить, поэтому используется хинт "default".

<u>Алгоритм преобразования таков объектов в JavaScript:</u>
1. Сначала вызывается метод `obj[Symbol.toPrimitive](hint)`, если он существует,
1. В случае, если хинт равен `"string"`
    происходит попытка вызвать` obj.toString()` и `obj.valueOf()`, смотря что есть.
1. В случае, если хинт равен `"number"` или `"default"`
    происходит попытка вызвать `obj.valueOf()` и `obj.toString()`, смотря что есть.

Все эти методы должны возвращать примитив (если определены).

На практике часто бывает достаточно реализовать только `obj.toString()` в качестве универсального метода для преобразований к строке, который должен возвращать удобочитаемое представление объекта для целей логирования или отладки.

### Методы преобразования объектов в примитивы:
---
По умолчанию обычный объект имеет следующие методы `toString` и `valueOf`:
1. Метод `toString` возвращает строку `"[object Object]"`.
1. Метод `valueOf` возвращает сам объект.
```javascript
let user = {name: "John"};

alert(user); // [object Object]
alert(user.valueOf() === user); // true
```

<u>`Symbol.toPrimitive`</u> - встроенный символ(метод) с именем `Symbol.toPrimitive`, который следует использовать для обозначения метода преобразования, вот так:

```javascript
obj[Symbol.toPrimitive] = function(hint) {
  // вот код для преобразования этого объекта в примитива
  // он должен вернуть примитивное значение
  // hint = чему-то из "string", "number", "default"
};
```
Если метод `Symbol.toPrimitive` существует, он используется для всех хинтов, и больше никаких методов не требуется.
Например, здесь объект user реализует его:
```javascript
let user = {
  name: "John",
  money: 1000,

[Symbol.toPrimitive](hint) {
    alert('hint: ' + hint);
    return hint == "string" ? 'name: + this.name' : this.money;
  }
};

// демонстрация результатов преобразований:
alert(user); // hint: string -> {name: "John"}
alert(+user); // hint: number -> 1000
alert(user + 500); // hint: default -> 1500
```

> В отсутствие `Symbol.toPrimitive` и `valueOf`, `toString` обработает все примитивные преобразования.

<u>`toString/valueOf`</u> - если нет `Symbol.toPrimitive`, тогда JavaScript пытается найти методы `toString` и `valueOf`:
1. Для хинта `"string"`: вызвать метод `toString`, а если он не существует или возвращает объект вместо примитивного значения, то `valueOf` (таким образом, `toString` имеет приоритет при строковом преобразовании).
1. Для других хинтов: вызвать метод `valueOf`, а если он не существует или возвращает объект вместо примитивного значения, то `toString` (таким образом, `valueOf` имеет приоритет для математических операций).

```javascript
let user = {
  name: "John",
  money: 1000,

  // для хинта равного "string"
  toString() {
    return `{name: "${this.name}"}`;
  },

  // для хинта равного "number" или "default"
  valueOf() {
    return this.money;
  }

};

alert(user); // toString -> {name: "John"}
alert(+user); // valueOf -> 1000
alert(user + 500); // valueOf -> 1500
```

> Преобразование может вернуть любой примитивный тип  
	Важная вещь, которую следует знать обо всех методах преобразования примитивов, заключается в том, что они не обязательно возвращают подсказанный хинтом примитив.  
	Нет никакого контроля над тем, вернёт ли toString именно строку, или чтобы метод Symbol.toPrimitive возвращал именно число для хинта "number".  
	Единственное обязательное условие: эти методы должны возвращать примитив, а не объект.

## Перебираемые объекты
---
Перебираемые(итерируемые) объекты – это обобщение массивов. Концепция, которая позволяет использовать любой объект в цикле `for..of`.

Конечно же, сами массивы являются перебираемыми объектами. Но есть и много других встроенных перебираемых объектов, например: `string`.  

### Symbol.iterator (для перебираеммых объектов)
---
`Symbol.iterator` - специальный встроенный `Symbol`, созданный сделать объект итерируеммым и позволить `for..of` работать с ним.

1. Когда цикл `for..of` запускается, он вызывает этот метод один раз (или выдаёт ошибку, если метод не найден). Этот метод должен вернуть итератор – объект с методом `next()`.
1. Дальше `for..of` работает только с этим возвращённым объектом.
1. Когда `for..of` хочет получить следующее значение, он вызывает метод `next()` этого объекта.
1. Результат вызова `next()` должен быть код `{done: Boolean, value: any}`, где `done=true` означает, что цикл завершён, в противном случае `value` содержит очередное значение.

Вот полная реализация `range` с пояснениями:
```javascript
let range = {
  from: 1,
  to: 5
};

// 1. вызов for..of сначала вызывает эту функцию
range[Symbol.iterator] = function() {

  // функция возвращает объект итератора:
  // 2. Далее, for..of работает только с этим итератором, запрашивая у него новые значения
  return {
    current: this.from,
    last: this.to,

    // 3. next() вызывается на каждой итерации цикла for..of
    next() {
      // 4. он должен вернуть значение в виде объекта {done:.., value :...}
      if (this.current <= this.last) {
        return { done: false, value: this.current++ };
      } else {
        return { done: true };
      }
    }
  };
};

// теперь работает!
for (let num of range) {
  alert(num); // 1, затем 2, 3, 4, 5
}
```

### Строка – перебираемый объект
---
Среди встроенных перебираемых объектов наиболее широко используются массивы и строки.

Для строки `for..of` перебирает символы:
```javascript
for (let char of "test") {
  // срабатывает 4 раза: по одному для каждого символа
  alert( char ); // t, затем e, затем s, затем t
}
```

### Итерируемые объекты и псевдомассивы
---
Есть два официальных термина, которые очень похожи, но в то же время сильно различаются. Поэтому убедитесь, что вы как следует поняли их, чтобы избежать путаницы.

<u>Итерируемые объекты</u> – это объекты, которые реализуют метод `Symbol.iterator`, как было описано выше.  
<u>Псевдомассивы</u> – это объекты, у которых есть индексы и свойство length, то есть, они выглядят как массивы.

При использовании JavaScript в браузере или других окружениях мы можем встретить объекты, которые являются итерируемыми или псевдомассивами, или и тем, и другим.

А вот объект, который является псевдомассивом, но его нельзя итерировать:
```javascript
let arrayLike = { // есть индексы и свойство length => псевдомассив
  0: "Hello",
  1: "World",
  length: 2
};

// Ошибка (отсутствует Symbol.iterator)
for (let item of arrayLike) {}
```
> Что у них общего? И итерируемые объекты, и псевдомассивы – это обычно не массивы, у них нет методов `push`, `pop` и т.д. Довольно неудобно, если у нас есть такой объект и мы хотим работать с ним как с массивом. Например, мы хотели бы работать с range, используя методы массивов. Как этого достичь? см. далее

## Array.from
---
`Array.from(arrayLike); :Array` - универсальный метод, который принимает итерируемый объект или псевдомассив и делает из него «настоящий» `Array`. После этого мы уже можем использовать методы массивов.
```javascript
let arrayLike = {
  0: "Hello",
  1: "World",
  length: 2
};

let arr = Array.from(arrayLike); // (*)
alert(arr.pop()); // World (метод работает)
```

`Array.from(obj[, mapFn, thisArg]);` - полный синтаксис.  
* первый аргумент, это преобразуеммый объект.
* необязательный второй аргумент может быть функцией, которая будет применена к каждому элементу перед добавлением в массив, а `thisArg` позволяет установить `this` для этой функции.

```javascript
// range взят из примера выше

// возводим каждое число в квадрат
let arr = Array.from(range, num => num * num);

alert(arr); // 1,4,9,16,25
```

# Тип данных Symbol
`Symbol`(символ) - представляет собой уникальный идентификатор.  
* Создаются новые символы с помощью функции `Symbol();`:
	```javascript
	// Создаём новый символ - id
	let id = Symbol();
	```
* При создании, символу можно дать описание (также называемое имя), в основном использующееся для отладки кода:
	```javascript
	// Создаём символ id с описанием (именем) "id"
	let id = Symbol("id");
	```
* Символы гарантированно уникальны. Даже если мы создадим множество символов с одинаковым описанием, это всё равно будут разные символы. Описание – это просто метка, которая ни на что не влияет.  
* Символы не преобразуются автоматически в строки. Если же мы действительно хотим вывести `Symbol` как строку, то необходимо явно преобразовать его с помощью метода `.toString()`, вот так:
	```javascript
	let id = Symbol("id");
	alert(id.toString()); // Symbol(id), теперь работает
	```
	Или мы можем обратиться к свойству `symbol.description`, чтобы вывести только описание:
	```javascript
	let id = Symbol("id");
	alert(id.description); // id
	```
*  Символы в литеральном объекте:
	Если мы хотим использовать символ при литеральном объявлении объекта {...}, его необходимо заключить в квадратные скобки.
	```javascript
	let id = Symbol("id");

	let user = {
	name: "Вася",
	[id]: 123 // просто "id: 123" не сработает
	};
	```
	Это вызвано тем, что нам нужно использовать значение переменной id в качестве ключа, а не строку «id».
* Символы игнорируются циклом `for…in`
* А вот `Object.assign`, в отличие от цикла `for..in`, копирует и строковые, и символьные свойства.  
Здесь нет никакого парадокса или противоречия. Так и задумано. Идея заключается в том, что, когда мы клонируем или объединяем объекты, мы обычно хотим скопировать все свойства (включая такие свойства с ключами-символами, как, например, id в примере выше).

## Глобальные символы Symbol.for(key), Symbol.keyFor
---
Глобальный реестр символов - мы можем создавать в нём символы и обращаться к ним позже, и при каждом обращении нам гарантированно будет возвращаться один и тот же символ.  

`Symbol.for(key);` - проверяет глобальный реестр и, при наличии в нём символа с именем `key`, возвращает его, иначе же создаётся новый символ `Symbol(key)` и записывается в реестр под ключом `key`.
```javascript
// читаем символ из глобального реестра и записываем его в переменную
let id = Symbol.for("id"); // если символа не существует, он будет создан

// читаем его снова и записываем в другую переменную (возможно, из другого места кода)
let idAgain = Symbol.for("id");

// проверяем -- это один и тот же символ
alert( id === idAgain ); // true
```
---
`Symbol.keyFor(symbol);` - принимает глобальный символ и возвращает его имя. Внутри метода `Symbol.keyFor` используется глобальный реестр символов для нахождения имени символа. Так что этот метод не будет работать для неглобальных символов. Если символ неглобальный, метод не сможет его найти и вернёт `undefined`.
```javascript
// получаем символ по имени
let sym = Symbol.for("name");
let sym2 = Symbol.for("id");

// получаем имя по символу
alert( Symbol.keyFor(sym) ); // name
alert( Symbol.keyFor(sym2) ); // id
```

## Системные символы
---
Существует множество «системных» символов, использующихся внутри самого JavaScript, и мы можем использовать их, чтобы настраивать различные аспекты поведения объектов.  
Эти символы перечислены в спецификации в таблице Well-known symbols:
* `Symbol.hasInstance`
* `Symbol.isConcatSpreadable`
* `Symbol.iterator`
* `Symbol.toPrimitive`
…и так далее.  

В частности, `Symbol.toPrimitive` позволяет описать правила для объекта, согласно которым он будет преобразовываться к примитиву. Мы скоро увидим его применение.  
С другими системными символами мы тоже скоро познакомимся, когда будем изучать соответствующие возможности языка.

# Массивы
* массивы это `Object`, у которых прототипом является `Array`
	```javascript
	let arr = [];
	```
* `new Array([number])` - ещё один вариант синтаксиса для создания массива.  
	Необязательное начение `number` создаёт массив с заданной длиной, но без элементов.
* элементы массива нумеруются, начиная с нуля
* length - длина массива находится с помощью свойства `length`
	```javascript
	let arr = ['a', 'b', 'c'];
	console.log(arr.length) // выведет 3
	```
* `Array` следует считать особой структурой, позволяющей работать с упорядоченными данными. Для этого массивы предоставляют специальные методы. Массивы тщательно настроены в движках JavaScript для работы с однотипными упорядоченными данными, поэтому, пожалуйста, используйте их именно в таких случаях. Если вам нужны произвольные ключи, вполне возможно, лучше подойдёт обычный `Object{}`.

* cравнение массивов (`==`), если мы всё же сравниваем массивы с помощью `==`, то они никогда не будут одинаковыми, если только мы не сравним две переменные, которые ссылаются на один и тот же массив.  
Оператор строгого равенства `===` ещё проще, так как он не преобразует типы.  
Так как же сравнить массивы?
Это просто: не используйте оператор ==. Вместо этого сравните их по элементам в цикле или используя методы итерации.

### Изменение элементов массива в JavaScript
---
```javascript
arr[0] = '!';
console.log(arr); // выведет ['!', 'b', 'c']
```

### Варианты неправильного применения массива
---
1. Добавление нечислового свойства, например: `arr.test = 5;`
1. Создание «дыр», например: добавление `arr[0]`, затем `arr[1000]` (между ними ничего нет).
1. Заполнение массива в обратном порядке, например:` arr[1000], arr[999]` и т.д.

## Специальные свойства массивов
### `array.at(i)`
---
Новая возможность языка.  
`array.at(i);` - обращение к элементам массива(плюс обращение с конца массива через минус ключ):
* это ровно то же самое, что и `arr[i]`, если i >= 0.
* для отрицательных значений i, он отступает от конца массива.
	```javascript
	let fruits = ["Apple", "Orange", "Plum"];
	// то же самое, что и fruits[fruits.length-1]
	alert(fruits.at(-1)); //Plum
	```

### `Array.isArray(массив_или_что_то_другое);`
---
`Array.isArray(массив_или_что_то_другое);` - позволяет различать массивы и объекты
Массивы на самом деле являются частным случаем объектов. В этом можно убедится, если проверить массив через оператор `typeof`
```javascript
alert(typeof {}); // object
alert(typeof []); // тоже object

alert(Array.isArray({})); // false
alert(Array.isArray([])); // true

```

## Деструктуризация массивов или объектов
---
<u>Деструктуризации массива (объекта)</u> - данная операция предназначена для массовой записи элементов массива в переменные в одну строчку кода.  

Синтаксис для массива: `let [var1, var2, var1] = [array|function:Array];`  
Синтаксис для объекта: `let {var1, var2} = {var1:…, var2:…};`  
* При деструктуризации объектов имена переменных должны совпадать с ключами объекта, порядок переменных и элементов в объекте не имеет значения.
> Можно сделать так, чтобы имена переменных не совпадали с именами ключей объекта: `let {year: y, month: m, day: d} =  {year:…, month:…, day:…};`  
Как вы видите, слева от знака `=` в квадратных скобках перечисляются имена переменных. Эти переменные массово объявляются через `let`, который располагается перед открывающей скобкой. В результате операции в первую переменную запишется первый элемент массива (с ключом ноль), во вторую переменную - второй, в третью переменную - третий. 
* Массив для деструктуризации не обязательно должен хранится в переменной. Он также может быть результатом работы функции.
```javascript  
let [year, month, day] = func();
```
* Можно начать записывать в переменные не сначала массива, а пропустить некоторые значения.
```javascript
let arr = [2025, 12, 31]; 
let [,, day] = arr;
```
* Если в массиве меньше элементов, чем переменных, то в "лишние" переменные запишется undefined.
* Если в массиве больше элементов, чем переменных - лишние элементы никуда не запишутся и ничего страшного не произойдет.
* Если в массиве больше элементов, чем переменных, при необходимости лишние элементы можно записать в массив с помощью оператора "троеточия" `...`
```javascript
let arr = [2025, 12, 31, 23, 59, 59];
let [year, month, day, ...time] = arr;
```
* Для переменных можно указывать значения по умолчанию. В этом случае, если переменной не хватит элемента массива - возьмется значение по умолчанию.
```javascript
let arr = [2025, 12];
let [year, month, day = 1] = arr;
```
* В качестве значения по умолчанию можно также указывать функцию.
```javascript
let [year, month, day = func()] = arr;
```
* Деструктуризация имеет еще одну очень важную область применения - передача параметров функций. Суть в следующем: если функция принимает в качестве параметра массив, мы можем задать прямо в объявлении функции то, как деструктуризировать этот массив.
Давайте посмотрим на примере. Пусть у нас есть функция, параметром принимающая массив с годом, месяцем и днем:
```javascript
func([2025, 12, 31]);
            
function func([year, month, day]) {
    console.log(year);  // выведет 2025
	console.log(month); // выведет 12
	console.log(day);   // выведет 31
}
```

## Оператор(rest) ...
---
`...` - оператор rest позволяет получить все лишние параметры в виде массива. Для этого в функцию добавляется еще один параметр (обязательно последним), перед которым пишутся 3 точки:
```javascript
function func(a, b, ...rest) { //Переменная rest является массивом из оставшихся элементов переданных в функцию
}
```

## Оператор(spread) ...[массив]
---
`...[array]` - оператор spread стоит перед массивом, он разделяет этот массив на отдельные значения, превращая массив в набор параметров, необходимых для вызова функции.
```javascript
func(...[1, 2, 3]);
```

# Map
`Map` – это коллекция ключ/значение, как и `Object`. Но основное отличие в том, что `Map` позволяет использовать ключи любого(mixed) типа.

Методы и свойства `Map`:
* `new Map()` – создаёт коллекцию.
* `map.set(key, value)` – записывает по ключу `key` значение `value`.
* `map.get(key)` – возвращает значение по ключу или `undefined`, если ключ `key` отсутствует.
* `map.has(key)` – возвращает true, если ключ `key` присутствует в коллекции, иначе `false`.
* `map.delete(key)` – удаляет элемент (пару «ключ/значение») по ключу `key`.
* `map.clear()` – очищает коллекцию от всех элементов.
* `map.size` – свойство, возвращает текущее количество элементов.

```javascript
let map = new Map();

map.set("1", "str1");    // строка в качестве ключа
map.set(1, "num1");      // цифра как ключ
map.set(true, "bool1");  // булево значение как ключ

// помните, обычный объект Object приводит ключи к строкам?
// Map сохраняет тип ключей, так что в этом случае сохранится 2 разных значения:
alert(map.get(1)); // "num1"
alert(map.get("1")); // "str1"

alert(map.size); // 3
```

> Использование объектов в качестве ключей – одна из наиболее заметных и важных функций `Map`. Это то что невозможно для `Object`, т.к. строка в качестве ключа в `Object` – это нормально, но мы не можем использовать другой `Object` в качестве ключа в `Object`.  

Каждый вызов `map.set()` возвращает объект `map`, так что мы можем объединить вызовы в цепочку:
```javascript
map.set("1", "str1")
  .set(1, "num1")
  .set(true, "bool1");
```

## Перебор Map
---
Для перебора коллекции Map есть 3 метода:
* `map.keys()` – возвращает итерируемый объект по ключам,
* `map.values()` – возвращает итерируемый объект по значениям,
* `map.entries()` – возвращает итерируемый объект по парам вида [ключ, значение], этот вариант используется по умолчанию в `for..of`.

Кроме этого, Map имеет встроенный метод `forEach`, схожий со встроенным методом массивов `Array`:
```javascript
// выполняем функцию для каждой пары (ключ, значение)
recipeMap.forEach((value, key, map) => {
  alert(`${key}: ${value}`); // огурец: 500 и так далее
});
```

## `Object.entries`: Map из Object
---
При создании `Map` мы можем указать массив (или другой итерируемый объект) с парами ключ-значение для инициализации, но если у нас уже есть обычный объект, и мы хотели бы создать `Map` из него, то поможет встроенный метод `Object.entries(obj)`, который получает объект и возвращает массив пар ключ-значение для него, как раз в этом формате.

Так что мы можем создать `Map` из обычного объекта следующим образом:
```javascript
let obj = {
  name: "John",
  age: 30
};

let map = new Map(Object.entries(obj));

alert( map.get('name') ); // John
```

## `Object.fromEntries`: Object из Map
---
`Object.fromEntries` - получив массив пар вида [ключ, значение], он создаёт из них объект:
```javascript
let prices = Object.fromEntries([
  ['banana', 1],
  ['orange', 2],
  ['meat', 4]
]);

// prices = { banana: 1, orange: 2, meat: 4 }

alert(prices.orange); // 2
```

# Set
Объект `Set` – это особый вид коллекции: «множество» значений (без ключей), где каждое значение может появляться только один раз.
Его основные методы это:
* `new Set(iterable)` – создаёт `Set`, и если в качестве аргумента был предоставлен итерируемый объект (обычно это массив), то копирует его значения в новый `Set`.
* `set.add(value)` – добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект `set`.
* `set.delete(value)` – удаляет значение, возвращает `true`, если `value` было в множестве на момент вызова, иначе `false`.
* `set.has(value)` – возвращает `true`, если значение присутствует в множестве, иначе `false`.
* `set.clear()` – удаляет все имеющиеся значения.
* `set.size` – возвращает количество элементов в множестве.

> Основная «изюминка» – это то, что при повторных вызовах set.add() с одним и тем же значением ничего не происходит, за счёт этого как раз и получается, что каждое значение появляется один раз. 

> Альтернативой множеству Set может выступать массив для хранения гостей и дополнительный код для проверки уже имеющегося элемента с помощью arr.find. Но в этом случае будет хуже производительность, потому что arr.find проходит весь массив для проверки наличия элемента. Множество Set лучше оптимизировано для добавлений, оно автоматически проверяет на уникальность.

Set имеет те же встроенные методы, что и Map:
* `set.keys()` – возвращает перебираемый объект для значений,
* `set.values()` – то же самое, что и `set.keys()`, присутствует для обратной совместимости с `Map`,
* `set.entries()` – возвращает перебираемый объект для пар вида [значение, значение], присутствует для обратной совместимости с `Map`.

# WakeMap
`WeakMap` – это Map-подобная коллекция, позволяющая использовать в качестве ключей только объекты, и автоматически удаляющая их вместе с соответствующими значениями, как только они становятся недостижимыми иными путями.  

`WeakMap()` – отличается от `new Map()`, тем что:
1. не предотвращает удаление объектов сборщиком мусора, когда эти объекты выступают в качестве ключей.
1. Ключи в `WeakMap` должны быть объектами, а не примитивами.
1. `WeakMap` не поддерживает перебор и методы `keys()`, `values()`, `entries()`, так что нет способа взять все ключи или значения из неё.  
	Присутсвуют только методы:
	1. `weakMap.get(key)`
    1. `weakMap.set(key, value)`
    1. `weakMap.delete(key)`
    1. `weakMap.has(key)`

# WeakSet
`WeakSet` – это Set-подобная коллекция, которая хранит только объекты и удаляет их, как только они становятся недостижимыми иными путями.  

Коллекция `WeakSet()` ведёт себя похоже:
1. Она аналогична `Set`, но мы можем добавлять в `WeakSet` только объекты (не примитивные значения).
1. Объект присутствует в множестве только до тех пор, пока доступен где-то ещё.
1. Как и `Set`, она поддерживает `add`, `has` и `delete`, но не `size`, `keys()` и не является перебираемой.

> Наиболее значительным ограничением WeakMap и WeakSet является то, что их нельзя перебрать или взять всё содержимое. Это может доставлять неудобства, но не мешает WeakMap/WeakSet выполнять их главную задачу – быть дополнительным хранилищем данных для объектов, управляемых из каких-то других мест в коде.

# Прототипы, наследование
## Прототипное наследование
---
<u>Прототипное наследование</u> - это когда мы хотим прочитать свойство из object , а оно отсутствует, JavaScript автоматически берёт его из прототипа.

`[[Prototype]]` - в JavaScript объекты имеют специальное скрытое свойство `[[Prototype]]` (так оно названо в спецификации), которое либо равно `null`, либо ссылается на другой объект. Этот объект называется «прототип».  
Есть только два ограничения:
	1. Ссылки не могут идти по кругу. JavaScript выдаст ошибку, если мы попытаемся назначить `__proto__` по кругу.
	1. Значение `__proto__` может быть объектом или null. Другие типы игнорируются.

* Свойство `[[Prototype]]` является внутренним и скрытым, но есть много способов задать его:
	* использование `__proto__` - данное свойство это исторически обусловленный геттер/сеттер для `[[Prototype]]`
	```javascript
	let animal = {
		eats: true
	};
	let rabbit = {
		jumps: true
	};

	rabbit.__proto__ = animal;
	```
	> Свойство `__proto__` немного устарело, оно существует по историческим причинам. Современный JavaScript предполагает, что мы должны использовать функции Object.getPrototypeOf/Object.setPrototypeOf вместо того, чтобы получать/устанавливать прототип. Мы также рассмотрим эти функции позже.
	
	> Неважно, где находится метод: в объекте или его прототипе. При вызове метода this — всегда объект перед точкой.

	> Цикл `for..in` проходит не только по собственным, но и по унаследованным свойствам объекта (у которых стоит флаг перечислимости).

## F.Prototype
---
<u>F.Prototype</u> - способ задания `[[Prototype]]` для объектов, создаваемых с помощью функции-конструктора.

* Свойство` F.prototype` (не путать с `[[Prototype]]`) устанавливает `[[Prototype]]` для новых объектов при вызове `new F()`.
* Значение `F.prototype` должно быть либо объектом, либо `null`. Другие значения не будут работать.
* Свойство "`prototype`" является особым, только когда оно назначено функции-конструктору, которая вызывается оператором `new`.

> В обычных объектах prototype не является чем-то особенным:
	```javascript
	let user = {
	name: "John",
	prototype: "Bla-bla" // никакой магии нет - обычное свойство
	};
	```

По умолчанию все функции имеют `F.prototype = { constructor: F }`, поэтому мы можем получить конструктор объекта через свойство "`constructor`".

## Встроенные прототипы
---
Все встроенные объекты следуют одному шаблону:
*	Методы хранятся в прототипах (`Array.prototype, Object.prototype, Date.prototype` и т.д.).
* Сами объекты хранят только данные (элементы массивов, свойства объектов, даты).
* Примитивы также хранят свои методы в прототипах объектов-обёрток: `Number.prototype, String.prototype, Boolean.prototype`. Только у значений `undefined` и `null` нет объектов-обёрток.
* Встроенные прототипы могут быть изменены или дополнены новыми методами. Но не рекомендуется менять их. Единственная допустимая причина – это добавление нового метода из стандарта, который ещё не поддерживается движком JavaScript.

## Методы прототипов, объекты без свойства `__proto__`
---
Свойство `__proto__` считается устаревшим, и по стандарту оно должно поддерживаться только браузерами.  

Современные же методы это:
* `Object.create(proto, [descriptors])` – создаёт пустой объект со свойством `[[Prototype]]`, указанным как `proto`, и необязательными дескрипторами свойств `descriptors`.
* `Object.getPrototypeOf(obj)` – возвращает свойство `[[Prototype]]` объекта obj.
* `Object.setPrototypeOf(obj, proto)` – устанавливает свойство `[[Prototype]]` объекта obj как `proto`.

```javascript
let animal = {
  eats: true
};

// создаём новый объект с прототипом animal
let rabbit = Object.create(animal);

alert(rabbit.eats); // true
alert(Object.getPrototypeOf(rabbit) === animal); // получаем прототип объекта rabbit

Object.setPrototypeOf(rabbit, {}); // заменяем прототип объекта rabbit на {}

//или
// клон obj c тем же прототипом (с поверхностным копированием свойств)
let clone = Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
```

> Не меняйте `[[Prototype]]` существующих объектов, если важна скорость.

Ещё методы:
* `Object.keys(obj) / Object.values(obj) / Object.entries(obj)` – возвращают массив всех перечисляемых собственных строковых ключей/значений/пар ключ-значение.
* `Object.getOwnPropertySymbols(obj)` – возвращает массив всех собственных символьных ключей.
* `Object.getOwnPropertyNames(obj)` – возвращает массив всех собственных строковых ключей.
* `Reflect.ownKeys(obj)` – возвращает массив всех собственных ключей.
* `obj.hasOwnProperty(key)` - возвращает true, если у obj есть собственное (не унаследованное) свойство с именем key.

Все методы, которые возвращают свойства объектов (такие как Object.keys и другие), возвращают «собственные» свойства. Если мы хотим получить и унаследованные, можно воспользоваться циклом `for..in`.


# Стандартные функции
## Функция вывода в html
---
* `document.write(123);` - вывод текста в документ HTML в поток
## Функция вывода в консоль
---
* `console.log()` - вывод в консоль `console.log(123);`

## Определение типа переменной(выражения) typeof (проверка типа)
---
Синтаксис: 'typeof переменной(выражения) : mixed
```javascript
console.log(typeof {}); // выведет 'object'
```

## Методы примитивов
---
<u>Методы примитовов</u> - это создание специального «объект-обёртка», который предоставляет нужную функциональность объекта, а после удаляется.
* Каждый примитив имеет свой собственный «объект-обёртку», которые называются: `String, Number, Boolean, Symbol и BigInt`. Таким образом, они имеют разный набор методов.
* Все примитивы, кроме `null` и `undefined`, предоставляют множество полезных методов.
* Формально эти методы работают с помощью временных объектов, но движки JavaScript внутренне очень хорошо оптимизируют этот процесс, так что их вызов не требует много ресурсов.

## Числовые методы примитивов оберток
---
* `num.toSring(base); : Integer` - возвращает строковое представление числа num в системе счисления base. base может варьироваться от 2 до 36 (по умолчанию 10).
* `num.toFixed([количество знаков в дробной части]); Integer` - производит округление числа до указанного знака в дробной части.
	Есть поддержка десятичных дробей: 0.25 + 0.75  
	Неточность вычисления в JavaScript: дроби хранятся в компьютерах в таком виде, что часто могут быть представлены неточно. В этом случае вас может ждать некоторый сюрприз, когда банальная операция выдает странный результат. Например:
	```javascript
	let a = 0.1 + 0.2;
	alert(a); // выведет 0.30000000000000004
	```
	Для борьбы с таким поведением можно применить специальный метод `toFixed`, выполняющий округление до заданного знака в дробной части.  
	```число.toFixed(число_до_которого_округлять); : String```  
	Давайте округлим наш результат:
	```javascript
	let a = 0.1 + 0.2;
	alert(a.toFixed(2)); // выведет '0.30'
	```
* `num.toPrecision(количество знаков); Integer` - округляет число до заданного знака (округление можно проводить не только в дробной части).

## Математические функции
---
* `Math.pow(число, степень); :Integer` - возводит число в заданную степень  
Альтернатива оператор **
* `Math.sqrt(положительное число); Integer` - возвращает квадратный корень числа
* `Math.round(число); Integer` - выполняет округление до ближайшего целого числа по правилам математического округления.  
* `Math.ceil(число); Integer` - производит округление дробного числа до целого всегда в большую сторону.
* `Math.floor(число); Integer` - производит округление числа до целых всегда в меньшую сторону.  
* `Math.max(число, число, число...); Integer` - возвращает максимальное число из группы чисел, переданных в функцию. Если ничего не передано, то будет возращено Infinity.  
* `Math.min(число, число, число...); Integer` - возвращает минимальное число из группы чисел, переданных параметрами. Если ничего не передано, то будет возращено Infinity.  
* `Math.random(); Integer` - возвращает случайное дробное число от 0 до 1.  
    * Случайное дробное число между min и max происходит так:
	```javascript
	function getRandomArbitary(min, max) {
		return Math.random() * (max - min) + min;
	}
	```
	*
	* Случайное целое число между min и max:
	```javascript
	function getRandomInt(min, max) {
		return Math.floor(Math.random() * (max - min + 1)) + min;
	}
	```
* `Math.abs(число); :Integer` - возвращает модуль числа, то есть из отрицательного числа делает положительное.  

## Строковые функции
---
* `строка.toUpperCase(); :String` - производит преобразование строки в верхний регистр (из маленьких букв делает большие).
* `строка.toLowerCase(); :String` - преобразует символы строки в нижний регистр (из больших букв делает маленькие).
* `строка.substr(откуда отрезать, [сколько символов отрезать]); :String` - возвращает подстроку из строки.  
	* Первый параметр задает номер позиции, с которого метод начнет вырезать символ (нумерация идет с нуля), а второй параметр - сколько символов отрезать.  
	* Первый параметр может принимать отрицательные значения. В этом случае отсчет символа, с которого начинается обрезание, будет идти с конца строки.  
	* Последний символ имеет номер -1. Второй параметр не является обязательным, если он не указан, то вырезаны будут все символы до конца строки.  
* `строка.substring(откуда начать отрезать, [докуда отрезать]); :String` - возвращает подстроку из строки.  
	* Первый параметр задает номер символа, с которого метод начинает отрезать (нумерация идет с нуля), а второй параметр - номер символа, на котором следует закончить вырезание (символ с этим номером не включается в вырезанную часть).  
	* Второй параметр не является обязательным, если он не указан, то вырезаны будут все символы до конца строки.
* `строка.slice(откуда отрезать, [докуда отрезать]); :String` - возвращает подстроку из строки.  
	* Первым параметром указывается номер символа строки, с которого начинается вырезание, а вторым параметром - номер символа, на котором закончится вырезание (при этом символ с этим номером не включится в вырезанную часть).  
	* Второй параметр не является обязательным. Если его не указать - подстрока возьмется с указанного в первом параметре символа до конца строки. Он также может принимать отрицательные значения. В этом случае отсчет символа, на котором закончится обрезание, начинается с конца строки. Последний символ имеет номер -1.
* `строка.includes(что ищем, [откуда начинать поиск]); :bool` - выполняет поиск заданной строки в текущей с учетом регистра.  
	* Первым параметром метод принимает строку, которую нужно найти.  
	* Вторым необязательным - позицию, с которой нужно начинать поиск.
* `строка.startsWith(что ищем, [начало проверки]); :bool` - проверяет начинается ли строка с указанной в первом параметре подстроки. Если начинается, то возвращает true, а если не начинается, то false.  
Вторым необязательным параметром метод принимает позицию, с которой начинать проверку (по умолчанию с начала строки).  
* `строка.endsWith(что ищем, [длина строки]); :bool` - проверяет, заканчивается ли строка на указанную в первом параметре подстроку. Если заканчивается, то возвращает true, а если не заканчивается,то false.  
Вторым необязательным параметром можно принудительно указать длину строки. 
В этом случае проверка будет не настоящего конца строки, а указанного.  
* `строка.indexOf(что ищем, [откуда начинать поиск]); :Integer` - осуществляет поиск подстроки в строке.  
В первом параметре указываем искомую подстроку в нужном нам регистре (большие буквы или маленькие).Метод вернет позицию первого совпадения, а если оно не найдено, то вернет -1.  
Вторым необязательным параметром можно передать номер символа, откуда следует начинать поиск.
* `строка.lastIndexOf(что ищем, [откуда начинать поиск]); :Integer` - осуществляет поиск последнего вхождения подстроки в строке. При этом необходимо обращать внимание на указанный в первом параметре регистр символов. Поиск ведется с конца строки. Метод вернет позицию первого совпадения с конца, а если оно не найдено, то вернет -1.  
Вторым необязательным параметром можно передать номер символа, откуда следует начинать поиск.  
* `строка.replace(что заменяем, на что заменяем); :String` - осуществляет поиск и замену частей строки.  
Первым параметром принимается подстрока, которую заменяем, а вторым - подстрока, на которую заменяем.  
* `символ.codePointAt(0); :Integer` - получить код по его символу  
* `String.fromCodePoint(код); :String` - создаёт символ по его коду  
* `str.localeCompare(str2): Integer(-1,+1,0)` - возвращает число, которое показывает, какая строка больше в соответствии с правилами языка:
	1. Отрицательное число, если str меньше str2.
	1. Положительное число, если str больше str2.  
	1. 0, если строки равны.  

	У этого метода есть два дополнительных аргумента, которые указаны в документации. Первый позволяет указать язык (по умолчанию берётся из окружения) — от него зависит порядок букв. Второй — определить дополнительные правила, такие как чувствительность к регистру, а также следует ли учитывать различия между "a" и "á".

## Функции для объектов
---
* `Object.keys(объект); :Array` - возвращает массив из свойств объекта в том же порядке, как и при перечислении через цикл.

* `Object.values(объект, из которого выводим значения); :Array` - возвращает массив из значений объекта в том же порядке, как и перечислении через цикл.

* `Object.entries(obj); :Array` – возвращает массив пар [ключ, значение].
```javascript
let user = {
  name: "John",
  age: 30
};

Object.keys(user) = ["name", "age"]
Object.values(user) = ["John", 30]
Object.entries(user) = [ ["name","John"], ["age",30] ]
```

> Object.keys/values/entries игнорируют символьные свойства

* `Object.fromEntries(array); :Object` - преобразовывает массив в объект.

* `Object.getOwnPropertySymbols(obj); :Array` - возвращающий массив только символьных ключей.

* `Reflect.ownKeys(obj)` - метод, который возвращает все ключи и символы и методы.
* `Array.from(obj[, mapFn, thisArg]);` - преобразование итерируеммого объекта или псевдомассива в полноценный массив.  
	* первый аргумент, это преобразуеммый объект.
	* необязательный второй аргумент может быть функцией, которая будет применена к каждому элементу перед добавлением в массив, а `thisArg` позволяет установить `this` для этой функции.

	```javascript
	// range взят из примера выше

	// возводим каждое число в квадрат
	let arr = Array.from(range, num => num * num);

	alert(arr); // 1,4,9,16,25
	```

## Функции для массива
---
* (-) `array.delete(ключ); :void` - удаление элементов из объектов для массивов лучше не использовать, т.к. не изменяет длину массива.

* `array.toString(); :String` - для массива возвращает список элементов, разделённых запятыми.
	```javascript
	let arr = [1, 2, 3];

	alert( arr ); // 1,2,3
	alert( String(arr) === '1,2,3' ); // true
	```

* `array.splice(откуда удаляем, сколько удаляем, [вставить], [вставить]...); :void+Array` - добавляет, удаляет и заменяет элементы. Можно только удалять элементы, только добавлять или делать и то и другое одновременно.  
<u>Изменяет сам массив и возвращает при этом массив удаленных элементов.(два массива)</u>
	1. Первым параметром метод принимает номер элемента массива, который нужно удалить.  
	1. Вторым параметром - сколько элементов массива следует удалить, если его поставить в 0 - то элементы удалены не будут (только добавлены новые).  
	1. Дальше через запятую идут элементы, которые нужно добавить в массив (являются необязательными параметрами). Эти элементы добавятся вместо удаленных элементов массива.

Если удаления не было (когда второй параметр 0) - элементы вставятся в массив начиная с той позиции, которая указана первым параметром метода.  
Первый параметр может иметь отрицательное значение. В этом случае отсчет позиции начнется не с начала массива, а с конца.  
Последний элемент при этом будет иметь номер -1.    
Пример удаления:
```javascript
let arr = ["Я", "изучаю", "JavaScript"];
arr.splice(1, 1); // начиная с индекса 1, удалить 1 элемент
alert(arr); // осталось ["Я", "JavaScript"]
```
Пример удаления с заменой:
```javascript
let arr = ["Я", "изучаю", "JavaScript", "прямо", "сейчас"];
// удалить 3 первых элемента и заменить их другими
arr.splice(0, 3, "Давай", "танцевать");
alert(arr) // теперь ["Давай", "танцевать", "прямо", "сейчас"]
```
> В этом и в других методах массива допускается использование отрицательных индексов. Они определяют позицию с конца массива.

* `array.slice(откуда отрезать, [докуда отрезать]); :Array` - вырезает и возвращает указанную часть массива.  
<u>Массив при этом не изменяется</u>.  
	1. первым параметром указывается номер элемента массива, с которого начинается вырезание
	1. вторым параметром - номер элемента, на котором закончится вырезание (при этом элемент с этим номером не включится в вырезанную часть).  
	Второй параметр не является обязательным. Если его не указать - подмассив возьмется с указанного в первом параметре элемента до конца массива. Он также может принимать отрицательные значения. В этом случае отсчет элемента, на котором закончится обрезание, начинается с конца массива. Последний элемент при этом будет иметь номер -1.

* `array.concat(arg1, arg2...) :void` - создаёт новый массив, в который копирует данные из других массивов и дополнительные значения.  
Он принимает любое количество аргументов, которые могут быть как массивами, так и простыми значениями.  
В результате – новый массив, включающий в себя элементы из arr, затем arg1, arg2 и так далее.  
Если аргумент argN – массив, то копируются все его элементы. Иначе копируется сам аргумент.  
```javascript
// создать массив из: arr и [3,4] и [5,6]
alert(arr.concat([3, 4], [5, 6])); // 1,2,3,4,5,6
```

* `string.split([разделитель], [максимальное количество элементов]); :Array` - разбивает строки в массив.  
	1. в первом параметре разделитель, если он не задан - вернется вся строка. Если он задан как пустые кавычки, то каждый символ строки попадет в отдельный элемент массива.  
	1. вторым необязательным параметром можно указать максимальное количество элементов в получившемся массиве.

* `array.join([разделитель]); :String` - объединяет элементы массива в строку с указанным разделителем (он будет вставлен между элементами массива).  
Разделитель задается параметром метода и не является обязательным. Если он не задан - по умолчанию в качестве разделителя возьмется запятая. Если вы хотите слить элементы массива без разделителя - укажите его как пустую строку ''.

* `array.push(элемент, элемент, элемент...); :void` - добавляет неограниченное количество элементов в конец массива. При этом исходный массив изменяется, а результатом возвращается новая длина массива.

* `array.pop(); :void+String` - удаляет последний элемент из массива и возваращет удаленный элемент. При этом исходный массив изменяется.

* `array.shift(); :void+String` - удаляет первый элемент из массива. При этом исходный массив изменяется, а результатом метода возвращается удаленный элемент.

* `array.unshift(элемент, элемент, элемент...); :vlid+Integer` - добавляет неограниченное количество новых элементов в начало массива. При этом исходный массив изменяется, а результатом возвращается новая длина массива.  

* `array.map(function(элемент, индекс, массив) { /* код */ return измененный элемент; }); :void+Array` - позволяет применить заданную функцию для каждого элемента массива. При этом метод не <u>изменяет исходный массив</u>, а возвращает измененный.  
В функцию можно передавать 3 параметра. Если эти параметры есть (они не обязательны), то в первый автоматически попадет элемент массива, во второй попадет его номер в массиве (индекс), а в третий - сам массив.

* `array.forEach(function(элемент, индекс, массив) { /* код */ }); :void` - позволяет последовательно перебрать все элементы массива. Метод в параметре получает функцию, которая выполнится для каждого элемента массива. В эту функцию можно передавать три параметра. Если эти параметры есть (они не обязательны), то в первый автоматически попадет элемент массива, во второй попадет его номер в массиве (индекс), а в третий - сам массив.

* `array.filter(function(элемент, индекс, массив) { /* код */ return true или false}); :Array` - позволяется отфильтровать элементы массива, оставив только подходящие под определенное условие элементы.  
Метод в параметре получает функцию, которая выполнится для каждого элемента массива. Своим результатом метод возвращает новый массив, в который войдут только те элементы, для которых переданная функции вернет true. В функцию можно передавать три параметра. Если эти параметры есть (они не обязательны), то в первый автоматически попадет элемент массива, во второй попадет его номер в массиве (индекс), а в третий - сам массив.

* `array.every(function(элемент, индекс, массив) { return true или false; }); :Boolean` - проверяет элементы массива в соответствии с переданной функцией. Метод возвращает true, если для всех элементов массива переданная функция вернет true, в противном случае метод возвращает false. В функцию можно передавать три параметра. Если эти параметры есть (они не обязательны), то в первый автоматически попадет элемент массива, во второй попадет его номер в массиве (индекс), а в третий - сам массив.

* `array.some(function(элемент, индекс, массив) { return true или false; }); :Boolean` - проверяет элементы массива в соответствии с переданной функцией. Эта функция передается параметром метода и выполняется для каждого элемента массива. Метод возвращает true, если хотя бы для одного элемента массива переданная функция вернет true, в противном случае метод возвращает false. В функцию можно передавать три параметра. Если эти параметры есть (они не обязательны), то в первый автоматически попадет элемент массива, во второй попадет его номер в массиве (индекс), а в третий - сам массив.

* `array.find(функция); :String|undefined` - помогает найти первый элемент в массиве согласно переданному в параметре коллбэку. Если элемента нет, то возвращается undefined.

* `array.findLast(функция); :String|undefined` - ищет последний элемент массива согласно переданному в параметре коллбэку. Если элемента нет, то в результат возвращается undefined.

* `array.findIndex(функция); :Integer|-1` - позволяет найти индекс первого элемента согласно согласно переданному в `параметре` коллбэку. Если элемент не найден, то возвращается -1.

* `array.findLastIndex(функция); :Integer|undefined` - помогает найти индекс последнего элемента массива, соответствующий условию согласно переданному в параметре коллбэку. Если элемента нет, то возвращается undefined.  

* `array.reduce(function(промежуточный результат, элемент, индекс, массив) { return новый промежуточный результат; }, начальное значение); :Mixed` - сворачивает массив к одному значению (редуцирует). К примеру, с помощью этого метода можно легко найти сумму элементов массива (то есть массив сведется к одному значению - к сумме элементов).  
	1. Первым параметром метод reduce получает функцию, которая последовательно выполнится для каждого элемента массива, начиная с первого. В эту функцию можно передавать 4 параметра. Если эти параметры есть (они не обязательны), то в первый автоматически попадет промежуточный результат, во второй попадет элемент массива, в третий - его номер в массиве (индекс), а в четвертый - сам массив. Промежуточный результат - это переменная, в которую будет накапливаться то значение, которое вернет метод reduce, когда переберет все элементы массива.  
	К примеру, туда последовательно можно накапливать сумму элементов массива: сначала положить первый элемент, при следующем проходе цикла уже сумму первого элемента и второго, при следующем проходе - сумму первого, второго и третьего. И так, пока массив не закончится. Функция, которую принимает reduce, должна возвращать новое значение промежуточного результата.
	1. Вторым параметром метода reduce указывается начальное значение промежуточного результата. Если его не указать, то оно будет равно первому элементу массива, а обработка элементов начнется со второго элемента.

* `array.reduceRight(function(промежуточный результат, элемент, индекс, массив) { return новый промежуточный результат; }, начальное значение); :Mixed` - работает точно так же как и reduce - смотрите его для полного понимания.  
Единственное отличие: reduce перебирает элементы слева направо, а reduceRight - справа налево.

* `array.sort([func]): void` - сортирует массив «на месте», а потом возвращает его.  
Он также возвращает отсортированный массив, но обычно возвращаемое значение игнорируется, так как изменяется сам `arr`.  
Чтобы использовать наш собственный порядок сортировки, нам нужно предоставить функцию в качестве аргумента `array.sort(func)`.  
Используйте `localeCompare` для строк  
Помните алгоритм сравнения строк? По умолчанию, он сравнивает буквы по их кодам.  
Для многих алфавитов лучше использовать метод `str.localeCompare`, для правильной сортировки букв, таких как Ö.  
	```javascript
	let countries = ['Österreich', 'Andorra', 'Vietnam'];
	alert( countries.sort( (a, b) => a > b ? 1 : -1) ); // Andorra, Vietnam, Österreich (неправильно)
	alert( countries.sort( (a, b) => a.localeCompare(b) ) ); // Andorra,Österreich,Vietnam (правильно!)
	```

* `array.reverse(); :void` - метод меняет порядок элементов в `array` на обратный.  
Он также возвращает массив `array` с изменённым порядком элементов.

* `array.includes(value) :Boolean` – возвращает `true`, если в массиве имеется элемент `value`, в противном случае `false`.

# Работа с объектом Date
Объект с датой создается экземпляром класса `new Date();` 
```javascript 
let date = new Date(); //создание объекта и присваивание его переменной, вернет Thu Jan 26 2017 11:00:00 GMT текущий часовой пояс
```
После проделанной операции переменная `date` будет представлять собой объект, хранящий в свойствах текущий момент времени (секунду, минуту, час и так далее).  
Используя этот объект с помощью специальных методов мы можем получить нужные нам характеристики времени, например, текущий час, текущий день или текущий месяц.  
* `Объект.getFullYear()` - год (YYYY)
* `Объект.getMonth()` -  месяц. Учтите, что месяц, который возвращает метод getMonth, начинается с нуля - январь нулевой, февраль первый и так далее. 
* `Объект.getDate()` - получить день месяца, от 1 до 31, что несколько противоречит названию метода.
* `Объект.getDay()` - день. Этот метод возвращает числа от 0 до 6-ти, причем неделя начинается с воскресенья и этот день имеет номер 0. Понедельник - это день номер 1, вторник - номер 2 и так далее.
* `Объект.getHours()` - часы
* `Объект.getMinutes()` - минуты
* `Объект.getSeconds()` - секунды
* `Объект.getMilliseconds()` - милисекунды
* `Объект.getTimezoneOffset()` - возвращает разницу в минутах между UTC и местным часовым поясом
* `Объект.getTime()` - возвращает timestamp, учтите, что, в отличие от некоторых других систем, в JavaScript таймстамп в миллисекундах, а не в секундах.
* `Date.now()` - получение текущего времени без создания объекта Date

```javascript
let date = new Date();
console.log(date.getSeconds());  //секунды
```

Существуют и их UTC-варианты, возвращающие день, месяц, год для временной зоны UTC+0:` 
* `getUTCFullYear()`
* `getUTCMonth()`
* `getUTCDay()`

Для их использования требуется после "get" подставить "UTC".

## Установка своего времени в объекте Date
---
Можно, передать параметры в формате  
`new Date(int 'год, месяц, день, часы, минуты, секунды, миллисекунды' или int timestamp)`  
и в этом случае в переменную date запишется не текущий момент времени, а тот, который мы указали в параметрах. Параметры можно опускать с конца. При этом отсутствующие параметры для миллисекунд, секунд и часов считаются равными нулю, а для дней - единице. Год и месяц опускать нельзя.

### Установка отельный компонентов даты
---
* `setFullYear(year, [month], [date])`
* `setMonth(month, [date])`
* `setDate(date)`
* `setHours(hour, [min], [sec], [ms])`
* `setMinutes(min, [sec], [ms])`
* `setSeconds(sec, [ms])`
* `setMilliseconds(ms)`
* `setTime(milliseconds)` - (устанавливает дату в виде целого количества миллисекунд, прошедших с 01.01.1970 UTC)
> У всех этих методов, кроме setTime(), есть UTC-вариант, например: setUTCHours().

<u>Автоисправление</u> – это очень полезная особенность объектов `Date`. Можно устанавливать компоненты даты вне обычного диапазона значений, а объект сам себя исправит.

```javascript
let date = new Date(2013, 0, 32); // 32 Jan 2013 ?!?
alert(date); // ...1st Feb 2013!
```

## Получение времени в формате timestamp
---
Cпециальный формат timestamp, который показывает количество миллисекунд, прошедшее с 1-го января 1970 года по текущий (или заданный) момент времени. Датам до 1 января 1970 будут соответствовать отрицательные таймстампы.
* `Объект.getTime()` - с помощью которого можно получить время в формате timestamp (милисекунды). Чтобы перевести в секунды, нужно милисекунды поделить на 1000, чтобы секунды перевести в минуты, нужно секунды поделить на 60 и так далее.
```javascript
let date = new Date();
console.log(date.getTime()); //преобразование из объектного вида в timestamp
```

## Разность между датами в формате timestamp
---
```javascript
let now  = new Date();
let date = new Date(2015, 11, 4, 23, 59, 59);

let diff = now.getTime() - date.getTime();
console.log(diff);
//или
let diff = now - date; // вычитаем два объекта с датами друг от друга
console.log(diff);     // увидим разницу в миллисекундах
```

## Разбор строки с датой
---
`Date.parse(str)` - метод считывает дату из строки.
Формат строки должен быть следующим: YYYY-MM-DDTHH:mm:ss.sssZ, где:
* YYYY-MM-DD – это дата: год-месяц-день.
* Символ "T" используется в качестве разделителя.
* HH:mm:ss.sss – время: часы, минуты, секунды и миллисекунды.
* Необязательная часть 'Z' обозначает часовой пояс в формате +-hh:mm. Если указать просто букву Z, то получим UTC+0.

Возможны и более короткие варианты, например, YYYY-MM-DD или YYYY-MM, или даже YYYY.

Вызов `Date.parse(str)` обрабатывает строку в заданном формате и возвращает таймстамп (количество миллисекунд с 1 января 1970 года UTC+0). Если формат неправильный, возвращается `NaN`.
```javascript
let ms = Date.parse('2012-01-26T13:51:50.417-07:00');
alert(ms); // 1327611110417 (таймстамп)
```

## Строковое сравнение дат (строковых дат)
---
Важно также, чтобы даты были в одном формате. В нашем случае разделителями частей дат являются дефисы. Это, конечно же, не обязательно. Например, можно поставить точки:
```javascript
let date1 = '2020-12-01';
let date2 = '2019-12-01';

console.log(date1 > date2); // выведет true
```

Можно сравнивать не только строки, но и объекты с датами:
```javascript
let date1 = new Date(2020, 1, 1);
let date2 = new Date(2019, 1, 1);

console.log(date1 > date2); // выведет true
```

# Формат JSON
JavaScript предоставляет методы:
* `JSON.stringify` для преобразования объектов в JSON (полученная строка json называется JSON-форматированным или сериализованным объектом)
* `JSON.parse` для преобразования JSON обратно в объект

## `JSON.stringify(value, [replacer, space])`
Вложенные объекты поддерживаются и конвертируются автоматически.

1. <u>value</u> - значения для кодирования
1. <u>replacer</u> - 
	1. массив свойств для кодирования (только данных свойств)
	1. функция соответствия function(key, value) (функция будет вызываться для каждой пары (key, value), и она должна возвращать заменённое значение, которое будет использоваться вместо исходного. Или undefined, чтобы пропустить значение)
1. <u>space</u> - дополнительное пространство (отступы), используемое для форматирования (параметр space применяется исключительно для логирования и красивого вывода)  
`alert(JSON.stringify(user, null, 4));`

JSON поддерживает следующие типы данных:
* Объекты { ... }
* Массивы [ ... ]
* строки
* числа
* логические значения true/false
* null

JSON не поддерживает следующие типы данных:
* Свойства-функции (методы)
* Символьные ключи и значения
* Свойства, содержащие undefined

> Важное ограничение: не должно быть циклических ссылок.

## Пользовательский «toJSON»
Как и `toString` для преобразования строк, объект может предоставлять метод `toJSON` для преобразования в JSON. `JSON.stringify` автоматически вызывает его, если он есть.
```javascript
let room = {
  number: 23,
  toJSON() {
    return this.number;
  }
};

let meetup = {
  title: "Conference",
  room
};

alert( JSON.stringify(room) ); // 23

alert( JSON.stringify(meetup) );
/*
  {
    "title":"Conference",
    "room": 23
  }
*/
```

## JSON.parse
`JSON.parse(str, [reviver]);` - десериализовать в объект строку
* str - JSON для преобразования в объект
* reviver - Необязательная функция, которая будет вызываться для каждой пары (ключ, значение) и может преобразовывать значение 
	```javascript
	let str = '{"title":"Conference","date":"2017-11-30T12:00:00.000Z"}';

	let meetup = JSON.parse(str, function(key, value) {
  		if (key == 'date') return new Date(value);
  		return value;
	});

	alert( meetup.date.getDate() ); // 30 - теперь работает!
	```

> JSON может быть настолько сложным, насколько это необходимо, объекты и массивы могут включать другие объекты и массивы. Но они должны быть в том же JSON-формате.
================================================================

# BOM в JavaScript
<u>Browser Object Model</u>, BOM) – это Объектная модель браузера, дополнительные объекты, предоставляемые браузером (окружением), чтобы работать со всем, кроме документа.
> Функции `alert/confirm/prompt` тоже являются частью BOM: они не относятся непосредственно к странице, но представляют собой методы объекта окна браузера для коммуникации с пользователем.

# DOM в JavaScript
<u>Document Object Model</u>, сокращённо DOM – объектная модель документа, которая представляет все содержимое страницы в виде объектов, которые можно менять.

## DOM-дерево
---
* Браузер парсит HTML в DOM объекты.
* Каждый HTML-тег является объектом.
* Вложенные теги являются «детьми» родительского элемента.
* Текст, который находится внутри тега, также является объектом.

> Автоисправленя: eсли браузер сталкивается с некорректно написанным HTML-кодом, он автоматически корректирует его при построении DOM. При генерации DOM браузер самостоятельно обрабатывает ошибки в документе, закрывает теги и так далее.

> Важный «особый случай» – работа с таблицами. По стандарту DOM у них должен быть `<tbody>`, но в HTML их можно неписать (официально). В этом случае браузер добавляет `<tbody>` в DOM самостоятельно.

Существует 12 типов узлов. Но на практике мы в основном работаем с 4 из них:
1. `document` – «входная точка» в DOM.
1. `узлы-элементы` – HTML-теги, основные строительные блоки.
1. `текстовые узлы` – содержат текст.
1. `комментарии` – иногда в них можно включить информацию, которая не будет показана, но доступна в DOM для чтения JS.

<u>DOM-узлы</u> – это обычные JavaScript объекты. Для наследования они используют классы, основанные на прототипах.

## Навигация по DOM-элементам (и текстовым узлам)
---
Все операции с DOM начинаются с объекта `document`. Это главная «точка входа» в DOM. Из него мы можем получить доступ к любому узлу.  

1. `document.documentElement` и `document.body`  
	`<html>` = document.documentElement  
	`<body>` = document.body  
	`<head>` = document.head
	> Есть одна тонкость: document.body может быть равен null. В частности, если скрипт находится в `<head>`, document.body в нём недоступен, потому что браузер его ещё не прочитал.

1. Дочерние узлы  
	`childNodes` - все потомки узлы (которые лежат внутри данного, включая детей, не включая их детей), содержит список всех детей, включая текстовые узлы.
	`firstChild` - первый дочерний узел
	`lastChild` - последний дочерний узел

	<u>Уточнение:</u>
	1. Дочерние узлы (или дети) – элементы, которые являются непосредственными детьми узла. Другими словами, элементы, которые лежат непосредственно внутри данного. Например, `<head>` и `<body>` являются детьми элемента `<html>`.
	1. Потомки – все элементы, которые лежат внутри данного, включая детей, их детей и т.д.
	
	> Важная деталь скрипт видит детей только до того места где запущен.
	* Метод `elem.hasChildNodes()` - проверка наличия дочерних узлов, вернёт `true` или `false`

2. Соседи – это узлы, у которых один и тот же родитель  
	`nextSibling, previosSibling`
	1. `nextSibling` - следующий сосед
	1. `previousSibling` - предыдущий сосед

3. Родитель - `parentNode`

---

1. DOM-коллекции - это не массив, а коллекция – особый перебираемый объект-псевдомассив.  
И есть два важных следствия из этого:
	1. Для перебора коллекции мы можем использовать `for..of`
	2. Методы массивов не будут работать, потому что коллекция (перебираемый объект) – это не массив
		> Если нам хочется использовать именно методы массива, то мы можем создать настоящий массив из коллекции, используя обёртку `Array.from`.   
		`alert( Array.from(document.body.childNodes).filter ); // сделали массив`
1. DOM-коллекции – только для чтения, Мы не можем заменить один дочерний узел на другой, просто написав `childNodes[i] = ...`.
1. DOM-коллекции живые - почти все DOM-коллекции, за небольшим исключением, живые. Другими словами, они отражают текущее состояние DOM.  
	Если мы сохраним ссылку на `elem.childNodes` и добавим/удалим узлы в DOM, то они появятся в сохранённой коллекции автоматически.
1. Не используйте цикл `for..in` для перебора коллекций.

## Навигация только по элементам (без текстовых узлов)
---
Это узлы элементов, но без текстовых узлов и узлов комментариев
* `children` – коллекция детей, которые являются элементами.
* `firstElementChild, lastElementChild` – первый и последний дочерний элемент.
* `previousElementSibling, nextElementSibling` – соседи-элементы.
* `parentElement` – родитель-элемент.
	> Зачем нужен parentElement? Разве может родитель быть не элементом? Причина в том, что родителем корневого узла document.documentElement (`<html>`) является document. Но document – это не узел-элемент, так что parentNode вернёт его, а parentElement нет.

## Таблицы в DOM
---
Элемент `<table>`, в дополнение к свойствам, о которых речь шла выше, поддерживает следующие:  
* `table.rows` – коллекция строк `<tr>` таблицы
* `table.caption/tHead/tFoot` – ссылки на элементы таблицы `<caption>, <thead>, <tfoot>`
* `table.tBodies` – коллекция элементов таблицы `<tbody>` (по спецификации их может быть больше одного)  

`<thead>, <tfoot>, <tbody>` предоставляют свойство rows:
* `tr.cells` – коллекция `<td>` и `<th>` ячеек, находящихся внутри строки `<tr>`
* `tr.sectionRowIndex` – номер строки `<tr>` в текущей секции `<thead>/<tbody>/<tfoot>`
* `tr.rowIndex` – номер строки `<tr>` в таблице (включая все строки таблицы)

`<tr>`:
* `td.cellIndex` – номер ячейки в строке `<tr>`

## Поиск под ID (document.getElementById (или просто id))
---
`document.getElementById(id элемента)` - найти элемент под ID
Если у элемента есть атрибут `id`, то мы можем получить его вызовом `document.getElementById(id)`, где бы он ни находился или просто через `ID` (вызов просто по id, только если мы не объявили в JavaScript переменную с таким же именем, иначе она будет иметь приоритет).
* Значение id должно быть уникальным
* Только `document.getElementById`, а не `anyElem.getElementById`
* Если в id есть дефис, мы можем обратиться к нему через квадратные скобки: `window['elem-content']`

## Поиск по CSS-селектору (document.querySelectorAll) - получение нескольких DOM элементов
---
<u>Селекторы</u> — инструкции, которые позволяют выбирать определённые HTML-элементы и применять к ним стили.

`document.querySelectorAll(селектор)` - получающает все теги, подпадающие под CSS селектор, в виде массива элементов.
```html
<p class="www">text1</p>
<p class="www">text2</p>
<p class="www">text3</p>
```
```javascript
let elems = document.querySelectorAll('.www');
for (let elem of elems) {
    console.log(elem.textContent);
}
```

Псевдоклассы тоже работают - псевдоклассы в CSS-селекторе, в частности `:hover` и `:active`, также поддерживаются.  
Например, `document.querySelectorAll(':hover')` вернёт коллекцию (в порядке вложенности: от внешнего к внутреннему) из текущих элементов под курсором мыши.

## Поиск по CSS-селектору (document.querySelector) - получение первого(и только одного) DOM элемента
---
`document.querySelector(селектор)` - этот метод параметром принимает CSS селектор и возвращает ссылку на найденный по этому селектору элемент (всегда возвращает первый, попавший указанный селектор).

```html
<div class='mod'>
	<input id="button" type="submit">
</div>
```
```javascript
let button = document.querySelector('div > #button');
console.log(button);
```
или
```html
<div id="parent">
    <input id="button1" type="submit">
    <input id="button2" type="submit">
</div>
```
```javascript
let elem = document.querySelector('#parent input');
console.log(elem); //вывдет button1
```

## Метод element.matches
---
`элемент.matches('селектор'); :bool` - позволяет проверить, удовлетворяет ли элемент указанному CSS селектору.

```html
<p id="elem" class="www"></p>
```
```javascript
let elem = document.querySelector('#elem');
console.log(elem.matches('p.www')); ///true
```

## Метод element.closest
---
`элемент.closest('селектор'); :Element|null` - ищет ближайший родительский элемент, подходящий под указанный CSS селектор, при этом сам элемент тоже включается в поиск.

```html
<div class="www" id="parent2">
	<div class="ggg" id="parent1">
		<p class="zzz" id="child"></p>
	</div>
</div> 
```
```javascript
let elem = document.querySelector('#child');
let parent = elem.closest('.www');
console.log(parent.id); //parent2
```

## Метод element.contains
---
`elemA.contains(elemB); :Boolean` - вернёт true, если elemB находится внутри elemA (elemB потомок elemA) или когда `elemA == elemB`.

## Метод getElementsBy* - методы поиска элементов по тегу, классу и так далее.
---
Существуют также другие методы поиска элементов по тегу, классу и так далее.  
На данный момент, они скорее исторические, так как `querySelector` более чем эффективен.  
Здесь мы рассмотрим их для полноты картины, также вы можете встретить их в старом коде.  
`elem.getElementsByTagName(tag)` ищет элементы с данным тегом и возвращает их коллекцию. Передав "*" вместо тега, можно получить всех потомков.  
`elem.getElementsByClassName(className)` возвращает элементы, которые имеют данный CSS-класс.  
`document.getElementsByName(name)` возвращает элементы с заданным атрибутом `name`. Очень редко используется.

### Доп.:
---
|Метод|Ищет по...|Ищет внутри элемента?|Возвращает живую коллекцию?|
|-|-|-|-
|querySelector|CSS-selector|✔|-|
|querySelectorAll|CSS-selector|✔|-|
|getElementById|id|-|-|
|getElementsByName|name|-|✔|
|getElementsByTagName|tag or '*'|✔|✔|
|getElementsByClassName|class|✔|✔|

* Все методы `getElementsBy*` возвращают живую коллекцию. Такие коллекции всегда отражают текущее состояние документа и автоматически обновляются при его изменении.
```html
<div>First div</div>
```
```javascript
let divs = document.getElementsByTagName('div');
alert(divs.length); //1
```

```html
<div>Second div</div>
```
```javascript
alert(divs.length); //2
```

* `querySelectorAll` возвращает статическую коллекцию. Это похоже на фиксированный массив элементов.

# Классы DOM-узлов
* Каждый DOM-узел принадлежит соответствующему встроенному классу.
* Корнем иерархии является `EventTarget`, от него наследует `Node` и остальные DOM-узлы.

Существуют следующие классы:
* `EventTarget` – это корневой «абстрактный» класс для всего. Объекты этого класса никогда не создаются. Он служит основой, благодаря которой все DOM-узлы поддерживают так называемые «события», о которых мы поговорим позже.
* `Node` – также является «абстрактным» классом, и служит основой для DOM-узлов. Он обеспечивает базовую функциональность: `parentNode`, `nextSibling`, `childNodes` и т.д. (это геттеры). Объекты класса Node никогда не создаются. Но есть определённые классы узлов, которые наследуются от него (и следовательно наследуют функционал Node).
* `Document` - по историческим причинам часто наследуется HTMLDocument (хотя последняя спецификация этого не навязывает) – это документ в целом. Глобальный объект document принадлежит именно к этому классу. Он служит точкой входа в DOM.
* `CharacterData` – «абстрактный» класс. Вот, кем он наследуется:
	* `Text` – класс, соответствующий тексту внутри элементов. Например, Hello в `<p>Hello</p>`.
	* `Comment` – класс для комментариев. Они не отображаются, но каждый комментарий становится членом DOM.
* `Element` – это базовый класс для DOM-элементов. Он обеспечивает навигацию на уровне элементов: `nextElementSibling`, `children`. А также и методы поиска элементов: `getElementsByTagName`, `querySelector`.
	* `HTMLInputElement` – класс для тега `<input>`,
	* `HTMLBodyElement` – класс для тега `<body>`,
	* `HTMLAnchorElement` – класс для тега `<a>`,
	* …и т.д.


# Свойства узлов
## Имя узла `constructor.name`
---
`elem.constructor.name` - узнать имя узла

## Проверить наследование от класса DOM `instanceof`
---
`element instanceof classDom`
```javascript
alert( document.body instanceof HTMLBodyElement ); // true
```

## Свойство `nodeType` - вывести номер типа узла
---
`elem.nodeType` - предоставляет ещё один, «старомодный» способ узнать «тип» DOM-узла.
* elem.nodeType == 1 для узлов-элементов,
* elem.nodeType == 3 для текстовых узлов,
* elem.nodeType == 9 для объектов документа,

### Тег: `nodeName` и `tagName`
Получив DOM-узел, мы можем узнать имя его тега из свойств `nodeName` и `tagName`:
```javascript
alert(document.body.nodeName); //BODY
alert(document.body.tagName); //BODY
```
* Свойство `tagName` есть только у элементов Element.
* Свойство `nodeName` определено для любых узлов Node:
	* для элементов оно равно `tagName`.
	* для остальных типов узлов (текст, комментарий и т.д.) оно содержит строку с типом узла.

> Имена тегов (кроме XHTML) всегда пишутся в верхнем регистре

```html
<body><!-- комментарий -->
```
```javascript
// для комментария
alert( document.body.firstChild.tagName ); // undefined (не элемент)
alert( document.body.firstChild.nodeName ); // #comment

// for document
alert( document.tagName ); // undefined (не элемент)
alert( document.nodeName ); // #document
```
```html
</body>
```

## Свойство `innerHTML` - HTML содержимое элемента c тегами без элемента
---
`elem.innerHTML;` - свойство позволяющее прочитывать и заменить HTML код этих элементов.
```html
<p id="elem"><b>text</b></p>
```
```javascript
let elem = document.querySelector('#elem');
console.log(elem.innerHTML); // выведет <b>text</b>
elem.innerHTML = '<i>!!!</i>'; //задать новое свойство
```
> Если innerHTML вставляет в документ тег `<script>` – он становится частью HTML, но не запускается.

> Будьте внимательны: «innerHTML+=» осуществляет перезапись (т.е. содержимое «обнуляется» и переписывается заново, все изображения и другие ресурсы будут перезагружены.)
> Есть и другие побочные эффекты. Например, если существующий текст выделен мышкой, то при переписывании innerHTML большинство браузеров снимут выделение. А если это поле ввода `<input>` с текстом, введённым пользователем, то текст будет удалён. И т.д.

## Свойство `outerHTML` - HTML содержимое элемента c тегами + сам элемент
---
`elem.outerHTML;` - cвойство outerHTML содержит HTML элемента целиком. Это как innerHTML плюс сам элемент.

> Будьте осторожны: в отличие от innerHTML, запись в outerHTML не изменяет элемент. Вместо этого элемент заменяется целиком во внешнем контексте.
> Здесь легко сделать ошибку: заменить div.outerHTML, а потом продолжить работать с div, как будто там новое содержимое. Но это не так. Подобное верно для innerHTML, но не для outerHTML.

```html
<div>Привет, мир!</div>
```
```javascript
let div = document.querySelector('div');
// заменяем div.outerHTML на <p>...</p>
div.outerHTML = '<p>Новый элемент</p>'; // (*)
// Содержимое div осталось тем же!
alert(div.outerHTML); // <div>Привет, мир!</div> (**)
```

## Свойство `nodeValue` или `data` содержимое текстового узла
---
Свойство `innerHTML` есть только у узлов-элементов.  
У других типов узлов, в частности, у текстовых, есть свои аналоги: свойства `nodeValue` и `data`. Эти свойства очень похожи при использовании, есть лишь небольшие различия в спецификации. Мы будем использовать `data`, потому что оно короче.

```html
<body>
Привет <!-- Комментарий -->
```
```javascript
let text = document.body.firstChild;
alert(text.data); // Привет

let comment = text.nextSibling;
alert(comment.data); // Комментарий
```

## Свойство `textContent` - просто текст
---
`селектор.textContent;` - свойство позволяющее прочитывать и записать текст этих элементов, как обычный текст

> С `innerHTML` вставка происходит «как HTML», со всеми HTML-тегами.  
> С `textContent` вставка получается «как текст», все символы трактуются буквально.

```html
<div id="news">
  <h1>Срочно в номер!</h1>
  <p>Марсиане атаковали человечество!</p>
</div>
```
```javascript
alert(news.textContent); // Выведет без тегов: Срочно в номер! Марсиане атаковали человечество!
```

## Свойство `hidden` - видимость элемента
---
Атрибут и DOM-свойство `«hidden»` указывает на то, видим ли мы элемент или нет.  
Технически, `hidden` работает так же, как `style="display:none"`. Но его применение проще.

```html
<div>Оба тега DIV внизу невидимы</div>
<div hidden>С атрибутом "hidden"</div>
<div id="elem">С назначенным JavaScript свойством "hidden"</div>
```
```javascript
elem.hidden = true;
```

## Другие свойства DOM-элементов
У DOM-элементов есть дополнительные свойства, в частности, зависящие от класса:  
* `value` – значение для `<input>, <select> и <textarea>` (HTMLInputElement, HTMLSelectElement…).
* `href` – адрес ссылки «href» для `<a href="...">` (HTMLAnchorElement).
* `id` – значение атрибута «id» для всех элементов (HTMLElement).

> Большинство стандартных HTML-атрибутов имеют соответствующее DOM-свойство, и мы можем получить к нему доступ.

```html
<input type="text" id="elem" value="значение">
```
```javascript
alert(elem.type); // "text"
alert(elem.id); // "elem"
alert(elem.value); // значение
```

DOM-свойства и методы ведут себя так же, как и обычные объекты JavaScript:
* Им можно присвоить любое значение.
* Они регистрозависимы (нужно писать elem.nodeType, не elem.NoDeTyPe).
* Всегда можно вывести элемент в консоль, используя `console.dir(elem)`, и прочитать все свойства. Или исследовать «свойства DOM» во вкладке Elements браузерных инструментов разработчика.

## HTML-атрибуты
---
HTML-атрибуты - всегда являются строками.  
Когда у элемента есть `id` или другой стандартный атрибут, создаётся соответствующее свойство. Но этого не происходит, если атрибут нестандартный.  
Все атрибуты доступны с помощью следующих методов (эти методы работают именно с тем, что написано в HTML):
* `elem.hasAttribute(name)` – проверяет наличие атрибута.
* `elem.getAttribute(name)` – получает значение атрибута.
* `elem.setAttribute(name, value)` – устанавливает значение атрибута.
* `elem.removeAttribute(name)` – удаляет атрибут.
* `elem.attributes` - получить все атрибуты элемента можно с помощью свойства `elem.attributes`: коллекция объектов, которая принадлежит ко встроенному классу Attr со свойствами `name` и `value`. Коллекция `attributes` является перебираемой. В ней есть все атрибуты элемента (стандартные и нестандартные) в виде объектов со свойствами name и value.
	```javascript
	for (let attr of elem.attributes) { // (4) весь список
    	alert( `${attr.name} = ${attr.value}` );
    }
	```
### Синхронизация между атрибутами и свойствами
---
Когда стандартный атрибут изменяется, соответствующее свойство автоматически обновляется. Это работает и в обратную сторону (за некоторыми исключениями).  
Но есть и исключения, например, input.value синхронизируется только в одну сторону – атрибут → значение, но не в обратную:
```html
<input>
```
```javascript
let input = document.querySelector('input');

// атрибут => значение
input.setAttribute('value', 'text');
alert(input.value); // text

// свойство => атрибут
input.value = 'newValue';
alert(input.getAttribute('value')); // text (не обновилось!)
```
В примере выше:
* Изменение атрибута value обновило свойство.
* Но изменение свойства не повлияло на атрибут.

Иногда эта «особенность» может пригодиться, потому что действия пользователя могут приводить к изменениям value, и если после этого мы захотим восстановить «оригинальное» значение из HTML, оно будет в атрибуте.

### DOM-свойства типизированы
---
DOM-свойства не всегда являются строками. Например, свойство `input.checked` (для чекбоксов) имеет логический тип:

```html
<input id="input" type="checkbox" checked> checkbox

<div id="div" style="color:red;font-size:120%">Hello</div>
```
```javascript
alert(input.getAttribute('checked')); // значение атрибута: пустая строка
alert(input.checked); // значение свойства: true

// строка
alert(div.getAttribute('style')); // color:red;font-size:120%

// объект
alert(div.style); // [object CSSStyleDeclaration]
alert(div.style.color); // red
```

### Нестандартные (пользовательские) атрибуты, `dataset`
---
Все атрибуты, начинающиеся с префикса `«data-»`, зарезервированы для использования программистами. Они доступны в свойстве `dataset`.  
Атрибуты, состоящие из нескольких слов, к примеру `data-order-state`, становятся свойствами, записанными с помощью верблюжьей нотации: `dataset.orderState`.

```html
<body data-about="Elephants">
```
```javascript
alert(document.body.dataset.about); // Elephants
```

## Создание элемента DOM
---
`document.createElement(tag)` - создаёт новый элемент с заданным тегом
`document.createTextNode(text)` - создаёт новый текстовый узел с заданным текстом

## Вставка созданного элемента DOM на страницу (вставка текста происходит без обработки HTML, а элементов с обработкой)
---
`document.body.append(div)` - вставка элемента в body
```javascript
let div = document.createElement('div');
div.className = "alert";
div.innerHTML = "<strong>Всем привет!</strong> Вы прочитали важное сообщение.";
document.body.append(div);
```

Вот методы для различных вариантов вставки:
* `node.append(...nodes or strings)` – добавляет узлы или строки в конец node,
* `node.prepend(...nodes or strings)` – вставляет узлы или строки в начало node,
* `node.before(...nodes or strings)` - вставляет узлы или строки до node,
* `node.after(...nodes or strings)` - вставляет узлы или строки после node,
* `node.replaceWith(...nodes or strings)` - заменяет node заданными узлами или строками.
```html
<ol id="ol">
  <li>0</li>
  <li>1</li>
  <li>2</li>
</ol>
```
```javascript
ol.before('before'); // вставить строку "before" перед <ol>
ol.after('after'); // вставить строку "after" после <ol>

let liFirst = document.createElement('li');
liFirst.innerHTML = 'prepend';
ol.prepend(liFirst); // вставить liFirst в начало <ol>

let liLast = document.createElement('li');
liLast.innerHTML = 'append';
ol.append(liLast); // вставить liLast в конец <ol>
```
> Эти методы могут вставлять несколько узлов и текстовых фрагментов за один вызов.  
> Весь текст вставляется как текст.

## Вставка созданного элемента DOM на страницу (вставка текста c обработкой html)
---
`elem.insertAdjacentHTML(where, html)` - вставляеются строка html с тегами.  
`elem.insertAdjacentText(where, text)` – такой же синтаксис, но строка text вставляется «как текст», вместо HTML.
`elem.insertAdjacentElement(where, elem)` – такой же синтаксис, но вставляет элемент elem.
> Последние два существуют, в основном, чтобы унифицировать синтаксис. На практике часто используется только insertAdjacentHTML. Потому что для элементов и текста у нас есть методы append/prepend/before/after – их быстрее написать, и они могут вставлять как узлы, так и текст.  

[Первый параметр] – это специальное слово, указывающее, куда по отношению к elem производить вставку. Значение должно быть одним из следующих:
* `"beforebegin"` – вставить html непосредственно перед elem,
* `"afterbegin"` – вставить html в начало elem,
* `"beforeend"` – вставить html в конец elem,
* `"afterend"` – вставить html непосредственно после elem.

[Второй параметр] – это HTML-строка, которая будет вставлена именно «как HTML».

## Удаление узлов из DOM
---
`node.remove()` - удаление узла
> Если нам нужно переместить элемент в другое место – нет необходимости удалять его со старого. Все методы вставки автоматически удаляют узлы со старых мест.

## Клонирование узлов: cloneNode
---
`elem.cloneNode(true)` - создаёт «глубокий» клон элемента – со всеми атрибутами и дочерними элементами.  
`elem.cloneNode(false)` - клон будет без дочерних элементов.

## DocumentFragment
---
`DocumentFragment` является специальным DOM-узлом, который служит обёрткой для передачи списков узлов.
```html
<ul id="ul"></ul>
```
```javascript
function getListContent() {
  let fragment = new DocumentFragment();

  for(let i=1; i<=3; i++) {
    let li = document.createElement('li');
    li.append(i);
    fragment.append(li);
  }

  return fragment;
}

ul.append(getListContent()); // (*)
```

## Добавить HTML на страницу до завершения её загрузки
---
`document.write(html)` - записывает html на страницу «прямо здесь и сейчас». Строка html может быть динамически сгенерирована, поэтому метод достаточно гибкий. Мы можем использовать JavaScript, чтобы создать полноценную веб-страницу и записать её в документ.

* Вызов `document.write` работает только во время загрузки страницы.
* Метод работает невероятно быстро, ведь при этом нет модификации DOM. Метод пишет прямо в текст страницы, пока DOM ещё в процессе создания.

## Стили и классы
---
Как правило, существует два способа задания стилей для элемента:
* Создать класс в CSS и использовать его: <div class="...">
* Писать стили непосредственно в атрибуте style: <div style="...">.

JavaScript может менять и классы, и свойство style.  
> Классы – всегда предпочтительный вариант по сравнению со style. Мы должны манипулировать свойством style только в том случае, если классы «не могут справиться».

### className и classList - чтобы изменить атрибут class
---
1. `elem.className` - соответствует атрибуту "class" в HTML.
	> Если мы присваиваем что-то `elem.className`, то это заменяет всю строку с классами. 
1. `elem.classList` - это специальный объект с методами для добавления/удаления одного класса. Методы classList:
	* `elem.classList.add/remove("class")` – добавить/удалить класс.
	* `elem.classList.toggle("class")` – добавить класс, если его нет, иначе удалить.
	* `elem.classList.contains("class")` – проверка наличия класса, возвращает true/false.
	
	> Кроме того, classList является перебираемым, поэтому можно перечислить все классы при помощи for..of

### style - чтобы изменить стили в атрибуте style
---
`elem.style` – это объект, который соответствует тому, что написано в атрибуте "style".
1. Свойства из одного слова записываются так же, с маленькой буквы:
	* background  => `elem.style.background`
	* top         => `elem.style.top`
	* opacity     => `elem.style.opacity`
	* и др.
1. Для свойств из нескольких слов используется camelCase:
	* background-color  => `elem.style.backgroundColor`
	* z-index           => `elem.style.zIndex`
	* border-left-width => `elem.style.borderLeftWidth`
	* и др.
1. Стили с браузерным префиксом, например, `-moz-border-radius`,` -webkit-border-radius` преобразуются по тому же принципу: дефис означает заглавную букву.
	* `button.style.MozBorderRadius = '5px';`
	* `button.style.WebkitBorderRadius = '5px';`
	* и др.

> Не забудьте добавить к значениям единицы измерения. Например, мы должны устанавливать 10px, а не просто 10.

### cssText - добавление строки стилей в style
---
Свойство `style.cssText` соответствует всему атрибуту "style", полной строке стилей.
`elem.style.cssText = 'top: ${top}; left: ${left};'`

> cssText может как добавить стили к существующим, так и полностью перезаписать их на новые.

```javascript
let top = /* сложные расчёты */;
let left = /* сложные расчёты */;

// полная перезапись стилей elem, используем =
elem.style.cssText = `
  top: ${top};
  left: ${left};
`;

// добавление новых стилей к существующим стилям elem, используем +=
elem.style.cssText += `
  top: ${top};
  left: ${left};
`;

// если элементу уже заданы стили, которые мы хотим добавить (+=),
// они будут перезаписаны на новые.
```

### Сброс стилей
---
Иногда нам нужно добавить свойство стиля, а потом, позже, убрать его.
1. Чтобы скрыть элемент, мы можем задать `elem.style.display = "none"`.
1. Затем мы можем удалить свойство `style.display`, чтобы вернуться к первоначальному состоянию. Вместо delete elem.style.display мы должны присвоить ему пустую строку: `elem.style.display = ""`.

### Вычисленные стили: getComputedStyle
---
Свойство `style` оперирует только значением атрибута "`style`", без учёта CSS-каскада. Поэтому, используя `elem.style`, мы не можем прочитать ничего, что приходит из классов CSS.  
Для этого есть метод: `getComputedStyle`:  
`getComputedStyle(element, [pseudo])` - результат вызова – объект со стилями, похожий на `elem.style`, но с учётом всех CSS-классов.
* `element` - элемент, значения для которого нужно получить
* `pseudo` - указывается, если нужен стиль псевдоэлемента, например `::before`. Пустая строка или отсутствие аргумента означают сам элемент.

Есть две концепции в CSS:
* Вычисленное (computed) значение – это то, которое получено после применения всех CSS-правил и CSS-наследования. Например, height:1em или font-size:125%.
* Окончательное (resolved) значение – непосредственно применяемое к элементу. Значения 1em или 125% являются относительными. Браузер берёт вычисленное значение и делает все единицы измерения фиксированными и абсолютными, например, height:20px или font-size:16px. Для геометрических свойств разрешённые значения могут иметь плавающую точку, например, width:50.5px.
Давным-давно getComputedStyle был создан для получения вычисленных значений, но оказалось, что окончательные значения гораздо удобнее, и стандарт изменился.  
Так что, в настоящее время `getComputedStyle` фактически возвращает окончательное значение свойства, для геометрии оно обычно в пикселях.

> `getComputedStyle` требует полное свойство!
	Для правильного получения значения нужно указать точное свойство. Например: `paddingLeft`, `marginTop`, `borderTopWidth`. При обращении к сокращённому: padding, margin, border – правильный результат не гарантируется.
> Стили, применяемые к посещённым `:visited` ссылкам, скрываются!
	Посещённые ссылки могут быть окрашены с помощью псевдокласса :visited.
	Но `getComputedStyle` не даёт доступ к этой информации, чтобы произвольная страница не могла определить, посещал ли пользователь ту или иную ссылку, проверив стили.

# Размеры и прокрутка элементов
---
У элементов есть следующие геометрические свойства (метрики):
* `offsetParent` – ближайший CSS-позиционированный родитель или ближайший td, th, table, body.
* `offsetLeft/offsetTop` – позиция в пикселях верхнего левого угла относительно offsetParent (расстояние от родителя).
* `offsetWidth/offsetHeight` – «внешняя» ширина/высота элемента, включая рамки (общая ширина и высота с рамкой и отступами).
* `clientLeft/clientTop` – расстояние от верхнего левого внешнего угла до внутренного. Для операционных систем с ориентацией слева-направо эти свойства равны ширинам левой/верхней рамки. Если язык ОС таков, что ориентация справа налево, так что вертикальная полоса прокрутки находится не справа, а слева, то clientLeft включает в своё значение её ширину. (ширина рамки с прокрутой, если она есть)
* `clientWidth/clientHeight` – ширина/высота содержимого вместе с внутренними отступами padding, но без полосы прокрутки и без рамки.
* `scrollWidth/scrollHeight` – ширины/высота содержимого, аналогично clientWidth/Height, но учитывают прокрученную, невидимую область элемента.	
* `scrollLeft/scrollTop` – ширина/высота прокрученной сверху части элемента, считается от верхнего левого угла.

Все свойства доступны только для чтения, кроме `scrollLeft/scrollTop`, изменение которых заставляет браузер прокручивать элемент.

## Ширина/высота окна
### Получение ширины/высота окна
---
* Ширина/высота видимой части документа (ширина/высота области содержимого) для `html` работает на видимой области в отличии от элемента, которая показывает ширину и высоту документа: 
	```javascript
	document.documentElement.clientWidth; //ширина
	document.documentElement.clientHeight; //высота
	```
* Ширина/высота всего документа со всей прокручиваемой областью страницы (лучше вычислять по максимальному размеру из...):
	```javascript
	let scrollHeight = Math.max(
		document.body.scrollHeight, document.documentElement.scrollHeight,
		document.body.offsetHeight, document.documentElement.offsetHeight,
		document.body.clientHeight, document.documentElement.clientHeight
	);
	```

### Прокрутка окна
---
* Получение текущей прокрутки: 
	* `window.pageXOffset` – то же самое, что и `window.scrollX` - слева
	* `window.pageYOffset` – то же самое, что и `window.scrollY` - сверху

* Изменить текущую прокрутку:
	* `document.documentElement.scrollTop/Left` - не работает в Safari, лучше через `document.body.scrollTop/Left`
	* `window.scrollTo(pageX,pageY)` – абсолютные координаты, - это всё равно, что поставить scrollLeft/scrollTop. Для прокрутки в самое начало мы можем использовать `scrollTo(0,0)`.
	* `window.scrollBy(x,y)` – прокрутка относительно текущего места, прокручивает страницу относительно её текущего положения. Например, `scrollBy(0,10)` прокручивает страницу на 10px вниз.
		В обоих методах вместо координат также может использоваться объект options, как аргумент:
		```javascript
		window.scrollTo({
			top: 100,
			left: 0,
			behavior: "smooth"
		});
		```
		behavior – определяет, каким образом будет прокручиваться страница:
		* "smooth" – плавно (не поддерживается в IE и в старых версиях Safari)
		* "instant" – мгновенно
		* "auto" – определяется браузером (зависит от CSS-свойства scroll-behavior)

	* `elem.scrollIntoView(top)` – прокрутить страницу так, чтобы сделать `elem` видимым (выровнять относительно верхней/нижней части окна).
		* если top=true (по умолчанию), то страница будет прокручена, чтобы elem появился в верхней части окна. Верхний край элемента совмещён с верхней частью окна.
		* если top=false, то страница будет прокручена, чтобы elem появился внизу. Нижний край элемента будет совмещён с нижним краем окна.

		также принимает объект options как аргумент:
		```javascript
		this.scrollIntoView({
			behavior: "smooth",
			block: "end",
			inline: "nearest"
		});
		```

		* behavior – анимация прокрутки (smooth, instant, auto)
		* block – вертикальное выравнивание (start, center, end, nearest). Значение по умолчанию: start
		* inline – горизонтальное выравнивание (start, center, end, nearest). Значение по умолчанию: nearest

	> Для прокрутки страницы из JavaScript её DOM должен быть полностью построен. Например, если мы попытаемся прокрутить страницу из скрипта, подключенного в `<head>`, это не сработает.

### Запретить прокрутку документа
---
Чтобы запретить прокрутку страницы, достаточно установить `document.body.style.overflow = "hidden"`  
Чтобы разрешить прокрутку страницы, достаточно установить `document.body.style.overflow = ""`
> Аналогичным образом мы можем «заморозить» прокрутку для других элементов, а не только для document.body.

## Координаты
---
`getBoundingClientRect()` - возвращает координаты в контексте окна для минимального по размеру прямоугольника, который заключает в себе элемент elem, в виде объекта встроенного класса DOMRect.  
Основные свойства объекта типа DOMRect:
* `x/y` – X/Y-координаты начала прямоугольника относительно окна,
	> Internet Explorer и Edge: не поддерживают x/y, лучше использовать left/top
* `width/height` – ширина/высота прямоугольника (могут быть отрицательными).

Дополнительные, «зависимые», свойства:
* `top/bottom` – Y-координата верхней/нижней границы прямоугольника, (`bottom = y + height`)
* `left/right` – X-координата левой/правой границы прямоугольника. (`right = x + width`)

Любая точка на странице имеет координаты:  
* Относительно окна браузера – `elem.getBoundingClientRect()` с `position:fixed`
* Относительно документа – `elem.getBoundingClientRect()` + 'текущая прокрутка страницы `window.pageXOffset/pageYOffset`' с `position:absolute`

1. Координаты в контексте окна подходят для использования с `position:fixed`, а координаты относительно документа – для использования с `position:absolute`.
1. Каждая из систем координат имеет свои преимущества и недостатки. Иногда будет лучше применить одну, а иногда – другую, как это и происходит с позиционированием в CSS, где мы выбираем между `absolute` и `fixed`.

### Функция elementFromPoint(x, y)
---
Вызов `document.elementFromPoint(x, y)` возвращает самый глубоко вложенный элемент в окне, находящийся по координатам (x, y).  
```javascript
let centerX = document.documentElement.clientWidth / 2;
let centerY = document.documentElement.clientHeight / 2;

let elem = document.elementFromPoint(centerX, centerY);

elem.style.background = "red";
alert(elem.tagName);
```

# События
<u>Событие</u> – это сигнал от браузера о том, что что-то произошло. Все DOM-узлы подают такие сигналы (хотя события бывают и не только в DOM).

Часто используемые события:
1. События мыши:
	* `click` – происходит, когда кликнули на элемент левой кнопкой мыши (на устройствах с сенсорными экранами оно происходит при касании).
	* `contextmenu` – происходит, когда кликнули на элемент правой кнопкой мыши.
	* `mouseover / mouseout` – когда мышь наводится на / покидает элемент.
	* `mousedown / mouseup` – когда нажали / отжали кнопку мыши на элементе.
	* `mousemove` – при движении мыши.

1. События на элементах управления:
	`submit` – пользователь отправил форму `<form>`.
	* `focus` – пользователь фокусируется на элементе, например нажимает на `<input>`.

1. Клавиатурные события:
	* `keydown и keyup` – когда пользователь нажимает / отпускает клавишу.

1. События документа:
	* `DOMContentLoaded` – когда HTML загружен и обработан, DOM документа полностью построен и доступен.

1. CSS events:
	* `transitionend` – когда CSS-анимация завершена.

## Способы назначения обработчика
---
<u>Обработчики событий</u> - функция, которая сработает, как только событие произошло.

1. <u>Использование атрибута HTML</u>
	1. Обработчик в виде функции прямо в HTML
	```html
	<input value="Нажми меня" onclick="alert('Клик!')" type="button">
	```
	
	1. Обработчик в виде функции
	```javascript
	function countRabbits() {
		for(let i=1; i<=3; i++) {
			alert("Кролик номер " + i);
		}
	}
	```
	```html
	<input type="button" onclick="countRabbits()" value="Считать кроликов!">
	```

	* Если обработчик задан через атрибут, то браузер читает HTML-разметку, создаёт новую функцию из содержимого атрибута и записывает в свойство.  
	* Обработчик всегда хранится в свойстве DOM-объекта, а атрибут – лишь один из способов его инициализации.
	* Убрать обработчик можно назначением elem.onclick = null.
	* Обработчиком можно назначить и уже существующую функцию.

1. <u>Использование свойства DOM-объекта</u>  
	Можно назначать обработчик, используя свойство DOM-элемента `on<событие>`.

	```html
	<input id="elem" type="button" value="Нажми меня!">
	```
	```javascript
	elem.onclick = function() {
		alert('Спасибо');
	};
	```

	<u>Доступ к элементу через `this`.</u>  
	Внутри обработчика события `this` ссылается на текущий элемент, то есть на тот, на котором, как говорят, «висит» (т.е. назначен) обработчик.  
	В коде ниже `button` выводит своё содержимое, используя `this.innerHTML`:
	```html
	<button onclick="alert(this.innerHTML)">Нажми меня</button>
	```

	Частые ошибки:
	* Функция должна быть присвоена как `sayThanks`, а не `sayThanks()`.
	* Используйте именно функции, а не строки. Назначение обработчика строкой `elem.onclick = "alert(1)"` также сработает. Это сделано из соображений совместимости, но делать так не рекомендуется.
	* Не используйте setAttribute для обработчиков.
		```javascript
		// при нажатии на body будут ошибки,
		// атрибуты всегда строки, и функция станет строкой
		document.body.setAttribute('onclick', function() { alert(1) });
		```

1. <u>addEventListener</u>  
	Фундаментальный недостаток описанных выше способов назначения обработчика – невозможность повесить несколько обработчиков на одно событие.  
	Метод `addEventListener` позволяет добавлять несколько обработчиков на одно событие одного элемента, например:
	```javascript
	elem.onclick = () => alert("Привет");
  	elem.addEventListener("click", handler1); // Спасибо
  	elem.addEventListener("click", handler2); // Спасибо ещё раз!
	```

	* `element.addEventListener(event, handler, [options]);` - добавить обработчик
		1. `event` - имя события, например "click".
		1. `handler` - ссылка на функцию-обработчик.
		1. `options`:
			Дополнительный объект со свойствами:
			* `once`: если true, тогда обработчик будет автоматически удалён после выполнения.
			* `capture`: фаза, на которой должен сработать обработчик, подробнее об этом будет рассказано в главе Всплытие и погружение. Так исторически сложилось, что options может быть false/true, это то же самое, что {capture: false/true}.
			* `passive`: если true, то указывает, что обработчик никогда не вызовет preventDefault(), подробнее об этом будет рассказано в главе Действия браузера по умолчанию.
	
	* `element.removeEventListener(event, handler, [options]);` - удалить обработчик.
		Обратим внимание – если функцию обработчик не сохранить где-либо, мы не сможем её удалить. Нет метода, который позволяет получить из элемента обработчики событий, назначенные через `addEventListener`.
		```javascript
		function handler() {
			alert( 'Спасибо!' );
		}

		input.addEventListener("click", handler);
		// ....
		input.removeEventListener("click", handler);
		```

	> Обработчики некоторых событий можно назначать только через `addEventListener`. Например, таково событие `DOMContentLoaded`, которое срабатывает, когда завершена загрузка и построение DOM документа.
	```javascript
	document.onDOMContentLoaded = function() {
		alert("DOM построен"); // не будет работать
	};
	document.addEventListener("DOMContentLoaded", function() {
		alert("DOM построен"); // а вот так сработает
	});
	```

## Объект события
---
Чтобы хорошо обработать событие, могут понадобиться детали того, что произошло. Не просто «клик» или «нажатие клавиши», а также – какие координаты указателя мыши, какая клавиша нажата и так далее.  
Когда происходит событие, браузер создаёт объект события, записывает в него детали и передаёт его в качестве аргумента функции-обработчику.  

```html
<input type="button" value="Нажми меня" id="elem">
```
```javascript
elem.onclick = function(event) {
    // вывести тип события, элемент и координаты клика
    alert(event.type + " на " + event.currentTarget);
    alert("Координаты: " + event.clientX + ":" + event.clientY);
};
```

Некоторые свойства объекта event:
* `event.type` - тип события, в данном случае "click".
* `event.currentTarget` - элемент, на котором сработал обработчик. Значение – обычно такое же, как и у `this`, но если обработчик является функцией-стрелкой или при помощи `bind` привязан другой объекту в качестве `this`, то мы можем получить элемент из `event.currentTarget`.
* `event.clientX / event.clientY` - координаты курсора в момент клика относительно окна, для событий мыши.

> Объект события доступен и в HTML
	```javascript
	<input type="button" onclick="alert(event.type)" value="Тип события">
	```

## Объект-обработчик: handleEvent
---
* Мы можем назначить обработчиком не только функцию, но и объект при помощи `addEventListener`. В этом случае, когда происходит событие, вызывается метод объекта `handleEvent`.
```html
<button id="elem">Нажми меня</button>
```
```javascript
elem.addEventListener('click', {
	handleEvent(event) {
      alert(event.type + " на " + event.currentTarget);
    }
});
```

* Мы также можем использовать класс для этого:
```html
<button id="elem">Нажми меня</button>
```
```javascript
class Menu {
    handleEvent(event) {
      switch(event.type) {
        case 'mousedown':
          elem.innerHTML = "Нажата кнопка мыши";
          break;
        case 'mouseup':
          elem.innerHTML += "...и отжата.";
          break;
      }
    }
  }

let menu = new Menu();
elem.addEventListener('mousedown', menu);
elem.addEventListener('mouseup', menu);
```

Метод `handleEvent` не обязательно должен выполнять всю работу сам. Он может вызывать другие методы, которые заточены под обработку конкретных типов событий, вот так:
```javascript
class Menu {
    handleEvent(event) {
      // mousedown -> onMousedown
      let method = 'on' + event.type[0].toUpperCase() + event.type.slice(1);
      this[method]();
    }

    onMousedown() {
      elem.innerHTML = "Кнопка мыши нажата";
    }

    onMouseup() {
      elem.innerHTML += "...и отжата.";
    }
  }

let menu = new Menu();
elem.addEventListener('mousedown', menu);
elem.addEventListener('mouseup', menu);
```

