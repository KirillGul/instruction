Yii (yа яй яй) (произносится как Йи [ji:]) в китайском языке означает «простой и эволюционирующий». Также Yii может расшифровываться как акроним Yes It Is!
# Настройка шаблона advanced
1. После установки шаблона, необходимо в Command Promt перейти в папку с проектом и выполнить команду `init`
1. В папке /path/to/yii-application/common/config/main-local.php определить настройки компонента `components['db']` для подлкючения к БД
1. Необходимо в Command Promt перейти в папку с проектом и выполнить команду `yii migrate` - таким образом создастся стандартная таблица user и migration в БД
1. Если используется локальный ПК -> Добавить в ручную домен в OpenServer
1. Создать файл .htaaccess в backend/web и frontend/web
1. В таблице user поменять статус с 9 на 10
1. При включенном режиме `Development` необходимо повысить `traceLevel`, для этого в backend и frontend `'traceLevel' => YII_DEBUG ? 4 : 0`

Определенные алиасы:
* `@yii` - framework directory.
* `@app` - base path of currently running application.
* `@common` - common directory.
* `@frontend` - frontend web application directory.
* `@backend` - backend web application directory.
* `@console` - console directory.
* `@runtime` - runtime directory of currently running web application.
* `@vendor` - Composer vendor directory.
* `@bower` - vendor directory that contains the bower packages.
* `@npm` - vendor directory that contains npm packages.
* `@web` - base URL of currently running web application.
* `@webroot` - web root directory of currently running web application.

# Фреймворк
---------
Сам фреймворк находиться в папке vendor, его нельзя изменять.

# Входной скрипт
* для веб-приложение: ./web/{index.php} (или другое название в зависимости от настроек сервера)
* для консольного приложения: ./yii.php 
    * запуск консольного приложения: ./yii <маршрут> [аргументы] [опции]

Входные скрипты в основном делают следующую работу:
1. Объявляют глобальные константы;
1. Регистрируют загрузчик классов Composer;
1. Подключают файл класса Yii;
1. Загружают конфигурацию приложения;
1. Создают и конфигурируют объект приложения;
1. Вызывают метод `yii\base\Application::run()` приложения для обработки входящего запроса.

# Приложение
`\Yii::$app` - ссылка на приложение доступная глобально, т.к. подключение происходит во входном скрипте.
> `Yii::$app` представляет собой глобально доступный экземпляр-одиночку приложения (singleton). Одновременно это Service Locator, дающий доступ к компонентам вроде request, response, db и так далее.

### Существует два вида приложений:
* web приложения (занимается обработкой веб запросов)
* консольные приложения (занимается обработкой консольных команд)

## Свойства приложения
### Обязательные
1. `id` - это уникальный индекс приложения, который отличает его от других приложений. В основном это используется внутрисистемно. Хоть это и не обязательно, но для лучшей совместимости рекомендуется использовать буквенно-цифровые символы при указании индекса приложения.
1. `basePath` - указывает на корневую директорию приложения.
    
### Важные
1. `aliases` - это свойство позволяет настроить вам множество псевдонимов в рамках массива. Ключами массива являются имена псевдонимов, а значениями массива - соответствующие значения пути.
1. `bootstrap` - данное свойство является очень удобным, оно позволяет указать массив компонентов, которые должны быть загружены в процессе начальной загрузки приложения. Например, если вы хотите, чтобы модуль производил тонкую настройку URL правил, вы можете указать его ID в качестве элемента данного свойства.  
Каждый из элементов данного свойства, может быть указан в одном из следующих форматов:
* ID, указанный в компонентах;
* ID модуля, указанный в модулях;
* название класса;
* массив конфигурации;
* анонимная функция, которая создаёт и возвращает компонент.

В процессе начальной загрузки, каждый компонент будет создан. Если класс компонента имеет интерфейс `yii\base\BootstrapInterface`, то также будет вызван метод bootstrap().  
Примечание: указывание слишком большого количества компонентов в bootstrap приведет к снижению производительности приложения, потому что для каждого запроса одно будут загружаться все указанные компоненты. Таким образом вы должны использовать начальную загрузку разумно.
1. `catchAll` - данное свойство поддерживается только веб приложениями. Оно указывает действие контроллера, которое должно обрабатывать все входящие запросы от пользователя. В основном это используется, когда приложения находится в режиме обслуживания и должно обрабатывать все запросы через одно действие.
1. `components` - данное свойство является наиболее важным. Оно позволяет вам зарегистрировать список именованных компонентов, называемых компоненты приложения, которые Вы можете использовать в других местах. Каждый компонент приложения указан массивом в формате ключ-значение. Ключ представляет собой ID компонента приложения, в то время как значение представляет собой название класса или конфигурацию. Вы можете зарегистрировать любой компонент в приложении, позже этот компонент будет глобально доступен через выражение `\Yii::$app->componentID`.
1. `controllerMap` - данное свойство позволяет вам задавать соответствия(mapping) между ID контроллера и произвольным классом контроллера. По-умолчанию, Yii задает соответствие между ID контроллера и его классом согласно соглашению, что ID post будет соответствовать `app\controllers\PostController`. Задавая эти свойства вы можете переопределить соответствия для необходимых контроллеров.
1. `controllerNamespace` - данное свойство указывает пространство имен, в котором по умолчанию должны находится названия классов контроллеров. По-умолчанию значение равно `app\controllers`. Если ID контроллера post, то согласно соглашению, соответствующий класс контроллера (без пространства имен) будет равен `PostController`, а полное название класса будет равно `app\controllers\PostController`.
1. `language` - данное свойство указывает язык приложения, на котором содержимое страницы должно быть отображено конечному пользователю. По-умолчанию значение данного свойства равно `en`, что означает "Английский". Если ваше приложение должно поддерживать несколько языков, вы должны настроить данное свойство.
1. `modules` - данное свойство указывает модули, которые содержатся в приложении.
1. `name` - свойство указывает название приложения, которое может быть показано конечным пользователям. В отличие от свойства `id`, которое должно быть уникальным, значение данного свойства нужно в основном для отображения и не обязательно должно быть уникальным. 
Если ваш код не использует данное свойство, то вы можете не настраивать его.
1. `params` - данное свойство указывает массив глобально доступных параметров приложения.  Вместо того, чтобы использовать жестко фиксированные числа и строки в вашем коде, лучше объявить их параметрами приложения в едином месте и использовать в нужных вам местах кода.
1. `sourceLanguage` - данное свойство указывает язык на котором написан код приложения. По-умолчанию значение равно '`en-US`', что означает "Английский" (США). Вы должны настроить данное свойство соответствующим образом, если содержимое в вашем коде является не английским языком.
1. `timeZone` - данное свойство предоставляет альтернативный способ установки временной зоны в процессе работы приложения. Путем указания данного свойства, вы по существу вызываете PHP функцию `date_default_timezone_set()`.
1. version - данное свойство указывает версию приложения. По-умолчанию значение равно '1.0'. Вы можете не настраивать это свойство, если ваш код не использует его.
        
### Полезные
1. `charset` - свойство указывает кодировку, которую использует приложение. По-умолчанию значение равно '`UTF-8`' - должно быть оставлено как есть для большинства приложения, только если вы не работаете с устаревшим кодом, который использует большее количество данных не юникода.
1. `defaultRoute` - свойство указывает маршрут, который должно использовать приложение, когда он не указан во входящем запросе. Маршрут может состоять из ID модуля, ID контроллера и/или ID действия.  
Например, help, post/create, admin/post/create. Если действие не указано, то будет использовано значение по умолчанию указанное в `yii\base\Controller::$defaultAction`. Для веб приложений, значение по умолчанию для данного свойства равно 'site', что означает контроллер `SiteController` и его действие по умолчанию должно быть использовано. Таким образом, если вы попытаетесь получить доступ к приложению не указав маршрут, оно покажет вам результат действия `app\controllers\SiteController::actionIndex()`. Для консольных приложений, значение по умолчанию равно '`help`', означающее, что встроенная команда `yii\console\controllers\HelpController::actionIndex(`) должна быть использована. Таким образом, если вы выполните команду yii без аргументов, вам будет отображена справочная информация.
1. `extensions` - данное свойство указывает список расширений, которые установлены и используются приложением. По-умолчанию, значением данного свойства будет массив, полученный из файла `@vendor/yiisoft/extensions.php`. Файл extensions.php генерируется и обрабатывается автоматически, когда вы используете Composer для установки расширений.  Таким образом, в большинстве случаев вам не нужно настраивать данное свойство.
1. `layout` - данное свойство указывает имя шаблона по умолчанию, который должен быть использовать при формировании представлений. Значение по умолчанию равно '`main`', означающее, что должен быть использован шаблон main.php в папке шаблонов. Если оба свойства папка шаблонов и папка представлений имеют значение по умолчанию, то файл шаблона по умолчанию может быть представлен псевдонимом пути как `@app/views/layouts/main.php`. Для отключения использования шаблона, вы можете указать данное свойство как false, хотя это используется очень редко.
1. `layoutPath` - свойство указывает путь, по которому следует искать шаблоны. Значение по умолчанию равно `layouts`, означающее подпапку в папке представлений. Если значение папки представлений является значением по умолчанию, то папка шаблонов по умолчанию может быть представлена псевдонимом пути как `@app/views/layouts`. Вы можете настроить данное свойство как папку так и как псевдоним.
1. `runtimePath` - свойство указывает путь, по которому хранятся временные файлы, такие как: лог файлы, кэш файлы. По-умолчанию значение равно папке, которая представлена псевдонимом пути `@app/runtime`. Для упрощения работы с данной папкой, Yii предоставляет предопределенный псевдоним пути `@runtime`.
1. `viewPath` - данное свойство указывает базовую папку,где содержаться все файлы представлений. Значение по умолчанию представляет собой псевдоним `@app/views`. Вы можете настроить данное свойство как папку так и как псевдоним.
1. `vendorPath` - свойство указывает папку сторонних библиотек, которые используются и управляются Composer. Она содержит все сторонние библиотеки используемые приложением, включая Yii фреймворк. Значение по умолчанию представляет собой псевдоним @app/vendor. Вы можете настроить данное свойство как папку так и как псевдоним. При изменении данного свойства, убедитесь что вы также изменили соответствующим образом настройки Composer. Для упрощения работы с данной папкой, Yii предоставляет предопределенный псевдоним пути `@vendor`.
1. `enableCoreCommands` - данное свойство поддерживается только консольными приложениями.  Оно указывает нужно ли использовать встроенные в Yii консольные команды. Значение по умолчанию равно true.

## Service Locator
[Ссылка на общие сведения про Service Locator](https://github.com/codedokode/pasta/blob/master/arch/di.md#%D1%87%D0%B5%D0%BC-%D0%BF%D0%BB%D0%BE%D1%85-servicelocator)

1. Service Locator - является объектом, предоставляющим всевозможные сервисы (или компоненты), которые могут понадобиться приложению.  
1. В Service Locator каждый компонент представлен единственным экземпляром, имеющим уникальный ID.  
1. Уникальный идентификатор (ID) может быть использован для получения компонента из Service Locator.  
1. В Yii Service Locator является экземпляром класса `yii\di\ServiceLocator` или его дочернего класса.

`yii\di\ServiceLocator::set()` - регистрация в Service Locator
`yii\di\ServiceLocator::has()` - проверка регистрации в Service Locator
`yii\di\ServiceLocator::get()` - вызов компонента

Yii реализует свой service locator поверх контейнера внедрения зависимостей. Когда service locator пытается создать новый экземпляр объекта, он перенаправляет вызов на контейнер внедрения зависимостей. Последний будет разрешать зависимости автоматически, как описано выше.

## Dependency Injection Container (контейнер внедрения зависимостей)
[Ссылка на общие сведения про DI Container](https://github.com/codedokode/pasta/blob/master/arch/di.md#%D1%87%D0%B5%D0%BC-%D1%85%D0%BE%D1%80%D0%BE%D1%88-di-container)  

1. Контейнер внедрения зависимостей — это объект, который знает, как создать и настроить экземпляр класса и зависимых от него объектов.
1. Yii обеспечивает функционал контейнера внедрения зависимостей через класс `yii\di\Container`. Он поддерживает следующие виды внедрения зависимостей:
* Внедрение зависимости через конструктор;
* Внедрение зависимости через метод;
* Внедрение зависимости через сеттер и свойство;
* Внедрение зависимости через PHP callback;
1. `\Yii::$container` - ссылка на контейнер DI
1. Yii создаёт контейнер внедрения зависимостей когда вы подключаете файл Yii.php во входном скрипте вашего приложения. При вызове `Yii::createObject()`, метод на самом деле вызовет метод контейнера `get()`, чтобы создать новый объект. Как упомянуто выше, контейнер внедрения зависимостей автоматически разрешит зависимости (если таковые имеются) и внедрит их получаемый объект. Поскольку Yii использует `Yii::createObject()` в большей части кода своего ядра для создания новых объектов, это означает, что вы можете настроить глобальные объекты, имея дело с `Yii::$container`.

### Регистрация зависимостей
1. `yii\di\Container::set()` - используется для регистрации зависимостей. Зависимость, зарегистрированная через set() создаёт экземпляр каждый раз, когда зависимость необходима. 
1. Вы можете использовать `yii\di\Container::setSingleton()` для регистрации зависимости, которая создаст только один экземпляр:

При регистрации требуется имя зависимости, а также определение зависимости:
1. именем может быть имя класса, интерфейса или алиас
1. определением зависимости может быть имя класса, конфигурационный массив или PHP callback
            
### Когда следует регистрировать зависимости
Поскольку зависимости необходимы тогда, когда создаются новые объекты, то их регистрация должна быть сделана как можно раньше. 
Рекомендуемые практики Yii:
* Если вы разработчик приложения, то вы можете зарегистрировать зависимости в конфигурации вашего приложения
* Если вы разработчик распространяемого расширения, то вы можете зарегистрировать зависимости в загрузочном классе расширения.
            
### Разрешение зависимостей
* `yii\di\Container::get()` - используется для создания или получения объектов и разрещения зависимостей, метод принимает имя зависимости, которым может быть имя класса, имя интерфейса или псевдоним. Имя зависимости может быть зарегистрировано через `set()` или `setSingleton()`.  
* Вы можете опционально предоставить список параметров конструктора класса и конфигурацию для настройки созданного объекта.  
* После регистрации зависимостей, вы можете использовать контейнер внедрения зависимостей для создания новых объектов, и контейнер автоматически разрешит зависимости их экземпляра и их внедрений во вновь создаваемых объектах. 
* Разрешение зависимостей рекурсивно, то есть если зависимость имеет другие зависимости, эти зависимости также будут автоматически разрешены.

# Контролллер
## Соглашение по умолчанию об именовании контролеров
Если ID контроллера `post`, то согласно соглашению, соответствующий класс контроллера (без пространства имен) будет равен `PostController`, а полное название класса будет равно `app\controllers\PostController`.  
По-умолчанию: `namespace app\controllers`.  

# Модель
1. Модели являются частью архитектуры MVC. Они представляют собой объекты бизнес данных, правил и логики.  
1. Чаще всего модели это объекты классов, унаследованных от yii\base\Model или их потомков (например класс Model также является базовым классом для многих расширенных моделей, таких как yii\db\ActiveRecord).  
> Вы не обязаны основывать свои классы моделей на yii\base\Model. Однако, поскольку в yii есть много компонентов, созданных для поддержки yii\base\Model, обычно так делать предпочтительнее для базового класса модели.
3. Название класса модели будет связано с таким же именем таблицы в базе данных.
> Если нет возможности задать прямую зависимость между именем таблицы и именем класса, вы можете переопределить метод `yii\db\ActiveRecord::tableName()`, чтобы явно задать имя связанной таблицы.

## Атрибуты модели
* модели предоставляют рабочие данные в терминах атрибутах (т.е. атрибуты выступают описанием полей БД). Каждый атрибут представляет собой публично доступное свойство модели.
* метод `yii\base\Model::attributes()` определяет какие атрибуты имеет класс модели (возвращает массив имен атрибутов)
* также возможно получить доступ к атрибутам как к элементам массива, спасибо поддержке ArrayAccess и Traversable в `yii\base\Model`

## Определение Атрибутов
* по умолчанию, если ваш класс модели расширяется напрямую от `yii\base\Model`, то все не статичные публичные переменные являются атрибутами.
* можно переопределить метод `yii\base\Model::attributes()`, чтобы определять атрибуты другим способом. Метод должен возвращать имена атрибутов в модели. 
Например `yii\db\ActiveRecord` делает так, возвращая имена столбцов из связанной таблицы базы данных в качестве имён атрибутов. Также может понадобиться переопределить магические методы, такие как `__get()`, `__set()` для того, чтобы атрибуты могли быть доступны как обычные свойства объекта.

## Метки атрибутов
* при отображении значений или при получении ввода значений атрибутов, часто требуется отобразить некоторые надписи, связанные с атрибутами. Например, если атрибут назван firstName, Вы можете отобразить его как First Name, что является более удобным для пользователя, в тех случаях, когда атрибут отображается конечным пользователям в таких местах, как форма входа и сообщения об ошибках.
* получить метку атрибута, вызвав `yii\base\Model::getAttributeLabel()`.
* если Вы не хотите использовать автоматически сгенерированные метки, Вы можете переопределить метод yii\base\Model::attributeLabels(), чтобы явно объявить метку атрибута
* можно даже условно определять метки атрибутов. Например, на основе сценариев и использованной в нём модели, Вы можете возвращать различные метки для одного и того же атрибута.
    
## Сценании модели
* Модель использует свойство `yii\base\Model::$scenario`, чтобы отслеживать сценарий, в котором она используется.  
* По умолчанию, модель поддерживает только один сценарий с именем `default`.  
Пример установки сценария:
```php
// сценарий задается как свойство
$model = new User;
$model->scenario = User::SCENARIO_LOGIN;

// или сценарий задается через конфигурацию
$model = new User(['scenario' => User::SCENARIO_LOGIN]);
```

* По умолчанию сценарии, поддерживаемые моделью, определяются правилами валидации объявленными в модели. Однако Вы можете изменить это поведение путем переопределения метода `yii\base\Model::scenarios()`. Метод `scenarios()` возвращает массив, ключами которого являются имена сценариев, а значения - соответствующие активные атрибуты.  
* Активные атрибуты могут быть массово присвоены и подлежат валидации.  
```php
const SCENARIO_LOGIN = 'login';
const SCENARIO_REGISTER = 'register';

public function scenarios()
{
    return [
        self::SCENARIO_LOGIN => ['username', 'password'],
        self::SCENARIO_REGISTER => ['username', 'email', 'password'],
    ];
}
```

* По умолчанию реализация scenarios() вернёт все найденные сценарии в правилах валидации, задекларированных в методе `yii\base\Model::rules()`.  
* При переопределении метода `scenarios()`, если Вы хотите ввести новые сценарии помимо стандартных, Вы можете написать код на основе следующего примера:
```php
public function scenarios()
{
    $scenarios = parent::scenarios();
    $scenarios[self::SCENARIO_LOGIN] = ['username', 'password'];
    $scenarios[self::SCENARIO_REGISTER] = ['username', 'email', 'password'];
    return $scenarios;
}
```
        
## Правила валидации
* Когда данные модели, получены от конечных пользователей, они должны быть проверены, для того чтобы убедиться, что данные удовлетворяют определенным правилам (так называемым правилам валидации также известными как бизнес-правила).  
* Вы можете вызвать `yii\base\Model::validate()` для проверки полученных данных. Данный метод будет использовать правила валидации определённые в `yii\base\Model::rules()` для проверки каждого соответствующего атрибута. Если ошибок не найдено, то возвращается `true`, в противном случае возвращается `false`, а ошибки содержит свойство `yii\base\Model::$errors`.
```php
$model = new \app\models\ContactForm;

// модель заполнения атрибутов данными, вводимыми пользователем
$model->attributes = \Yii::$app->request->post('ContactForm');

if ($model->validate()) {
    // все данные верны
} else {
    // проверка не удалась:  $errors - это массив содержащий сообщения об ошибках $errors = $model->errors;
}
```

* Объявляем правила валидации связанные с моделью, переопределяем метод `yii\base\Model::rules()` возврата правил атрибутов модели которые следует удовлетворить.
Правило может использоваться для проверки одного или нескольких атрибутов, также и атрибут может быть проверен одним или несколькими правилами. 
```php
public function rules()
{
    return [
        // name, email, subject и body атрибуты обязательны
        [['name', 'email', 'subject', 'body'], 'required'],

        // атрибут email должен быть правильным email адресом
        ['email', 'email'],
    ];
}
```

Иногда необходимо, чтобы правила применялись только в определенных сценариях. Чтобы это сделать необходимо указать свойство `on` в правилах, следующим образом:
```php
public function rules()
{
    return [
        // username, email и password требуются в сценарии "register"
        [['username', 'email', 'password'], 'required', 'on' => self::SCENARIO_REGISTER],

        // username и password требуются в сценарии "login"
        [['username', 'password'], 'required', 'on' => self::SCENARIO_LOGIN],
    ];
}
```

* Если не указать свойство `on`, то правило применяется во всех сценариях. 
* Правило называется активным правилом если оно может быть применено в текущем сценарии `scenario`.
* Атрибут будет проверяться тогда и только тогда если он является активным атрибутом объявленным в `scenarios()` и связанным с одним или несколькими активными правилами, объявленными в `rules()`.
        
## Массовое Присвоение атрибутов модели
Массовое присвоение - это удобный способ заполнения модели данными вводимыми пользователем с помощью одной строки кода.  
Он заполняет атрибуты модели путем присвоения входных данных непосредственно свойству `yii\base\Model::$attributes`.
```php
$model = new \app\models\ContactForm;
$model->attributes = \Yii::$app->request->post('ContactForm');
```

### Безопасные Атрибуты
Массовое присвоение применяется только к так называемым безопасным атрибутам, которые являются атрибутами, перечисленными в `yii\base\Model::scenarios()` в текущем сценарии `scenario` модели.

> Причиной того, что массовое присвоение атрибутов применяется только к безопасным атрибутам, является то, что необходимо контролировать какие атрибуты могут быть изменены конечными пользователями. Например, если модель User имеет атрибут permission, который определяет разрешения, назначенные пользователю, то необходимо быть уверенным, что данный атрибут может быть изменён только администраторами через бэкэнд-интерфейс.

По умолчанию `yii\base\Model::scenarios()` будет возвращать все сценарии и атрибуты найденные в `yii\base\Model::rules()`, если не переопределить этот метод, атрибут будет считаться безопасным только в случае, если он участвует в любом из активных правил проверки.  
По этой причине существует специальный валидатор с псевдонимом `safe`, он предоставляет возможность объявить атрибут безопасным без фактической его проверки.  
```php
//следующие правила определяют, что оба атрибута title и description являются безопасными атрибутами.
public function rules()
{
    return [
        [['title', 'description'], 'safe'],
    ];
}
```
   
### Небезопасные Атрибуты
Как сказано выше, метод `yii\base\Model::scenarios()` служит двум целям: определения, какие атрибуты должны быть проверены, и определения, какие атрибуты являются безопасными (т.е. не требуют проверки). В некоторых случаях необходимо проверить атрибут не объявляя его безопасным. Вы можете сделать это с помощью префикса восклицательный знак ! в имени атрибута при объявлении его в scenarios() как атрибут secret в следующем примере:
```php
public function scenarios()
{
    return [
        self::SCENARIO_LOGIN => ['username', 'password', '!secret'],
    ];
}
```
Когда модель будет присутствовать в сценарии login, то все три эти атрибута будут проверены. Однако, только атрибуты username и password могут быть массово присвоены. Назначить входное значение атрибуту secret нужно явно следующим образом,
```php
$model->secret = $secret;
```

## Экспорт Данных
Часто нужно экспортировать модели в различные форматы. Например, может потребоваться преобразовать коллекцию моделей в JSON или Excel формат.  
Процесс экспорта может быть разбит на два самостоятельных шага:
* на первом этапе модели преобразуются в массивы; 
* на втором этапе массивы преобразуются в целевые форматы. Вы можете сосредоточиться только на первом шаге потому что второй шаг может быть достигнут путем универсального инструмента форматирования данных, такого как `yii\web\JsonResponseFormatter`.

Самый простой способ преобразования модели в массив - использовать свойство `yii\base\Model::$attributes`.
```php
$post = \app\models\Post::findOne(100);
$array = $post->attributes;
```

По умолчанию свойство `yii\base\Model::$attributes` возвращает значения всех атрибутов объявленных в `yii\base\Model::attributes()`.  
Более гибкий и мощный способ конвертирования модели в массив - использовать метод `yii\base\Model::toArray()`.  
Его поведение по умолчанию такое же как и у `yii\base\Model::$attributes`. Тем не менее, он позволяет выбрать, какие элементы данных, называемые полями, поставить в результирующий массив и как они должны быть отформатированы. На самом деле, этот способ экспорта моделей по умолчанию применяется при разработке в RESTful Web service, как описано в Response Formatting.

## Поля
Поле - это просто именованный элемент в массиве, который может быть получен вызовом метода `yii\base\Model::toArray()` модели.По умолчанию имена полей эквивалентны именам атрибутов. Однако, это поведение можно изменить, переопределив методы `fields()` и/или `extraFields()`. [Подробнее по ссылке](https://www.yiiframework.com/doc/guide/2.0/ru/structure-models#attribute-labels)

> По умолчанию все атрибуты модели будут включены в экспортируемый массив, вы должны проверить ваши данные и убедиться, что они не содержат конфиденциальной информации. Если такая информация присутствует, вы должны переопределить fields() и отфильтровать поля.
