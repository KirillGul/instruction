Общие сведения про ООП:
-----------------------
Объектно-ориентированное программирование (т.е. основанное на объектах) - это подход, базирующийся на объектах и на взаимоотношениях между ними.
Структу́рное программи́рование — это подход, в основе которой лежит представление программы в виде иерархической структуры блоков (if/then/else/for/while и др.).

Класс - это чертеж объекта (пример: чертеж с помощью которого на заводе делаются автомобили). Дополнительно: название класса должно быть в CamelCase.
Объект же - это экземляр класса (пример: сама машина, сделанная по этому чертежу класса). Дополонительно: название объекта с маленькой буквы в camelCase.
	ВАЖНО: объекты передаются по ссылке, т.е. при записи (присвоении) в другую переменную объекты не копируются, а передаются по ссылке.

Инкапсуляциия - это возможность объектов содержать только свои свойства, методы. Указатель $this, а также модификаторы доступа "private" и "protected", это то же проявления инкапсуляции.

Наследование - это наследование свойств и методов от родительского класса. Ключевое слово extends.
	extends (англ. "расширять") - класс-потомок наследует только public и protected методы и свойства, но не private.
		!!!В PHP нет множественного наследования - каждый класс может иметь только одного родителя.
	parent::сам метод - вызываем метод родителя в наследуемом классе (обращение к переопределённому методы родителя)
		Пример: parent::setAge($age);

	Модификаторы доступа:
	--------------------
	1) public - "доступно" - указывает на то, что данные свойства и методы доступны извне (вне кода класса)
		Все public-свойства и методы, то есть то, что позволяет нам напрямую взаимодействовать с объектами извне, называются интерфейсом класса.
	2) private - "недоступно" - указывает на то, что свойства и методы недоступны извне и не наследуются потомками
	3) protected - "защищен" - чтобы методы или свойства родителя наследовались потомками, но при этом для всего остального мира вели себя как приватные.
	Доп.: 
		- public и private не нужны для реализации логики программы, а нужны для того, чтобы уберечь программистов от ошибок.
		- существует специальное правило: если вы делаете новый метод и не знаете, сделать его публичным или приватным, - делайте приватным.

Полиморфизм — свойство системы, позволяющее иметь множество реализаций одного интерфейса.
Полиморфизм — это способность обьекта использовать методы производного класса, который не существует на момент создания базового (абстрактные классы).
	$this привязывается к объекту, в котором код выполняется, а не там, где он был описан.
	Абстракция - это интерфейс, а реализация - это классы. Могут быть разные классы, реализующие один и тот же интерфейс.
	Возможность выбора реализации во время выполнения кода и есть полиморфизм.

Доп.:
	Правила совместимости сигнатуры - при переопределении метода его сигнатура должна быть совместима с родительским методом. 
		Правила совместимости не распространяются на конструктор и сигнатуру private методов, они не будут выдавать фатальную ошибку в случае несоответствия сигнатуры. 
		Сигнатура является совместимой, если она соответствует правилам:
		- контравариантности - делает обязательный параметр необязательным
		- если какие-либо новые параметры являются необязательными
		Ковариантность - позволяет дочернему методу возвращать более конкретный тип, чем тип возвращаемого значения его родительского метода.
		Контравариантность - позволяет типу параметра в дочернем методе быть менее специфичным, чем в родительском.

Общие правила начала именования методов классов в ООП:
	- add... - добавить к значению
	- is... - проверка на что либо
	- get... - вывести (геттер) одну сущность
	- find... - вывести несколько сущностей
	- set... - записать (сеттер) 
		Очень часто бывает так, что даже если нам не нужны никакие проверки - все равно свойство объявляется приватным, 
		а для доступа к нему используются геттеры и сеттеры. Почему? 
		Потому что, возможно, нам захочется добавить проверку в дальнейшем и, если все изменения свойства в коде делаются через сеттер, 
		нам не придется вносить правки в код снаружи класса - мы просто внесем одну правку в сам сеттер. 

Абстрактные классы представляют собой классы, предназначенные для наследования от них. При этом объекты таких классов нельзя создать.

==============================================================================================
Ключевые слова в PHP:
---------------------
class - создание класса (пример: class Car {свойства и методы})
new - создание объекта к определенному классу (пример: $mycar = new Car;)
-> - обращение к свойству или методу объекта (пример: $myCar->name; и $myCar->go();)
$this - обращение к текущему объекту. Для того, чтобы обратиться к свойству или методу класса внутри метода этого объекта класса, 
	вместо имени созданного объекта следует писать специальную переменную $this, которая существует только у созданного объекта.
parent:: - обращение к свойствам и методам родительского класса
self:: – это обращение к текущему классу (как $this – обращение к текущему объекту, не путайте эти понятия). Подставится класс, в котором этот метод определен (родитель).
static:: - тогда будет подставлено имя класса, у которого этот метод был вызван (где вызывается) (позднее связывание).
	Это выражение называется поздним статическим связыванием – благодаря нему мы можем писать код, который будет зависеть от класса, в котором он вызывается, а не в котором он описан.
	Пример:
		class A 
		{
			public function foo(): string 
			{
				return self::class;
			}

			public function bar(): string 
			{
				return static::class;
			}
		}

		class B extends A
		{
		}

		$b = new B();

		var_dump($b->foo()); // A
		var_dump($b->bar()); // B
::class - используется для разрешения имени класса (https://myrusakov.ru/php-class-name-resolution-keyword.html), возвращает строку с полным именем класса
	 Если непонятно почему бы не написать сразу строку, то так делается по нескольким причинам:
		1) Имя класса в коде далеко не всегда пишется с неймспейсом (когда он подключен через use в шапке файла в коде ниже пишется только имя)
		2) IDE при рефакторинге класса (переименовании, смене неймспейса), автоматически подставит новое значение, так как в коде прописано обращение именно к классу, 
			а не к какой-то непонятной строке
		3) Зачастую мы сами не знаем какой класс у объекта, в таком случае можно использовать конструкцию ::class с переменной, 
			в которой лежит объект: $obj::class
	оператор разрешения области видимости (::)
	Пример 1:
		class Controller {}
		echo Controller::class; // возвращает имя класса Controller
	Пример 2:
		namespace App\Controllers;
		class Controller {}
		echo Controller::class; // возвращает App\Controllers\Controller

instanceof - данный оператор используется для определения того, является ли текущий объект экземпляром указанного класса или интерфейса,
	instanceof не делает различия при проверки между родительскими и дочерними классами.
	var_dump($obj instanceof ChildClass);  // выведет true

Пример:
[
class Car
{
	public $color; // цвет автомобиля - свойство
	public $fuel; // количество топлива - свойство
		
	// Команда ехать: - метод
	public function go()
	{
		// какой-то PHP код
	}
		
	// Команда поворачивать: - метод
	public function turn()
	{
		// какой-то PHP код
	}
		
	// Команда остановиться: - метод
	public function stop()
	{
		// какой-то PHP код
	}
}

$myCar = new Car; // запишем созданный объект в переменную $myCar
$myCar->fuel = 50; // заливаем топливо - обращение к свойству
$myCar->go();   // автомодиль->едь - обращение к методы обязательно в конце ()
]


Конструктор класса:
------------------
__construct - если в коде класса существует метод с таким названием - он будет вызываться в момент создания объекта.
	Пример: $user = new User('john', 25); // создадим объект, сразу заполнив его данными
	
	В __construct, можно задавать начальные значения свойств.
	Пример: 
	[
		public function __construct()
		{
			$this->prop1 = 'value1'; // начальное значение свойства
			$this->prop2 = 'value2'; // начальное значение свойства
		}
	]

Константы классов:
------------------
const - создание константы через "const", затем написать имя константы без доллара и обязательно сразу же задать ее значение. (пример: const CONSTANT = 'test';)
	Константы класса задаются один раз для всего класса, а не отдельно для каждого объекта этого класса. Дополнительно: название константы должно быть CAMEL_CASE.
	Обращение к константе:
		echo Test::CONSTANT; - обращение напрямую, через класс или объект Test (вне класса)
		self::CONSTANT; - обращение внутри метода (внутри класса)

Сравнение объектов:
-------------------
== - используется для сравнения двух объектов, выполняется сравнение свойств объектов: два объекта равны, 
	если они имеют одинаковые свойства и их значения (значения свойств сравниваются через ==) и являются экземплярами одного и того же класса. 
=== - переменные, содержащие объекты, считаются равными только тогда, когда они ссылаются на один и тот же экземпляр одного и того же класса.


Статические свойства и методы:
------------------------------
К прочтению - https://www.php.net/manual/ru/language.oop5.static.php
static - при работе с классами можно делать методы и свойства, которые для своего вызова не требуют создания объекта. Такие методы называются статическими.
	Которые принадлежат классу целиком, а не созданным объектам этого класса.
	Пример: [
		public static function method()
		{
			return '!!!';
		}
	]

	Чтобы обратиться к статическому методу, нужно написать имя класса, потом два двоеточия и имя метода, объект класса при этом создавать не надо, вот так:
	Test::method(); - для метода без $
	Test::$property; - для свойства с $
	Пример: [
		echo Test::method(); // выведет '!!!'
	]

	self:: - для обращения к статическому методу внутри класса.
	Важно:
		Статические свойства принадлежат не какому-то объекту класса, а самому классу, хотя объекты класса и имеют доступ к этим свойствам. 
		На практике это означает то, что если у нас есть несколько объектов класса - статические свойства у них будут общие. 
		То есть, если в одном объекте поменять значение статического свойства - изменения произойдут во всех объектах.
		Внутри статических методов недоступен $this.

Функции для классов ООП:
------------------------
get_class - возвращает имя класса, к которому принадлежит объект get_class(object $object = ?): string
get_class_methods - возвращает массив имён методов класса (т.е. какие методы есть в данном классе в виде массива)  get_class_methods(object|string $object_or_class): array
get_class_vars - возвращает объявленные по умолчанию свойства класса 
	(возвращает ассоциативный массив объявленных свойств класса, видимых из текущей области видимости, с их значением по умолчанию)
	get_class_vars(string $class): array
get_object_vars - возвращает свойства указанного объекта
	(возвращает видимые нестатические свойства указанного объекта object в соответствии с областью видимости)
	 get_object_vars(object $object): array
class_exists - проверяет, был ли объявлен класс class_exists(string $class, bool $autoload = true): bool
method_exists - проверяет, существует ли метод в данном классе method_exists(object|string $object_or_class, string $method): bool
property_exists - проверяет, содержит ли объект или класс указанный атрибут property_exists(object|string $object_or_class, string $property): bool
get_parent_class - возвращает имя родительского класса для объекта или класса get_parent_class(object|string $object_or_class = ?): string
is_subclass_of - проверяет, содержит ли объект в своём дереве предков указанный класс либо прямо реализует его 
	is_subclass_of(mixed $object_or_class, string $class, bool $allow_string = true): bool
is_a - проверяет, принадлежит ли объект к данному классу или является ли этот класс одним из его родителей
	is_a(mixed $object_or_class, string $class, bool $allow_string = false): bool
get_declared_classes - возвращает массив с именами объявленных классов get_declared_classes(): array

----------------------------------------------------------------------------------------------------------------------------------
Абстрактные классы:
-------------------
abstract - объявление абстрактного класса, такие классы не имеют объектов, а нужны для наследования. Также данное слово принудительно запрещает создавать данный класс.
При наследовании от abstract используют extends.

Абстрактные методы:
-------------------
	Абстрактные классы также могут содержать как обычне так и абстрактные методы. Абстрактные методы не должны иметь реализации, а нужны для того, чтобы указать, 
		что такие методы должны быть у потомков, также в абстрактных методах можно указывать обязательные значения.
	А собственно реализация таких методов - уже задача потомков.
	Пример: [
			abstract class User
			{		
				// Абстрактный метод без тела:
				abstract public function increaseRevenue($value);
			}
	]

	- При наследовании от абстрактного класса, все методы, помеченные абстрактными в родительском классе, должны быть определены в дочернем классе. 
	- При этом область видимости этих методов должна совпадать или быть менее строгой.
	- Количество обязательных параметров должно быть одинаковым. Однако класс-потомок может добавлять необязательные параметры, которые не были указаны при объявлении метода в родителе.

----------------------------------------------------------------------------------------------------------------------------------
Интерфейсы:
-----------
interface (интерфейсы) - представляют собой абстрактные классы, у которых все методы являются публичными и не имеющими реализации. 
	Код методов должны реализовывать классы-потомки интерфейсов.
	Для наследования от интерфейсов используется немного другая терминология: говорят, что классы не наследуют от интерфейсов, а реализуют их.
	При реализации от interface используют implements, 
	При наследовании от interface в другом interface используют extends.
		Важно: {
		------
			В PHP нет множественного наследования - каждый класс может иметь только одного родителя.
			С интерфейсами дело, однако, обстоит по другому: каждый класс может реализовывать любое количество интерфейсов, 
			для этого имена интерфейсов нужно перечислить через запятую после ключевого слова implements. 
			Класс может наследовать от другого класса и при этом реализовывать какой-то интерфейс.
		}

	Пример 1: [
			interface Figure
			{
				public function getSquare();
				public function getPerimeter();
			}

			class Quadrate implements Figure 
			{

			}
	]

	Пример 2: [			
			interface iFigure
			{
				public function getSquare();
				public function getPerimeter();
			}

			interface iRectangle extends iFigure
			{
				public function __construct($a, $b);
			}
	]	

	- Нельзя создать объект интерфейса. 
	- Все методы интерфейса должны быть объявлены как public и не должны иметь реализации. 
	- У интерфейса могут быть только методы и константы, но не свойства.
	- Нельзя также сделать интерфейс и класс с одним и тем же названием.
	- Общепринято в таком случае название интерфейса начать с маленькой буквы i.

	Функции для интерфейсво ООП:
	----------------------------
		interface_exists - проверяет, определён ли интерфейс interface_exists(string $interface, bool $autoload = true): bool
		get_declared_interfaces — Возвращает массив всех объявленных интерфейсов get_declared_interfaces(): array

----------------------------------------------------------------------------------------------------------------------------------
Трейты:
-------
trait
------ - "трейт" представляет собой набор свойств и методов, которые можно включить в другой класс. При этом свойства и методы трейта будут восприниматься классом будто свои.
	- Синтаксис трейта такой же как и у класса, за исключением того, что имя трейта нужно объявлять с помощью ключевого слова trait. 
	- Экземпляр трейта нельзя создать - трейты предназначены только для подключения к другим классам.
	- Само подключение осуществляется с помощью команды use, после которой через пробел указывается имя подключаемого трейта. Данная команда пишется в начале класса.
	- В классе можно использовать не один, а несколько трейтов, через запятую после ключевого слова use.
	- Трейты, подобно классам, также могут использовать другие трейты.
	Создание трейта:
	----------------
	trait Helper
	{
		private $name;
		private $age;
		
		public function getName()
		{
			return $this->name;
		}
		
		public function getAge()
		{
			return $this->age;
		}
	}

	class User
	{
		use Helper; // подключаем трейт
		
		public function __construct($name, $age)
		{
			$this->name = $name;
			$this->age = $age;
		}
	}

	ВАЖНО (конфликты и т.п.):
	------
		- Следует обратить ваше внимание на то, что использование трейтов - это не наследование. При наследовании приватные методы и свойства не наследуются.
			В использующем трейт классе будут доступны как публичные, так и приватные методы и свойства класса.
		- Если в классе и в трейте есть одноименный метод, то метод класса переопределит метод трейта.
		- Если же сам класс не имеет такого метода, но имеется конфликт имен методов трейта и методов РОДИТЕЛЬСКОГО класса, то методы трейта имеют приоритет
		- Внутри трейта можно использовать любой модификатор доступа для методов (то есть public, private или protected).
			При необходимости, однако, в самом классе можно этот модификатор поменять на другой. Для этого в теле use после ключевого слова as нужно указать новый модификатор.
			Пример: [
				Меняем метод на публичный:
				class Test
				{
					use TestTrait {
						TestTrait::method as public; // меняем метод на публичный
					}
				}
			]
		- В трейтах можно некоторые методы объявлять абстрактными. В этом случае класс, использующий этот трейт, обязан будет реализовать такой метод. 
			При этом абстрактные методы трейта не могут быть приватными.
			
	insteadof:
	----------
	Разрешение конфликтов trait, если одинаковые имена методов:
		insteadof (переводится вместо чего-то)
		синтаксис тут следующий: вначале имя трейта, потом два двоеточия, потом имя метода, потом наш оператор insteadof и имя второго трейта.
		Пример 1: 
		[
		class Test
		{
			use Trait1, Trait2 {
				Trait1::method insteadof Trait2;
				//или
				//можно добавить альяс и использовать второй метод под другим именем, можно и первый использовать под другим именем (необязательно)
				//	use Trait1, Trait2 {
				//		Trait1::method insteadof Trait2;
				//		Trait1::method as method1; (необязательно)
				//		Trait2::method as method2;
				//	}
			
			}
		}
		]
	
	Функции для трейтов ООП:
	------------------------
		trait_exists — Проверяет, существует ли трейт  trait_exists(string $trait, bool $autoload = true): bool
		get_declared_traits — Возвращает массив со всеми объявленными трейтами  get_declared_traits(): array
----------------------------------------------------------------------------------------------------------------------------------

Манические методы:
------------------
__ - магические методы начинаются с двух подчеркиваний

__toString - он вызывается при попытке приведения экземпляра класса к строке (всегда использовать return (string) {переменная};)
__get - вызывается при попытке прочитать значение приватного или защищенного свойства.
__set - вызывается при попытке изменить значение несуществующего или скрытого свойства. В качестве параметров он принимает имя свойства и значение, которое ему пытаются присвоить.
__invoke - вызывается, когда скрипт пытается выполнить объект как функцию. 

namespace:
---------
1) Пространство имён - чтобы задать классу пространство имен, нужно первой строчкой файла, в которомм хранится этот класс написать команду namespace, 
	а после нее через пробел - название этого пространства. 
	Пример:
			namespace Admin;
	
			class Page {}

2) Если класс относится к какому-нибудь пространству имен, то для создания объекта класса нужно будет указать не только имя класса, но и его пространство имен, 
	разделенные обратным слешем. Давайте посмотрим на примере.
	Пример:
		$page = new \Admin\Page;
3) Здесь следует уточнить, что уровень вложенности подпространств не ограничен (можно создавать под под пространства в подпространствах и так далее).
	Пример:
		namespace Admin\View;
	
		class Page {}

4) В примерах выше имена пространств имен совпадают с именами папок, в которых хранятся файлы. Делать так - хорошая практика, но обязательным это не является.

- При наследовании класса с общим пространством имём, после extends можно указать только "класс".
- Как вы уже знаете, при обращении к классу перед его пространством имен следует писать обратный слеш. На самом деле это не обязательно. 
	Если этот слеш не написать, то вызываемое пространство имен будет рассчитано относительно текущего пространства.
	Пример:
		namespace Admin\Data;	
		new Core\Controller; // эквивалентно \Admin\Data\Core\Controller

- use - С помощью этой команды достаточно один раз подключить класс по его полному имени, и после этого можно будет обращаться к этому классу просто по имени класса.
	Пример:
		namespace Users;
		use \Core\Admin\Data; // подключаем класс
	
		class Page extends Controller
		{
			public function __construct()
			{
				$data1 = new Data('1'); // вызываем просто по имени
				$data2 = new Data('2'); // вызываем просто по имени
			}
		}

- as - с помощью данной команды можно создать псевдоним namespace.
	Пример:
			namespace Project;
			use \Core\Users\Data as UsersData;
			use \Core\Admin\Data as AdminData;
	
			class Test
			{
				public function __construct()
				{
					$data1 = new UsersData;
					$data2 = new AdminData;
				}
			}

==================================================================================================================================
Автозагрузка классов:
---------------------
https://github.com/codedokode/pasta/blob/master/php/autoload.md
https://victor.4devs.io/ru/php/classes-autoload-php.html

spl_autoload_register([function($class)]); // включаем автозагрузку - эта функция будет вызываться, когда PHP будет обнаруживать обращение к незагруженному классу
	- без function($class) сработает автозагрузка spl_autoload(string $class, ?string $file_extensions = null): void
	- function($class) - необязательный параметр, своя функция автозагрузки. 
	Важно: эта функция будет вызываться, когда PHP будет обнаруживать обращение к незагруженному классу. В параметр этой функции будет попадать имя класса с пространством имен.
		$class - в переменной $class будет имя класса с пространством имен
		Пример:
				spl_autoload_register(function($class) {
					$root = $_SERVER['DOCUMENT_ROOT'];
					$ds = DIRECTORY_SEPARATOR;
		
					$filename = $root . $ds . str_replace('\\', $ds, $class) . '.php';
					require($filename);
				});

	- стандартное соглашение PHP - если у нас есть некоторый файл с классом, то путь по папкам сайта к этому файлу должен совпадать с пространством имен файла, 
		а имя файла должно совпадать с именем хранящегося в нем класса. При этом имена папок и файла должны быть в нижнем регистре. 
	- функция spl_autoload_register пишется только один раз в начале файла. Затем можно создавать столько объектов разных классов, сколько угодно, 
		главное, чтобы их имена следовали соглашениям;
	- функция spl_autoload_register пишется только в начале того файла, который вызывается через адресную строку браузера,
		т.е., если какой-то класс вызывает внутри себя другой класс или наследует от кого-то, а сам класс вызывается в другом файле, 
		то spl_autoload_register нужно написать только в этом другом файле - в самом файле класса дублировать эту функцию не надо.

==================================================================================================================================
Перегрузка:
-----------
https://php.ru/manual/language.oop5.overloading.html
Перегрузка в PHP означает возможность динамически "создавать" свойства и методы. 
	Эти динамические сущности обрабатываются с помощью "магических" методов, которые можно создать в классе для различных видов действий.
	Методы перегрузки вызываются при взаимодействии с теми свойствами или методами, которые не были объявлены или не видны в текущей области видимости.

	__set(), __get(), __isset(), __unset()

==================================================================================================================================
Остановка выполнения скрипта:
-----------------------------
exit({string $status = ?}); - string $status = ? необязательный параметр выведеться на экран, также exit без доп.параметра, можно писать без скобок.
или die();

@ - оператор подавления ошибки (если она возникнит) (можно поставить перед функцией или переменной)
----

Исключения (ошибки):
--------------------
https://ruseller.com/lessons.php?rub=37&id=1277
https://github.com/codedokode/pasta/blob/master/php/exceptions.md
https://www.php.net/manual/ru/language.exceptions.php

Исключение — это объект любого класса, который реализует встроенный в PHP интерфейс Throwable (реализует - значит, содержит описанные в интерфейсе методы). 
Предполагается, что для каждого типа ошибки создаются свои классы исключений, что позволяет потом их различать.

- Генерируемый объект должен принадлежать классу Exception или наследоваться от Exception.

throw - можно сгенерировать (выбросить) при помощи оператора.
	Начиная с PHP 8.0.0, ключевое слово throw является выражением и может использоваться в контексте других выражений. 
	В более ранних версиях оно являлось оператором и требовало размещения в отдельной строке. 
	throw new Exception("Ошибка в функции b()"); - после совпадения какого либо условия можно остановить выполнения скрипта (как будто было выполненно exit()) 
		и вывести на экран значение throw
		if (!file_exists($file)) {
			throw new Exception("Ошибка: файл $file не существует");
		}

try - код генерирующий исключение, должен быть окружён блоком try
	каждый блок try должен иметь как минимум один соответствующий ему блок catch или finally.
catch - можно перехватить (поймать) оператором. Блок catch определяет то, как следует реагировать на выброшенное исключение.
finaly - Блок finally также может быть указан после или вместо блоков catch. 
	Код в блоке finally всегда будет выполняться после блоков try и catch, независимо от того, 
	было ли выброшено исключение и до возобновления нормального выполнения.

Дополнения:
	1) Во фронт-контроллере ловятся либо ошибки БД, либо исключения, брошенные из контроллера. 
		Фронт-контроллер не должен напрямую ловить ошибки, брошенные в слое модели. 
		Как например мы бросали InvalidArgumentException, но обрабатывали его в контроллере и далее рисовали ошибку в шаблоне.
	2) Модель валидирует данные при своём создании. Если они некорректны, бросаем исключение уровня модели. 
		А если неавторизованный пользователь пытается обратиться к контроллеру, где авторизация является обязательной, это уже исключительная ситуация на уровне контроллера.

Названия для классов исключений:
	DbException - ошибки уровня базы данных
	InvalidArgumentException - ошибки переменных (невалидные, отсутсвуют и т.д.)
	UnauthorizedException - ошибка авторизации 401
	ForbiddenException - ошибка доступа 403
	NotFoundException - ошибка недоступности 404

==================================================================================================================================
Выдержки из теории ООП:
-----------------------
https://habr.com/ru/post/463125/

1. Композиция — случай, когда на фабрике трансформеров, собирая Оптимуса, обе пушки ему намертво приколачивают к рукам гвоздями, и после смерти Оптимуса, пушки умирают вместе с ним. 
Другими словами, жизненный цикл дочернего объекта совпадает с жизненным циклом родительского.

2. Агрегация (наследование) — случай, когда пушка выдается как пистолет в руку, и после смерти Оптимуса этот пистолет может подобрать его боевой товарищ Олег, 
а затем взять в свою руку, либо сдать в ломбард. То бишь жизненный цикл дочернего объекта не зависит от жизненного цикла родительского, и может использоваться другими объектами.

Как при описании отношений двух сущностей определить, когда уместно наследование, а когда — композиция? 
Можно воспользоваться популярной шпаргалкой: спросите себя, сущность А является сущностью Б? 
Если да, то скорее всего, тут подойдет наследование. Если же сущность А является частью сущности Б, то наш выбор — композиция.

    Автобот является Трансформером? Да, значит выбираем наследование.
    Пушка является частью Трансформера? Да, значит — композиция.

==================================================================================================================================
MVC (Model-View-Conctroller (модель-представление-контроллер)): всё начинается с того, что пользователь вбивает адрес в адресную строку (чаще всего перейдя по ссылке). 
---------------------------------------------------------------
	В этот момент Контроллер(Conctroller) разбирается, что именно хотел получить пользователь и просит Модель(Model) дать соответствующие данные. 
	Модель(Model) дает Контроллеру(Conctroller) данные. Контроллер(Conctroller) получает эти данные и отправляет их в Представление(View). 
	Представление(View) показывает данные в оформленном нужным образом виде. 

При этом модель отвечает за получение данных, 
Представление - за вывод этих данных на экран в нужном виде, 
Контроллер представляет собой связующее звено между моделью и представлением.

1. — клиент посылает HTTP-запрос серверу (метод, uri).
2. — приложение запускается, определяет метод и uri, вызывает контроллер
3.1 — получает данные (как правило один или несколько объектов/массивов) в соответствии с запросом из модели
3.2 — передаёт данные в вид для генерации HTML,…
4. — возвращает сгенерированный HTML (XML, JSON, GIF, whatever)
5. — приложение завершается.

В MVC методы контроллеров называются действиями.

Наиболее частые ошибки:
Начинающие программисты очень часто трактуют архитектурную модель MVC как пассивную модель MVC:
	модель выступает исключительно совокупностью функций для доступа к данным, а контроллер содержит бизнес-логику. 
	В результате — код моделей по факту является средством получения данных из СУБД, а контроллер — типичным модулем, наполненным бизнес-логикой. 
	В результате такого понимания — MVC-разработчики стали писать код, который Pádraic Brady (известный в кругах сообщества «Zend Framework») 
	охарактеризовал как «ТТУК» («Толстые, тупые, уродливые контроллеры»; Fat Stupid Ugly Controllers):

    Среднестатистический ТТУК получал данные из БД (используя уровень абстракции базы данных, делая вид, что это модель) или манипулировал, проверял, 
		записывал, а также передавал данные в Представление. Такой подход стал очень популярен потому, что использование таких контроллеров похоже на 
		классическую практику использования отдельного php-файла для каждой страницы приложения.

Но в объектно-ориентированном программировании используется активная модель[12] MVC, где модель — это не только совокупность кода доступа к данным и СУБД, 
	но и вся бизнес-логика; также модели могут инкапсулировать в себе другие модели. 
Контроллеры же, — как элементы информационной системы, — ответственны лишь за:
    приём запроса от пользователя;
    анализ запроса;
    выбор следующего действия системы, соответственно результатам анализа (например, передача запроса другим элементам системы).

Только в этом случае контроллер становится «тонким» и выполняет исключительно функцию связующего звена (glue layer) между отдельными компонентами информационной системы. 
==================================================================================================================================

Давайте повторим последовательность шагов, которые необходимо сделать для добавления новой странички:

    Добавляем экшн в контроллер (либо создаём ещё и новый контроллер);
    Добавляем для него роут в routes.php;
    Описываем логику внутри экшена и в конце вызываем у компонента view метод renderHtml();
    Создаём шаблон для вывода результата.
	
==================================================================================================================================
SOLID:
------
    1) Принцип единственной ответственности (Single responsibility) - «На каждый объект должна быть возложена одна единственная обязанность». 
																Т.е. другими словами — конкретный класс должен решать конкретную задачу — ни больше, ни меньше.
		Single Responsibility Principle (принцип единственной обязанности или принцип одной обязанности)
		------------------------------------------------------------------------------------------------
			Разбивание сложной задачи (например, задачу регистрации пользователей) на небольшие, независимые части: 
				- вывод формы регистрации
				- прием данных из формы
				- проверка информации
				- сохранение ее в базу данных
				- авторизация пользователя. 
			Каждой из этих подзадач соответствует отдельный метод или класс.
			Принцип единственной обязанности заключается в том, что каждый класс занимается только своим делом. 
			Например, один класс отвечает только за взаимодействие с БД, другой за проверку правильности введенных данных, 
			третий за выставление и проверку кук для авторизованных пользователей.

    2) Принцип открытости/закрытости (Open-closed) - «Программные сущности должны быть открыты для расширения, но закрыты для модификации».
    3) Принцип подстановки Барбары Лисков (Liskov substitution) - «Объекты в программе могут быть заменены их наследниками без изменения свойств программы». 
															Своими словами я бы это сказал так — при использовании наследника 
															класса результат выполнения кода должен быть предсказуем и не изменять свойств методов.
															Принцип подстановки Барбары Лисков, где наследование должно дополнять базовый класс, а не переопределять его.
    4) Принцип разделения интерфейса (Interface segregation) - «Много специализированных интерфейсов лучше, чем один универсальный». 
															Это поможет гибче их комбинировать в имплементирующих классах, не заставляя имплементировать лишние методы.
    5) Принцип инверсии зависимостей (Dependency Invertion) - «Зависимости внутри системы строятся на основе абстракций. 
															Модули верхнего уровня не зависят от модулей нижнего уровня. Абстракции не должны зависеть от деталей. 
															Детали должны зависеть от абстракций». 
															Данное определение можно сократить — «зависимости должны строится относительно абстракций, а не деталей».

Шпаргалка:
Резюмируя всё выше изложенное, хотелось бы сделать следующую шпаргалку

Принцип единственной ответственности (Single responsibility)
    «На каждый объект должна быть возложена одна единственная обязанность»
    Для этого проверяем, сколько у нас есть причин для изменения класса — если больше одной, то следует разбить данный класс.
Принцип открытости/закрытости (Open-closed)
    «Программные сущности должны быть открыты для расширения, но закрыты для модификации»
    Для этого представляем наш класс как «чёрный ящик» и смотрим, можем ли в таком случае изменить его поведение.
Принцип подстановки Барбары Лисков (Liskov substitution)
    «Объекты в программе могут быть заменены их наследниками без изменения свойств программы»
    Для этого проверяем, не усилили ли мы предусловия и не ослабили ли постусловия. Если это произошло — то принцип не соблюдается
	Моё: наследники не должны изменять функции родителя, но могут изменять значения этих функции и могут создовать дополнительные свои функции
Принцип разделения интерфейса (Interface segregation)
    «Много специализированных интерфейсов лучше, чем один универсальный»
    Проверяем, насколько много интерфейс содержит методов и насколько разные функции накладываются на эти методы, и если необходимо — разбиваем интерфейсы.
Принцип инверсии зависимостей (Dependency Invertion)
    «Зависимости должны строится относительно абстракций, а не деталей»
    Проверяем, зависят ли классы от каких-то других классов(непосредственно инстанцируют объекты других классов и т.д) и если эта зависимость имеет место, заменяем на зависимость от абстракции.


https://badcode.ru/5-printsipov-solid-obiasnieniie-na-paltsakh/
https://habr.com/ru/post/208442/
https://www.youtube.com/watch?v=YsAJ1tthkJM&list=PLoonZ8wII66jOXzIvQCtKosCstjGPL0lg&index=2
https://igor.quatrocode.com/2008/09/solid-top-5.html
https://blog.byndyu.ru/2009/10/solid.html

==================================================================================================================================
LazyLoad (ленивая загрузка) – это когда данные не подгружаются до тех пор, пока их не запросят.

==================================================================================================================================
ORM (англ. Object-Relational Mapping, рус. объектно-реляционное отображение, или преобразование) — технология программирования, 
	которая связывает базы данных с концепциями объектно-ориентированных языков программирования, создавая «виртуальную объектную базу данных». 
	Существуют как проприетарные, так и свободные реализации этой технологии.
	Пример:
		- таблицам будут соответствовать отдельные классы. Например, таблице articles будет соответствовать класс Article.
    	- в классах будут описаны свойства объектов. Каждое свойство будет соответствовать полю в таблице. 
        	Например, будет свойство ->authorId, оно будет соответствовать столбцу author_id в таблице articles.
    	- мы будем работать с объектами таких классов. Каждый такой объект соответствует одной записи в базе данных. 
        	То есть объект класса Article будет соответствовать одной строке в таблице articles.
	Одной из реализациий ORM является патерн ActiveRecord.

Active Record - 
	Википедия: это подход к доступу к данным в базе данных. Таблица базы данных или представление обёрнуты в классы. 
	Таким образом, объектный экземпляр привязан к единственной строке в таблице. После создания объекта новая строка будет добавляться к таблице на сохранение. 
	Любой загруженный объект получает свою информацию от базы данных. Когда объект обновлён, соответствующая строка в таблице также будет обновлена. 
	Класс обёртки реализует методы средства доступа или свойства для каждого столбца в таблице или представлении.

	PHP.z: Этот шаблон говорит о том, что сущность (объекты класса статьи или пользователя или др.) сами должны управлять работой с базой данных.
	То есть весь остальной код, который эти сущности использует, не должен знать о базе данных. Наши контроллеры не должны работать с базой данных, 
	получая данные и заполняя ими сущности. Они должны знать только о сущностях. Сущность сама должна позаботиться о работе с базой данных. 
	О том, как это реализовать – читайте далее.

	https://github.com/morsbox/rusrails/blob/master/source/active_record_basics.md

==================================================================================================================================
Singleton (синглтон) - этот паттерн относится к числу порождающих паттернов проектирования, то есть тех, с помощью которых в нашей программе создаются объекты.
    Этот паттерн говорит о том, что в рамках одного запущенного приложения будет гарантироваться что будет использован только один объект какого-то класса. 
    Классы, реализующие паттерн синглтон сами гарантируют, что будет использоваться только один их экземпляр – создать объекты можно только с помощью специального метода, 
    ведь конструктор больше недоступен извне. А этот метод следит за тем, чтобы не было более одного созданного объекта и предоставляет единую точку доступа к этому экземпляру.

==================================================================================================================================
Reflection (от англ. reflection - отражение (типа внутренне свойтсво человека)) в программировании - рефлексия означает процесс, во время которого программа может отслеживать и модифицировать 
	собственную структуру и поведение во время выполнения (влияние на поведение программы непосредственно во время её выполнения).
self, static, __DIR__, __CLASS__, get_defined_vars(), func_get_args() или eval()

__DIR__ - директория файла. Если используется внутри подключаемого файла, то возвращается директория этого файла. Это эквивалентно вызову dirname(__FILE__). 
	Возвращаемое имя директории не оканчивается на слеш, за исключением корневой директории.
__CLASS__ - имя класса. Это имя содержит название пространства имён, в котором класс был объявлен (например, Foo\Bar). 
	При использовании в методах трейтов __CLASS__ является именем класса, в котором эти методы используется.
get_defined_vars(): array - эта функция возвращает многомерный массив, содержащий список всех определённых переменных, будь то переменные окружения, 
	серверные переменные или переменные, определённые пользователем, в той области видимости, в которой была вызвана get_defined_vars().
func_get_args(): array - возвращает массив, в котором каждый элемент является копией соответствующего члена списка аргументов пользовательской функции.
eval(string $code): mixed — Выполняет код PHP, содержащейся в строке

PHP Reflection API
------------------ - это набор специальных классов-рефлекторов, позволяющих вывести рефлексию на новый уровень. 
	С помощью этих классов мы можем создавать объекты-рефлекторы для разных типов данных в PHP, которые позволят творить с ними всё что только вздумается.
https://www.php.net/manual/ru/book.reflection.php
https://myrusakov.ru/php-reflection-class-api.html

Объекты которые можно создать внутри которых есть различные фукнции для работы с рефлексией:
	ReflectionClass сообщает информацию о классе. 
	ReflectionClassConstant используется для получения информации о константах класса.
	ReflectionEnum сообщает информацию о перечислении.
	ReflectionEnumUnitCase сообщает информацию о варианте перечисления, который не имеет скалярного эквивалента.
	ReflectionEnumBackedCase сообщает информацию о варианте типизированного перечисления, у которого есть скалярный эквивалент.
	ReflectionExtension сообщает информацию о модулях. 
	ReflectionFunction сообщает информацию о функциях. 
	ReflectionMethod сообщает информацию о методах.
		->getProperties() - Получить все свойства
		->getMethods() - Получить все методы
		->getConstants() - Получить все константы
		->newInstance() - Создание нового объекта (даже с непубличным конструктором)
		->newInstanceWithoutConstructor() - Создание нового объекта без вызова конструктора
	ReflectionObject сообщает информацию об объектах (object). 
	ReflectionParameter сообщает информацию о параметрах методов и функций. 
	ReflectionProperty сообщает информацию о свойствах класса.
	ReflectionType сообщает информацию о типе параметра/возвращаемого значения функции или типе свойства класса.
	ReflectionGenerator сообщает информацию о генераторе. 
	ReflectionReference предоставляет информацию о ссылке. 
	ReflectionAttribute предоставляет информацию об Атрибутах.
