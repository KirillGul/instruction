https://developer.mozilla.org/ru/docs/Web

HTML
-----
Формат файла - "UTF-8"
<> - начало и конец тегов
"" - атрибуты тегов заключаются в двойные кавычки
<!-- чтобы не забыть --> - оформление комментариев
<link rel="stylesheet" href="style.css"> - подключение стилей

=================================================================================
Заметики:
---------
OPcache - на prodaction можно ускорить сайт (необходимо читать)

Профилирование проектов в PHP - профилирование это анализ потребления ресурсов при работе программы. 
        Этимология слова видимо связана с тем что профиль это некая граница, отсюда — поиск границ компонентов ПО в ресурсном пространстве. 
        В моём случае программа это исполняемые php-скрипты, а ресурсы это время, память и нагрузка на процессор. (необходимо читать)

PHP Storm - ссылка для скачивания тестовой версии https://www.jetbrains.com/phpstorm/nextversion/

Имена переменных и функций - в формате lowerCamelCase

$argc - Количество аргументов, переданных скрипту (в котором нулевой элемент – это путь до скрипта, а все последующие – это его аргументы)
$argv - Массив переданных скрипту аргументов (в котором нулевой элемент – это путь до скрипта, а все последующие – это его аргументы)
__DIR__ - "магическая" константа, в которой содержится путь до директории, в которой находится текущий скрипт (скрипт, в котором эта константа была использована).

Для счетчиков принято использовать буквы i, j и k.

=================================================================================
empty - функция проверки переменной на пустоту (переменная будет пустая, если она равна 0, '', '0', false или null (то есть не определена ранее).

isset - функция проверяет существует(определенна) ли переменная и присвоенно ли её какое либо значение (то есть то, что она не равна null).

=================================================================================
Приведение типов:
(тип_к_которому_нужно_привести) значение
(int)
(string)
(boolean)

Например:
$string = '123';
$numeric = (int) $string;

=================================================================================
Перечисления - новый тип данных в PHP 8
------------
Чистое перечисление:
        [
                enum Suit
                {
                case Hearts;
                case Diamonds;
                case Clubs;
                case Spades;
                }

                $val = Suit::Diamonds;
        ]

У всех обращений есть свойство, доступное только для чтения, name, которое является именем самого варианта, чувствительным к регистру.
        [
                print Suit::Spades->name;
                // prints "Spades"
        ]

Типизированное перечисление:
        [
                enum Suit: string
                {
                case Hearts = 'H';
                case Diamonds = 'D';
                case Clubs = 'C';
                case Spades = 'S';
                }
        ]

У типизированных вариантов есть дополнительное свойство, доступное только для чтения, value, которое является значением, указанным в определении.
        [
                print Suit::Clubs->value;
                // Выведет "C"
        ]

И чистые перечисления, и типизированные перечисления реализуют внутренний интерфейс с именем UnitEnum. UnitEnum включает статический метод cases(). 
cases() возвращает упакованный массив всех определённых вариантов в порядке объявления. 
        [
                Suit::cases();
                // Produces: [Suit::Hearts, Suit::Diamonds, Suit::Clubs, Suit::Spades]
        ]

=================================================================================
Оператор match:
---------------
Выражение match предназначено для ветвления потока исполнения на основании проверки совпадения значения с заданным условием. Аналогично оператору switch, 
выражение match принимает на вход выражение, которое сравнивается с множеством альтернатив. 
Но, в отличие от switch, оно обрабатывает значение в стиле, больше похожем на тернарный оператор. 
Также, в отличие от switch, используется строгое сравнение (===), а не слабое (==). Выражение match доступно начиная с PHP 8.0.0. 

$return_value = match (subject_expression) {
    single_conditional_expression => return_expression,
    conditional_expression1, conditional_expression2 => return_expression,
};

[
        $food = 'cake';
        $return_value = match ($food) {
                'apple' => 'На столе лежит яблоко',
                'banana' => 'На столе лежит банан',
                'cake' => 'На столе стоит торт',
        };
        var_dump($return_value);
]

=================================================================================
Тренарный оператор: условие ? результат_если_true : результат_если_false

null-coalesce оператор (PHP 7): 
        // Извлекаем значение $_GET['user'], а если оно не задано,
        // то возвращаем 'nobody'
        $username = $_GET['user'] ?? 'nobody';
        // Это идентично следующему коду:
        $username = isset($_GET['user']) ? $_GET['user'] : 'nobody';

        // Данный оператор можно использовать в цепочке.
        // В этом примере мы сперва проверяем, задан ли $_GET['user'], если нет,
        // то проверяем $_POST['user'], и если он тоже не задан, то присваеваем 'nobody'.
        $username = $_GET['user'] ?? $_POST['user'] ?? 'nobody';

Передача параметров по ссылке: function func(&$x)

=================================================================================
Тайп-хинтинг (type hinting) в PHP 7:
https://www.php.net/manual/ru/language.types.declarations.php

        function getSum(int $x, int $y)
        {
                return $x + $y;
        }

Обнуляемые типы: 
        Объявления типов могут быть помечены как обнуляемые, путём добавления префикса в виде знака вопроса(?). 
        Это означает, что значение может быть как объявленного типа, так и быть равным null.
                function f(?C $c) {
                        var_dump($c);
                }

Составные типы:
        Можно комбинировать простые типы в составные типы. PHP позволяет комбинировать типы следующими способами:
                - Объединение простых типов. Начиная с PHP 8.0.0. T1|T2|... или T1|T2|null
                        null не может использоваться как отдельный тип.
                        false нельзя использовать как самостоятельный тип (включая обнуляемый вариант). Таким образом, все объявления такого типа недопустимы: false, false|null и ?false.
                        Обратите внимание, что псевдотип true не существует.
                - Пересечение типов классов (интерфейсы и имена классов). Начиная с PHP 8.1.0.
                        Объявление пересечения типов принимает значения, которые удовлетворяют нескольким объявлениям типа класса, а не одному. 
                        Пересечения типов указываются с использованием синтаксиса T1&T2&...

Типы, подходящие только для возвращаемого значения:
        void - означает, что функция ничего не возвращает. Соответственно, он не может быть частью объединения. Доступно с PHP 7.1.0.
        never - тип возвращаемого значения, указывающий, что функция ничего не возвращает. 
                Это означает, что она либо вызывает exit(), либо выбрасывает исключение, либо представляет собой бесконечный цикл. 
                Следовательно, она не может быть частью объявления union-типа. Доступно с PHP 8.1.0.
        static - значение должно представлять собой instanceof того же класса, в котором был вызван метод. Доступно с PHP 8.0.0.

Строгая типизация PHP 8:
        Не будет срабатывать приведения типа и будет появляться ошибка.
        Можно включить режим строгой типизации на уровне файла.
        Нужно в начале файла указать (включить) строгую типизацию: declare(strict_types=1);
        
=================================================================================

$week = ['пн', 'вт', 'ср', 'чт', 'пт', 'сб', 'вс'];
$week = [1=>'пн', 'вт', 'ср', 'чт', 'пт', 'сб', 'вс'];
$weekEN = [1=>'mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun'];
$month = [1=>'янв', 'фев', 'мар', 'апр', 'май', 'июн', 'июл', 'авг', 'сен', 'окт', 'ноя', 'дек'];
$monthEN = [1=>'jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec'];

echo '<pre>';
var_dump($a);
echo '</pre>';

abs - функция abs вычисляет модуль числа (то есть из отрицательного делает положительное).
abs(число);

sqrt - функция sqrt находит квадратный корень числа.
sqrt(число);

pow - функция pow возводит число в заданную степень.
pow(число, степень);

round - функция round округляет число по правилам математического округления.
round(число, [сколько знаков оставить в дробной части]);

ceil - функция ceil округляет дробь в большую сторону до целого.
ceil(число);

floor - функция floor округляет дробь в меньшую сторону.
floor(число);

min - функция min находит самое маленькое число из переданных ей параметрами или самое маленькое число среди элементов массива.
min(первое число, второе число....);
min(массив чисел);

max - функция max находит самое большое число из переданных ей параметрами или самое большое число среди элементов массива.
max(первое число, второе число....);
max(массив чисел);

mt_rand - Функция mt_rand генерирует случайное целое число в заданном промежутке.
mt_rand(с какого числа, до какого числа);

Вам также может пригодиться функция mt_getrandmax, которая возвращает наибольшее возможное случайное значение числа.
        Пример: echo mt_rand(1, mt_getrandmax());

=================================================================================
strtolower - функция strtolower преобразовывает строку в нижний регистр.
strtolower(строка);
mb_strtolower (она работает аналогичным образом, но корректно обрабатывает кириллицу)

strtoupper - функция strtoupper преобразовывает строку в верхний регистр.
strtoupper(строка);
mb_strtoupper (она работает аналогичным образом, но корректно обрабатывает кириллицу)

ucfirst - функция ucfirst преобразует первый символ строки 
        в верхний регистр. Не работает с кириллицей.
ucfirst(строка);

lcfirst - функция lcfirst преобразует первый символ строки
        в нижний регистр. Не работает с кириллицей.
lcfirst(строка);

ucwords - функция ucwords преобразует первый символ каждого слова
        в строке в верхний регистр. Не работает с кириллицей.
ucwords(строка, разделитель слов);

strlen - функция strlen возвращает длину строки 
        (количество символов в строке).
        Данная функция неправильно работает с кириллицей. 
        Используйте функцию mb_strlen (она работает аналогичным образом, 
        но корректно обрабатывает кириллицу).
strlen(строка);
mb_strlen (она работает аналогичным образом, но корректно обрабатывает кириллицу)

substr - функция substr вырезает и возвращает подстроку из строки.
        Сама строка при этом не изменяется. 
        Нумерация символов строки начинается с нуля.
        Второй параметр может быть отрицательным - в этом случае отсчет 
        начнется с конца строки, при этом последний символ будет 
        иметь номер -1.
        Последний параметр можно не указывать - в этом случае отрезание 
        произойдет до конца строки.
        Данная функция неправильно работает с кириллицей. 
        Используйте функцию mb_substr (она работает аналогичным образом,
        но корректно обрабатывает кириллицу).
substr(строка, откуда, [сколько]);
mb_substr (она работает аналогичным образом, но корректно обрабатывает кириллицу)

str_replace -  функция str_replace ищет в строке заданный текст и 
            меняет его на другой.
            Первым параметром функции принимает что меняем, а вторым - 
            на что меняем. Это могут быть две строки или два массива.
            Во втором случае соответствующие элементы одного массива 
            заменятся на соответствующие элементы второго массива 
            (см. примеры).
            Есть также функция str_ireplace, которая делает тоже самое, 
            но без учета регистра.
str_replace(что меняем, на что меняем, где меняем);

strtr - функция strtr осуществляет поиск и замену символов в строке.
        Функция имеет два варианта работы.
        В первом варианте функция принимает массив замен:
        ключами служит то, что мы меняем, 
        а значениями - на что будем менять:
strtr(где меняем, массив замен);

        Во втором варианте функция одним параметром принимает строку 
        с символами, которые будут заменены, а другим параметром строку 
        с символами, на которые будет производится замена.
        Соответствующие символы первой строки будут заменены на 
        соответствующие символы второй строки:
strtr(где меняем, что меняем, на что меняем);

substr_replace - функция substr_replace заменяет указанную часть 
                строки на другую.
substr_replace(где меняем, на что меняем, с какого символа, [сколько символов]);

strpos - функция strpos возвращает позицию первого вхождения подстроки 
        в другую строку. Первым параметром функция принимает строку, 
        в которой осуществляется поиск, вторым параметром - подстроку, 
        которую следует искать. 
strpos(где ищем, что ищем, [откуда искать]);

strstr - функция strstr находит первое вхождение подстроки 
        в строку и возвращает часть строки начиная этого места 
        до конца строки. В отличие от strchr ищет вхождение подстроки 
        из нескольких символов, а не вхождение одного символа.
strstr(где ищем, что ищем);

explode - функция explode разбивает строку в массив по определенному разделителю.
explode(разделитель, строка);

implode - функция implode сливает массив в строку с указанным разделителем.
implode(разделитель, массив);

str_split - функция str_split разбивает строку в массив.
str_split(строка, количество символов в элементе массива);

trim - функция trim удаляет пробелы с начала и конца строки. 
        Может также удалять другие символы, если их указать вторым параметром.
trim(строка);
trim(строка, символы);

ltrim - функция ltrim удаляет пробелы с начала строки.
rtrim - функция rtrim удаляет пробелы с конца строки.

strrev - функция strrev переворачивает строку так, чтобы символы шли в обратном порядке.
strrev(строка);

str_shuffle - функция str_shuffle переставляет символы в строке в случайном порядке.
str_shuffle(cтрока);

number_format - функция number_format позволяет форматировать число.
        Функция принимает один, два или четыре параметра (не три).
number_format(число);
number_format(число, количество знаков дробной части);
number_format(число, количество знаков дробной части, разделитель дробной части, разделитель тысяч);

str_repeat - функция str_repeat повторяет строку заданное количество раз.
str_repeat(строка, сколько раз повторить);

htmlspecialchars - функция htmlspecialchars позволяет вывести теги в 
            браузер так, чтобы он не считал их командами, 
            а выводил как строки.
htmlspecialchars(строка);

strip_tags - функция strip_tags удаляет HTML теги из строки 
            (не трогая их содержимого). 
            Вторым необязательным параметром можно указать 
            разрешенные теги - они не будут удалены. 
            Их указываем в таком формате: '<b>' или '<b><p>', 
            если хотим оставить несколько тегов.
strip_tags(строка, [разрешенные теги]);

chr - функция chr находит символ по его ASCII коду.
chr(код символа);

ord - функция ord возвращает ASCII код символа. Параметром 
        принимает один символ или целую строку 
        (в этом случае возвращает код ее первого символа).

str_word_count - функция str_word_count подсчитывает количество слов в строке.
        Функция может принимать второй необязательный параметр, число 1 или 2.
        Если он не задан, то возвращается целое число, 
        равное количеству слов.
        Если передано 1, то возвращается массив, содержащий все слова, 
        входящие в строку.
        Если передано 2, то возвращается массив, ключами которого являются 
        позиции в строке, а значениями - соответствующие слова.
str_word_count(строка, [число]);

substr_count - функция substr_count подсчитывает 
        сколько раз встречается подстрока в строке.
substr_count(строка, подстрока);

count_chars -  функция count_chars подсчитывает сколько раз встречаются 
        различные символы в строке.
        Первым параметром функция принимает строку, а вторым 
        необязательным параметром - модификатор, который изменяет 
        работу функции:
        0 - массив, индексами которого являются ASCII коды, 
            а значениями - число вхождений соответствующего символа.
        1 - то же, что и для 0, но информация о символах с нулевым числом 
            вхождений не включается в массив.
        2 - то же, что и для 0, но в массив включается информация 
            только о символах с нулевым числом вхождений.
        3 - строка, состоящая из символов, которые входят в исходную 
            строку хотя бы раз.
        4 - строка, состоящая из символов, которые не входят в исходную 
            строку.
        По умолчанию функция ведет себя так, будто второй параметр 
        поставлен в 0.
count_chars(строка, [модификатор]);

strchr - функция strchr находит первое вхождение подстроки в строку 
        и возвращает часть строки начиная этого места до конца строки.
strchr(где ищем, что ищем);

strrchr - функция strrchr находит последнее вхождение символа в строку
        и возвращает часть строки начиная этого места до конца строки.
strrchr(где ищем, что ищем);

strstr -  функция strstr находит первое вхождение подстроки в строку 
        и возвращает часть строки начиная этого места до конца строки. 
        В отличие от strchr ищет вхождение подстроки из нескольких символов, 
        а не вхождение одного символа.
strstr(где ищем, что ищем);

Есть также функция stristr, которая делает тоже самое, но без учета регистра. 

=================================================================================
count - подсчитывает количество элементов массива;
count(массив);

extract - извлекает массив в переменные (именованный массив) (т.е. ['key1' => 1, 'key2' => 2] получаем $key1 = 1 и $key2 = 2);
extract(массив);

unset — Удаляет переменную

in_array - проверяет наличие заданного элемента в массиве;
in_array(что искать, в каком массиве);

array_sum - вычисляет сумму элементов массива;
array_sum(массив);

array_product - вычисляет произведение (умножение) элементов массива;
array_product(массив);

range - создает массив с диапазоном элементов;
range(откуда, докуда, [шаг]);

array_merge - сливает два и более массивов вместе;
array_merge(первый массив, второй массив...);

array_slice - отрезает и возвращает часть массива (не меняет массив);
array_slice(массив, откуда отрезать, [сколько], [сохранять ключи = false]);

array_splice - отрезает и возвращает часть массива (меняет массив);
array_splice(массив, откуда отрезать, [сколько], [вставить взамен]);

array_keys - получает ключи массива и записывает их в новый массив;
array_keys(массив);

array_values - выбирает все значения из массива;
array_values(массив);

array_combine - осуществляет слияние двух массивов в один ассоциативный;
array_combine(массив ключей, массив значений);

array_flip - производит обмен местами ключей и значений массива;
array_flip(массив);

array_reverse - переворачивает массив в обратном порядке;
array_reverse(массив, [сохранять ли ключи]);

array_search - осуществляет поиск значения в массиве и возвращает 
        ключ первого найденного элемента;
array_search(что ищем, где ищем, [сравнивать по типу = false]);

array_replace - заменяет значения первого массива значениями с 
        такими же ключами из других переданных массивов;
array_replace(массив, массив, массив...);

array_count_values - производит подсчет количества всех значений массива;
array_count_values(массив);

Сортировка массивов:
sort - по возрастанию элементов,
rsort - по убыванию элементов, 
asort - по возрастанию элементов с сохранением ключей,
arsort - по убыванию элементов с сохранением ключей,
ksort - по возрастанию ключей, 
krsort - по убыванию ключей, 
usort - по функции по элементам, 
uasort - по функции по элементам с сохранением ключей,
uksort - по функции по ключам,
natsort - натуральная сортировка.

array_rand - возвращает случайный ключ из массива;
array_rand(массив, [сколько ключей выбрать]);

shuffle - перемещать массив (случайно)

array_unique - осуществляет удаление повторяющихся элементов (дублей)
        из массива;
array_unique(массив);

array_shift - вырезает и возвращает первый элемент массива. 
        При этом этот элемент исчезает из массива;
array_shift(массив);

array_pop - вырезает и возвращает последний элемент массива.
        При этом этот элемент исчезает из массива.
array_pop(массив);

array_unshift - добавляет элементы в начало массива
array_unshift(массив, какие элементы добавить);

array_push - добавляет элементы в конец массива;
array_push(массив к которому добавить элементы, какие элементы добавить);

array_pad - дополняет массив определенным значением до заданного размера.
array_pad(массив, до какого размера заполнить, чем заполнять);

array_fill - создает массив, заполненный элементами 
        с определенным значением.
array_fill(ключ первого элемента, сколько элементов, чем заполнять);

array_fill_keys - создает массив и заполняет массив элементами 
        с определенным значением так, чтобы весь массив был 
        с одинаковыми элементами, но разными ключами. 
        Ключи берутся из массива, передаваемого первым параметром.
array_fill_keys(ключ первого элемента, сколько элементов, чем заполнять);

array_chunk - разбивает одномерный массив в двухмерный. 
        Первым параметром она принимает массив, 
        а вторым - количество элементов в каждом подмассиве.
array_chunk(массив, по сколько элементов);

array_map - применяет заданную функцию ко всем элементам массива
         и возвращает измененный массив;
array_map(имя функции в кавычках, массив, [еще массивы через запятую]);

array_intersect - вычисляет пересечение массивов - возвращает массив
         из элементов, которые есть во всех массивах, переданных в функцию.
array_intersect(массив, массив, массив...);

array_diff - возвращает массив из элементов, которые не являются
         общими для первого массива, переданных в функцию.
array_diff(массив, массив, массив...);

=================================================================================
Работа с временем:
------------------
https://www.internet-technologies.ru/articles/data-i-vremya-metod-oop.html
https://myrusakov.ru/php-datetime-classes-part-1.html

Функция time - возвращает разницу в секундах между 1-го января 1970 года 
        и текущим моментом времени. Такое представление даты называется 
        форматом timestamp.
        С помощью функции time мы можем получить только текущий момент времени

Функция mktime - время на определенное время. Параметры можно опускать с конца.
mktime(час, минута, секунда, месяц, день, год)

Функция date - выводит текущие дату и время в заданном формате. 
        Формат задается управляющими командами (английскими буквами), 
        при этом можно вставлять любые разделители между ними 
        (дефисы, двоеточие и так далее).

        date('d-m-Y', mktime(0, 0, 0, 12, 29, 13));
        имеет второй необязательный параметр, который принимает момент времени 
        в формате timestamp. Если передать этот параметр, то функция date отформатирует
        не текущий момент времени, а тот, который передан вторым параметром. 
        Этот timestamp можно получить, к примеру, через mktime (но не обязательно).
&& date('n', $time) == '13'
 Команды (заглавные буквы отличаются от обычных, обратите внимание!):
    U – количество секунд, прошедших с 1 января 1970 года (то есть timestamp).
    z – номер дня от начала года.
    Y – год, 4 цифры.
    y - год, две цифры.
    m – номер месяца (с нулем спереди).
    n – номер месяца без нуля впереди.
    d – номер дня в месяце, всегда две цифры (то есть первая может быть нулем).
    j – номер дня в месяце без предваряющего нуля.
    w – день недели (0 - воскресенье, 1 - понедельник и т.д.).
    h – часы в 12-часовом формате.
    H – часы в 24-часовом формате.
    i – минуты.
    s – секунды.
    L – 1, если високосный год, 0, если не високосный.
    W – порядковый номер недели года.
    t – количество дней в указанном месяце.

    Другие обозначения:
    https://www.php.net/manual/ru/datetime.format.php

Функция strtotime - это аналог функции mktime (тоже возвращает timestamp), 
        только в отличие от нее принимает дату в более свободном формате.
Можно передать ей строку '2025-12-31' и функция сама разберет, где тут год, 
        где месяц, а где день.
можно написать так - strtotime('now') - и мы получим текущий момент времени, 
        или так - strtotime('next Monday') - и мы получим следующий понедельник 
        (Monday по-английски 'понедельник').
и т.п.

Как добавить или отнять дату
Чтобы отнять или прибавить к дате определенный промежуток времени, 
следует пользоваться комбинацией из трех функций:

date_create - она подготавливает дату к работе (дата должна быть в формате 
        год-месяц-день) создавая так называемый объект дата, 
        с которым производятся дальнейшие манипуляции. date_create('2025-12-31')
date_modify - она прибавляет или отнимает. date_modify($date, '3 days');
date_format - она выводит получившуюся дату в заданном формате. date_format($date, 'd.m.Y')

Класс DateTime:
        https://myrusakov.ru/php-datetime-classes-part-1.html

=================================================================================
Регулярные функции в PHP:
-------------------------
preg_match - которая проверяет, есть ли в строке совпадение с регуляркой
                ищет только одно совпадение, функция выводит либо 1, либо 0.
        preg_match(регулярка, где искать[, карман array])
                При этом в нулевом элементе массива будет лежать найденная строка, 
                в первом элементе - первый карман, 
                во втором элементе - второй карман и так далее.

preg_match_all - ищет все совпадения
        preg_match_all(регулярка, где искать[, найденное, способ группировки карманов])
                третий параметр: туда можно записать переменную, к которую сложатся все найденные совпадения (в виде массива)
                четвертый параметр: PREG_PATTERN_ORDER -Если этот флаг установлен, результат будет упорядочен следующим образом: элемент $matches[0] 
                                                        содержит массив полных вхождений шаблона, элемент $matches[1] содержит массив вхождений первой подмаски, и так далее. 
                                или PREG_SET_ORDER - Если этот флаг установлен, результат будет упорядочен следующим образом: элемент $matches[0] 
                                                        содержит первый набор вхождений, элемент $matches[1] содержит второй набор вхождений, и так далее. 
                                или PREG_OFFSET_CAPTURE - В случае, если этот флаг указан, для каждой найденной подстроки будет указана ее позиция в исходной строке. 
                                                        Необходимо помнить, что этот флаг меняет формат возвращаемых данных: каждое вхождение возвращается в виде массива, 
                                                        в нулевом элементе которого содержится найденная подстрока, а в первом - смещение. Данный флаг доступен в PHP 4.3.0 и выше.

preg_replace - эта функция очень похожа на 
        str_replace – тоже осуществляет поиск и замену, 
        только первым параметром принимается не просто строка,
        а регулярное выражение

        preg_replace(что меняем, на что меняем, где меняем)
        echo preg_replace('#a#', '!', 'aabbaa'); //выведет '!!bb!!'

        # - модификатор
        i - заставит игнорировать регистр
                echo preg_replace('#A#i', '!', 'aAb'); //выведет '!!b'
        u - для корректной работы кириллицы в регулярке необходимо поставить модификатор u
                echo preg_replace('#[а-яё]#u', '!', 'Привет');

Являются спецсимволами: $ ^ . * + ? \ / {} [] () |
Не являются спецсимволами: @ : , ' " ; - _ = < > % # ~ ` & !

Операторы повторения:
        + - один или более раз
        * - ноль или более раз
        ? - ноль или один раз
? - вместе с операторами повторения ограничитель жадности

() - группирующие скобки, а также карман в регулярном выражении. Они работают так: если что-то стоит в группирующих скобках и сразу после ')' стоит оператор повторения - он подействует на все, что стоит внутри скобок.
(?: ) - они группируют, но не кладут в карман.
$ и номер кармана - для замены. Например, $0 - нулевой карман, $1 - первый карман, $2 - второй карман и так далее. 
\ и номер кармана (или \g1, или \g{1}) - для самой регулярки. Например, \0 - нулевой карман, \1 - первый карман, \2 - второй карман и так далее. 
(?<year> выражение) (или ?P<name>pattern) - именованный карман для поиска, и сохранения с именем
\g<letter> (или (?P=name), \g{name}, \g'name', \k<name>, \k'name', \k{name}) - именованный карман для самой регулярки
        Пример: preg_replace('#(?<letter>[a-z])\g<letter>#', '!', $str);

\ - экранирование спецсимволов
{} - возможность указать определенной число повторений
        пример: {2,5}) - повторяется от двух до пяти (оба включительно), {2,} - повторяется два и более раз.
^ - начало строки в регулярном выражении
$ - конец строки в регулярном выражении
| - команда или в регулярном выражении
\b - обозначает начало и конец слова
\B - обозначает не начало и не конец слова

?= - позитивный просмотр вперёд (говорит, что должно быть)
?! - негативный просмотр вперед (говорит, что чего-то должно не быть)
        Пример:
                В следующем примере замена произойдет, только если после 'aaa' не стоит 'x':
	        preg_replace('#aaa(?!x)#', '!', 'aaab'); // вернет '!b'
?<= - позитивный просмотр назад
        Пример:
                В следующем примере замена произойдет, только если перед 'aaa' стоит 'x':
	        preg_replace('#(?<=x)aaa#', '!', 'xaaa'); // вернет 'x!'
?<! - негативный просмотр назад
        Пример:
                В следующем примере замена произойдет, только если перед 'aaa' не стоит 'x': 
                preg_replace('#(?<!x)aaa#', '!', 'baaa'); // вернет 'b!'


Группы символов:
        \d - числа от 0 до 9
        \D - не число от 0 до 9
        \w - латинская буква или знак подчеркивания
        \W- не латинская буква или знак подчеркивания
        \s - пробел или пробельный символ (пробел, перевод строки, табуляция)
        \S - не пробел или пробельный символ (пробел, перевод строки, табуляция)

Наборы символов:
        [] - набор, в перечеслении обозначает "или"
        [^] - не в наборе
        Примеры наборов:
                Спецсимволы в квадратных скобках становятся обычными символами, кроме самих квадратных скобок, дефиса.
                a-d, A-D, 0-9, abc и др.

Модификаторы регулярок (можно использовать одновременно несколько модификаторов):
        u - для кириллических символов
                $str = 'яяя ййй ёёё';
	        $res = preg_replace('#[а-яё]#u', '!', $str);
        i - игнорирование регистра
        x - разрешает расставлять в регулярке произвольные пробелы и переводы строк
        U - делает так, что все операторы повторений станут по умолчанию нежадными, а добавление ?, наоборот, будет добавлять им жадности
        X - делает так, что экранировка обычного символа приведет к ошибке
        

=================================================================================
Сессии ($_SESSION):
-------------------
session_start() - инициализация сессии (до этой команды не должно быть никаких выводов на экран типа echo, var_dump, print_r).
        Кодировка вашего документа обязательно должна быть utf-8 без BOM.
        Сессия пользователя хранится на сервере.
        При этом она живет не вечно, а всего около получаса - 
        если пользователь за это время не выполнил никаких обращений к сайту, то его сессия удалится и станет пустой.
$_SESSION - глобальный массив сессии в котором она храниться на сервере и доступна
unset($_SESSION[переменная]) - удаление переменной сессии
session_destroy() - удалить все переменные сессии для данного пользователя

Предопределенные константы модуля сессии (и доступны всегда):
        SID (string)
                Константа, содержащая либо имя сессии и идентификатор в виде "name=ID" либо пустую строку, если идентификатор сессии был установлен в соответствующие 
                cookies сессии. Это тот же идентификатор, что возвращает функция session_id(). 
        PHP_SESSION_DISABLED (int)
                Возвращаемое значение функцией session_status() в случае, если сессии отключены. 
        PHP_SESSION_NONE (int)
                Возвращаемое значение функцией session_status() в случае, если сессии включены, но нет созданных сессий. 
        PHP_SESSION_ACTIVE (int)
                Возвращаемое значение функцией session_status() в случае существования сессий. 

Куки ($_COOKIE):
----------------
setcookie(имя_куки, значение_куки, [время_жизни_куки в 	timestamp]) - запись кук.
        При этом запись кук нужно делать до любого вывода на экран (подобно сессиям).
        Если не указан третиь параметр "время_жизни_куки", то такие куки долго не живут - только до закрытия браузера.
        Третий параметр принято записывать так: настоящий момент времени + N секунд.

Для того, чтобы установленная кука сразу появилась в массиве $_COOKIE можно использовать хитрый прием.
        setcookie('str', 'eee');
	$_COOKIE['str'] = 'eee';

В PHP нет встроенного механизма для удаления кук. Поэтому удаляют куки хитрым способом - устанавливая время 'смерти' куки на текущий момент:
        setcookie('test', '', time(), '/');


=================================================================================
Абсолютные и относительные пути в PHP:
--------------------------------------
- абсолютный путь начинатьеся с "/", файл будет искаться от корня операционной системы
        $_SERVER['DOCUMENT_ROOT'] - путь к корню сайта
        __DIR__ - константа к папке со скриптом
        __FILE__ - константа к файлу скрипта

- "../" - переход на уровень выше


Работа с файлами:
-----------------
//чтение файл в строку
file_get_contents('файл');

//создание файла и(или) внесение текста в файл
file_put_contents('файл', 'текст файла');

//переименование и перемещение файла или папки
rename('старое_имя', 'новое_имя');

//копирование файла
copy('старое_имя', 'новое_имя');

//удаление файла
unlink('файл');

//узнать размер файла в байтах
filesize('файл');

//проверка существования файла
file_exists('файл');

//константа переноса строки в каждой ОС разная (Windows-\r\n, Linux-\n, MacOS-\r)
PHP_EOL

//читает содержимое файла и помещает его в массив
file ( string $filename , int $flags = 0 , resource $context = ? ) : array

//проверяет, достигнут ли конец файла
feof(resource $stream): bool

//Читает строку из файла
fgets(resource $stream, ?int $length = null): string|false

//Бинарно-безопасная запись в файл в конец файла
fwrite(resource $stream, string $data, ?int $length = null): int|false
fputs(resource $stream, string $data, ?int $length = null): int|false

=================================================================================
Работа с папками:
-----------------
//создание папки
mkdir('название_папки');

//удаление папки (только если в папке нет файлов)
rmdir('название_папки');

//создать массив значений папки (не сканирует подпапки)
scandir('папка');

//проверка на файл
is_file('путь');

//проверка на папку
is_dir('путь');

//функция glob - поиск файла по шаблону, возвращает массив имён файлов
// * - несколько символов
// ? - один символ

glob('dir/*.txt'); или
glob('dir/?.txt');

=================================================================================
Include и require:
------------------
Функция require() идентична функции include(), за исключением того, что она обрабатывает ошибки по-другому. 
Если возникает ошибка, функция include() генерирует предупреждение (E_WARNING), но скрипт будет продолжать работу, 
а require() генерирует фатальную ошибку (E_COMPILE_ERROR), и работа скрипта будет завершена.

- Используйте require, когда файл требуется приложению.
- Используйте include, когда файл не требуется, и приложение должно продолжаться, когда файл не найден.

//вставка из другого файла
include 'файл';
include_once 'файл'; - тоже только однократная вставка в данный файл

//запись вставки (include - после загрузки страницы в любом месте) в переменную на PHP
function getFile($name) {
        ob_start();
	include $name; 
	return ob_get_clean(); 
}
$res = getFile('test.php');
echo 'index' . $res;

//подключение файла (в любом месте кода)
require 'файл';
require_once 'файл'; - тоже только однократное подключение файла

=================================================================================
Редиректы:
----------
header - помните, что функцию header() можно вызывать только если клиенту ещё не передавались данные. 
        То есть она должна идти первой в выводе, перед её вызовом не должно быть никаких HTML-тегов, пустых строк и т.п.
        header('Location: test.php');

        header(string $header, bool $replace = true, int $response_code = 0): void
        - $header - куда переадресовать
        - $replace - необязательный параметр replace определяет, надо ли заменять предыдущий аналогичный заголовок или заголовок того же типа. 
                По умолчанию заголовок будет заменён, но если передать false, можно задать несколько однотипных заголовков.
        - $response_code - принудительно задаёт код ответа HTTP. Следует учитывать, что это будет работать, только если строка header не является пустой.

md5 - хеширование паролей - считается устаревшей
        md5($string);

password_hash - получение "соленого" пароля (добавление к паролю еще символов).
        Первым параметром она принимает строку, а вторым - алгоритм шифрования (о нем позднее), и возвращает хеш этой строки вместе с солью.
        password_hash('12345', PASSWORD_DEFAULT);

password_verify - проверить, это хеш этого пароля или нет, 
        ледует использовать функцию password_verify - первым параметром она принимает пароль, а вторым - хеш, и возвращает true или false.
        password_verify($password, $hash);


=================================================================================
Буфер вывода:
------------
В тот момент, когда мы подключаем файл c HTML-кодом, либо пишем в PHP-коде echo, либо совершаем какой-либо другой вывод данных, 
эти данные начинают сразу передаваться в поток вывода. И если что-то пойдёт не так, мы не сможем вернуть этот вывод и вывести вместо него какую-нибудь ошибку. 
Но в PHP есть возможность весь этот поток вывода положить во временный буфер вывода.

ob_start(); //запускаем перехват вывода
include $this->templatesPath . '/' . $templateName; //что-то делаем с выводом
$buffer = ob_get_contents(); //записываем весь вывод в переменную $buffer
ob_end_clean(); //закрываем перехват вывода

echo $buffer; //выводит общий результать (можно проверить на ошибки и т.д.)

=================================================================================
Функции:
--------
https://metanit.com/php/tutorial/2.19.php - Обязательно к прочтению

void - это значить, что функция ничего не возвращает.
        - в реальности если функция ни чего не возвращает, она возваращет NULL
        - имена функции регистронезависимы, только для символов ASCII;
        - функция может принимать информацию в виде списка аргументов, который является списком разделённых запятыми выражений;
        - аргументы вычисляются слева направо перед фактическим вызовом функции (энергичное вычисление);
        - обязательные аргументы должны быть левее, необязательных аргументов;
        - PHP поддерживает передачу аргументов по значению (по умолчанию), передачу аргументов по ссылке, и значения по умолчанию;
                1) амперсанд (&) перед именем аргумента в описании функции, передаёт аргумент по ссылке и данный аргумент не нужно возваращать в return;
                2) ... - списки аргументов переменной длины (пример: function sum(...$numbers) {} echo sum(1, 2, 3, 4); - передаётся массив $numbers)
                        Многоточие (...) можно использовать при вызове функции, чтобы распаковать массив (array) 
                                или Traversable (Интерфейс, определяющий, является ли класс обходимым (traversable) с использованием foreach.) переменную в список аргументов: echo add(...$a);
                        Перед ... - можно добавить другие аргументы
                        Перед ... - можно указать тип переменных
                        Можно передавать аргументы по ссылке. Для этого перед ... нужно поставить амперсанд (&).      
        - В PHP 8.0.0 появились именнованные параметры myFunction(paramName: $value); (пример: array_fill(start_index: 0, count: 100, value: 50);)
                Именованные аргументы можно комбинировать с позиционными. В этом случае именованные аргументы должны следовать после позиционных аргументов (быть правее).
        
        Возврат значений:
                - происходит через return, если он не указан возвращается null.
                - функция не может возвращать несколько значений, но аналогичного результата можно добиться, возвращая массив.
                        // Деструктуризация массива будет собирать каждый элемент массива индивидуально
                        [$zero, $one, $two] = small_numbers();

                        // До версии 7.1.0 единственной эквивалентной альтернативой было использование конструкции list().
                        list($zero, $one, $two) = small_numbers();
                - для того, чтобы функция возвращала результат по ссылке, вам необходимо использовать оператор & и при описании функции, 
                        и при присвоении переменной возвращаемого значения (пример: function &returns_reference() { return $someref; } $newref =& returns_reference();)
                - функцию можно присвоить переменной и обращаться к ней через неё + круглые скобки (Closure).

Аннонимные функции (также известная как замыкание (пер.Closure) - это функция переданная в качестве аргумента и имя ей не нужно.
------------------
        Замыкание (англ. closure) — подпрограмма, сохраняющая контекст (привязку к переменным), т.е. функция первого класса, 
                в теле которой присутствуют ссылки на переменные, объявленные вне тела этой функции в окружающем коде и не являющиеся её параметрами. 
                Или по другому замыкание это — функция, которая ссылается на свободные переменные в своей области видимости.   

        Замыкания в PHP представляют анонимную функцию, которая может использовать переменные из своего локального окружения. 
        В отличие от обычных анонимных функций замыкания в PHP применяют выражение use. - https://metanit.com/php/tutorial/2.20.php    

        https://phpqa.ru/post/pogruzenie-v-closure-i-anonimnye-funkcii-v-php
        http://bologer.ru/php-anonimnye-funktsii-gde-i-kak-ispolzovat/
        http://www.codeharmony.ru/materials/197 - перечитать

        - use - делает видимой переменные из родительской области видимости

        Пример:
        //1) аннонимная функция с общей переменной 
                $string = 'Привет мир!';
                $func = function() use (&$string) {
                        echo $string;
                };
                $func();

        //2) аннонимная функция с переменной
                $namePrinter = function($name) {
                        echo sprintf("Куку %s\n", $name);
                };
                $namePrinter('Вася');
                $namePrinter('Петр');
                $namePrinter('Саша');

        //3) аннонимная функция как callback (тип callable)
        Функции обратного вызова (callback) – предусматривает передачу определенного исполняемого кода в качестве одного из параметров для другого кода.
        Функции обратного вызова, это - как правило обычные функции, которые напрямую ни когда не вызываются.
                $names = ['alex', 'petr'];
                print_r(array_map(function($name) {
                        return "Хай " . ucfirst( $name );
                }, $names));

        //4) аннонимная функция с Closure
                class Test {
                        public static function doSomething($num, $closure = null) {
                                if( !$closure instanceof \Closure ) {
                                        return $num;
                                }
                                //call_user_func — Вызывает callback-функцию, заданную в первом параметре
                                if( ($value = call_user_func($closure, $num)) && is_int($value) ) { //50
                                        return $value * $num; //500
                                }
                                return $num;
                        }  
                }

                $t = new Test();
                var_dump($t->doSomething(function($passedNum) {
                        return $passedNum * 5;
                }), 10);
        
        Встроенные в PHP функций, которые принимают в качестве аргумента замыкание:
                preg_replace_callback(),
                array_filter(),
                array_map(),
                array_reduce(),
                usort(),
                call_user_func(callable $callback, mixed ...$args): mixed,
                call_user_func_array(callable $callback, array $args): mixed

Callback-функции могут быть обозначены объявлением типа callable:
----------------
        Функции обратного вызова (callback) - распространенный случай применения анонимный функции, является передача данной функции параметром для другий функции.
        Функции обратного вызова, это - как правило обычные функции, которые напрямую ни когда не вызываются.
        Функции обратного вызова вовсе не обязаны быть анонимными. 
        В качестве такой функции можно смело использовать имя обычной функции или даже ссылку на метод какого-нибудь объекта.

        - Callback-функции могут быть как простыми функциями, так и методами объектов, включая статические методы классов;
        - в PHP функции передаются по имени в виде строки. Можно использовать любые встроенные, либо созданные пользователем функции, 
                за исключением конструкций языка, таких как: array(), echo, empty(), eval(), exit(), isset(), list(), print или unset();
        - метод созданного объекта (object) передаётся как массив, содержащий объект по индексу 0 и имя метода по индексу 1;
        - статические методы класса также могут быть вызваны без создания экземпляра объекта класса путём передачи имени класса вместо объекта 
                в элементе массива с индексом 0 или выполнения 'ClassName::methodName';
        - помимо обычных пользовательских функций, в качестве callback-функции можно передавать анонимные функции и стрелочные функции.
        Пример:
                function welcome($message)
                        {
                        $message();
                        }
                        $goodMorning = function() { echo "<h3>Доброе утро</h3>"; };
                        $goodEvening = function() { echo "<h3>Добрый вечер</h3>"; };
                        
                        welcome($goodMorning);          // Доброе утро
                        welcome($goodEvening);          // Добрый вечер
                        welcome(function(){ echo "<h3>Привет</h3>"; }); // Привет

                // Пример callback-функции
                function my_callback_function() {
                        echo 'Привет, мир!<br>';
                }

                // Тип 1: Простой callback
                call_user_func('my_callback_function');


                //Сложные callable-функции
                <?php
                class Foo
                {
                static function bar()
                {
                        echo "bar\n";
                }
                function baz()
                {
                        echo "baz\n";
                }
                }

                $func = array("Foo", "bar");
                $func(); // выведет "bar"
                $func = array(new Foo, "baz");
                $func(); // выведет "baz"
                $func = "Foo::bar";
                $func(); // выведет "bar"
                ?>

Стрелочные функции (появились в PHP 7.4, как более лаконичный синтаксис для анонимных функций):
------------------
        1) Основной вид записи стрелочных функций: fn (argument_list) => expr.
        2) Стрелочные функции поддерживают те же возможности, что и анонимные функции, за исключением того, что использование переменных из родительской 
                области всегда выполняется автоматически.
        3) Когда переменная, используемая в выражении, определена в родительской области, она будет неявно захвачена по значению.
        Пример:
                $y = 1;

                $fn1 = fn($x) => $x + $y;
                // эквивалентно использованию $y по значению:
                $fn2 = function ($x) use ($y) {
                        return $x + $y;
                };

                var_export($fn1(3)); //4
        4) Стрелочные функции захватывают переменные по значению автоматически, даже когда они вложены.
        Пример:
                $z = 1;
                $fn = fn($x) => fn($y) => $x * $y + $z;
                // Выведет 51
                var_export($fn(5)(10));

=================================================================================
Настройка стека:
Git
PHP
Composer
Openserver

1) Скачиваем и устанавливаем Git (https://git-scm.com/download/win) : git --version
	Откройте Git Bush и запустите две команды:
	git config --global user.name "Ваше_Имя"
	git config --global user.email Ваша_Электронная_Почта

2) Скачиваем  и устанавливаем PHP >= 7.4 (всегда в папку C:\php) (https://www.php.net/downloads) : php -v
	- после установки Visual C++ Redistributable скачиваем архив PHP 7 для Windows (VC14 Non Thread Safe x64 или x86 в зависимости от разрядности системы
	- переименовываем файл php.ini-production в php.ini;
	- раскоментируем (убираем знак ;) перед строчками:
    	extension=php_curl.dll;
    	extension=php_gd2.dll;
    	extension=php_mbstring.dll;
    	extension=php_openssl.dll;
    	extension=php_pdo_mysql.dll;
    	extension=php_pdo_sqlite.dll;
    	extension=php_sqlite3.dll.
3) Скачиваем и устанавливаем желательно"в ручную" Composer (в папку с:\php) (https://getcomposer.org/) : composer -V
	- переходим в папку cd c:\php
	- выполняем команды https://getcomposer.org/download/ файл можно также скачать вручную
	- выполняем команду для создания bat файла: echo @php "%~dp0composer.phar" %*>composer.bat

4) Скачиваем и устанавливаем Openserver
	- в папке "D:\ospanel\userdata\config" создаем файл path.txt и прописываем в нём путь до Git -> "C:\Program Files\Git\cmd"
	- в OSPanel создаем папку prog\default и скидываем туда ярлык IDE (для того чтобы у IDE была среда разработки как у Openserver)

Если в системе есть прокси сервер:
	- необходимо установить системную переменную: HTTP_PROXY:"прокси":"порт"
	или
	Установка прокси в консоли управления Openserver (если подключение через прокси):
		set http_proxy=http://10.91.3.2:3128/

5) Настройка Visual Studio Code:
        Тема: JetBrains Darcula Theme
        Тема значков: JetBrains Icon Theme

=================================================================================
Ошибки в PHP:
------------
"Notice: undefined variable" - Ошибка undefined variable появляется при попытке обратиться к не существующей (не объявленной ранее) переменной.
"Notice: undefined index" - появляется при попытке обращения к не существующему элементу массива.
"Use of undefined constant" - появляется при попытке обращения к не существующей константе.
"unexpected end of file" -  появляется при наличии синтаксических ошибок в коде.
"Maximum execution time" - появляется когда скрипт работает дольше, чем разрешено в настройках PHP.

Красивое отображение ошибок:
1) Xdebug (раскомментировать в php.ini):
zend_extension = xdebug
xdebug.mode = debug, develop

2) Whoops:
https://phpprofi.ru/blogs/post/77

=================================================================================
Front Controller (фронт контроллер) - единая точка входа для приложения, грубо говоря это index.php:

Структура папок для проекта:
----------------------------
public
        |- css
        |- js
        |- image
        |- index.php
                <?php declare(strict_types = 1);
                require __DIR__ . '/../src/Bootstrap.php'
src
        |- Bootstrap.php
                <?php declare(strict_types = 1);
                echo 'Hello World!';

Или:
----
        myproject.loc - корень проекта
        www (public_html) - корневая директория сайта в рамках веб-сервера
        src - тут все исходники для бэкенда, кроме фронт-контроллера, лежащего в www
        MyProject - домен проекта, тут непосредственно код проекта, без всей вспомогательной шелухи

////////////////////////////////////////////////////////////
Как я и предполагал, что где-то есть правило, которое подсвечивает символы, которые можно спутать с английскими по типу русской и английской "а"/"a".
Решение:
    CTRL+SHIFT+p
    В поиске пишем "ui".
    Переходим в настройки ui.
    В поиске настроек пишем "Unicode Highlight: Ambiguous Characters"
    Убираем галочку

=================================================================================
Bootstrap:
----------
https://bootstrap-5.ru/articles/cheatsheet5/ - шпаргалка
https://bootstrap-5.ru/docs/5.2/layout/gutters/ - документация

Контрольные точки: 
        xs (<576px)
        sm (≥576px)
        md (≥768px)
        lg (≥992px)
        xl (≥1200px)
        xxl (≥1400px)

Вертикальное выравнивание колонок в строке row:
        align-items-start
        align-items-center
        align-items-end

Горизонтальное выравнивание колонок в строке row:
        justify-content-start (лево)
        justify-content-center (центр)
        justify-content-end (право)
        justify-content-around (каждая колонка равномерно от краёв)
        justify-content-between (каждая колонка по краям)
        justify-content-evenly (каждая колонка равномерно от центра)

<!-- Заставит следующие колонки переходить на новую строку -->
    <div class="w-100"></div>

<!-- Заставит следующие колонки переходить на новую строку в контрольной точке md и выше -->
    <div class="w-100 d-none d-md-block"></div>

=================================================================================
JSON:
-----
https://www.json.org/json-ru.html
https://medium.com/@stasonmars/%D0%B2%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B2-json-c798d2723107
https://translated.turbopages.org/proxy_u/en-ru.ru.2b82977a-63e606e2-30a0e0e2-74722d776562/https/www.tutorialspoint.com/json/json_overview.htm


=================================================================================
PHPDBG:
------
https://www.php.net/manual/ru/intro.phpdbg.php

1) Перейти в папку с проектом
2) Выполнить phpdbg [-e - или другой папраметр см. документацию] название_файла.php
3) break название_функции
4) run
5) s(step) для прохода

=================================================================================
Сериализация и десиариализаци:
------------------------------
   В PHP: serialize unserialize
   Когда данные сериализуются, они обычно кодируются в бинарном или текстовом формате, чтобы их можно было сохранить или передать по сети. 
   При десериализации эти закодированные данные восстанавливаются в исходное состояние объектов и структур данных.

=================================================================================
cURL:
-----
   https://www.php.net/manual/ru/ref.curl.php
   https://habr.com/ru/articles/717346/
   cURL - это библиотека с открытым исходным кодом, используемая для отправки HTTP-запросов с различных языков программирования, включая C, PHP и другие.
        Это набор библиотек, в которых реализуются базовые возможности работы с URL страницами и передачи файлов. 
        Библиотека поддерживает работу с протоколами: FTP, FTPS, HTTP, HTTPS, TFTP, SCP, SFTP, Telnet, DICT, LDAP, а также POP3, IMAP и SMTP. 
        Она отлично подходит для имитации действий пользователя на страницах и других операций с URL адресами.

   Включение: модуль PHP cURL обычно включён по умолчанию. Если это не так, то в файле php.ini уберите точку с запятой (;) у строки extension=php_curl.dll

=================================================================================
PSR
        https://habr.com/ru/articles/458484/
        https://php-psr.ru
        https://www.php-fig.org

PSR-7:
------
   https://www.php-fig.org/psr/psr-7/
   https://habr.com/ru/articles/250343/
   https://logachev.pro/psr/psr-7/?ysclid=li4dt0s2b148721052
   https://www.pvsm.ru/php-2/82552?ysclid=li4l4b549290093605

   Данный стандарт моделирует HTTP сообщения, пересылаемые через протоколы (HTTP, HTTPS, FTP и др.)

Заголовки сообщений:
        PSR-7 упрощает доступ к заголовкам, предоставляя объектно-ориентированный слой над ними.
        getHeader('Заголовок'); - вывести заголовок, при отсутствии вернет NULL
        hasHeader('Заголовок'); - проверить существует ли заголовок
        getAllHeaders(); - вернет все заголовки в виде массива
        withHeader('Location', 'http://example.com'); - определение нового заголовка
        withAddedHeader('X-Foo', 'bar'); - добавление заголовка к существующему
        withoutHeader('X-Foo'); - удаление заголовка

Тело сообщения:
        withBody(new Stream('php://temp')); - создание тела сообщения

Ответы:
        getStatusCode(); - вывести статус код ответа
        getReasonPhrase(); - вывести пояснительную фразу
        withStatus(418, "Я чайник"); - создать новый объект с определенным статусом

Запросы:
        $method = $request->getMethod(); - вывести метод
        $uri    = $request->getUri(); - вывести URI

        // части URI:
        $scheme    = $uri->getScheme();
        $userInfo  = $uri->getUserInfo();
        $host      = $uri->getHost();
        $port      = $uri->getPort();
        $path      = $uri->getPath();
        $query     = $uri->getQuery();     // строка запроса
        $authority = $uri->getAuthority(); // [user-info@]host[:port]

        $uri = $uri
                ->withScheme('http')
                ->withHost('example.com')
                ->withPath('/foo/bar')
                ->withQuery('?baz=bat');

Серверные запросы:
        $query   = $request->getQueryParams();
        $body    = $request->getBodyParams();
        $cookies = $request->getCookieParams();
        $files   = $request->getFileParams();
        $server  = $request->getServerParams();

Атрибуты:
    getAttribute($name, $default = null) для получения определённого атрибута и возврата значения по умолчанию, если атрибут не найден.
    getAttributes() получение всех атрибутов.
    withAttribute($name, $value) для возврата нового экземпляра ServerRequestInterface, который содержит данный атрибут.
    withoutAttribute(($name) для возврата экземпляра ServerRequestInterface без указанного атрибута.

=================================================================================
PSR-15:
------
        
