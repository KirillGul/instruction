Yii (произносится как Йи [ji:]) в китайском языке означает «простой и эволюционирующий». Также Yii может расшифровываться как акроним Yes It Is!

Фреймворк
---------
    Находиться в папке vendor, нельзя изменять.

    Соглашение по умолчанию об именовании контролеров:
        Yii задает соответствие между ID контроллера и его классом согласно данному соглашению (таким образом, ID post будет соответствовать app\controllers\PostController)
        По-умолчанию namespace app\controllers. Если ID контроллера post, то согласно соглашению, соответствующий класс контроллера (без пространства имен) 
        будет равен PostController, а полное название класса будет равно app\controllers\PostController.

========================================================================================================================================================
Входной скрипт
--------------
    Для веб-приложение (ВП):         ./web/{index.php} (можте быть другое название в зависимости от настроек сервера)
    Для консольного приложения (КП): ./yii.php

    Запуск КП: ./yii <маршрут> [аргументы] [опции]

    Входные скрипты в основном делают следующую работу:
        1) Объявляют глобальные константы;
        2) Регистрируют загрузчик классов Composer;
        3) Подключают файл класса Yii;
        4) Загружают конфигурацию приложения;
        5) Создают и конфигурируют объект приложения;
        6) Вызывают метод yii\base\Application::run() приложения для обработки входящего запроса.


    В Yii заранее определены псевдонимы для часто используемых путей к файлам и URL:

        @yii: директория, в которой находится файл BaseYii.php (директория фреймворка).
        @app: базовый путь текущего приложения.
        @runtime: директория runtime текущего приложения.
        @vendor: директория vendor Composer.
        @webroot: вебрут текущего веб приложения (там где находится входной скрипт index.php).
        @web: базовый URL текущего приложения.

========================================================================================================================================================
Приложение
----------
    \Yii::$app - ссылка на приложение доступная глобально, т.к. подключение происходит во входном скрипте.
    Информация: 
        Yii::$app представляет собой глобально доступный экземпляр-одиночку приложения (singleton). 
        Одновременно это Service Locator, дающий доступ к компонентам вроде request, response, db и так далее.

        ================
        Service Locator:
            Service Locator - является объектом, предоставляющим всевозможные сервисы (или компоненты), которые могут понадобиться приложению. 

            В Service Locator каждый компонент представлен единственным экземпляром, имеющим уникальный ID. 
            Уникальный идентификатор (ID) может быть использован для получения компонента из Service Locator.
            В Yii Service Locator является экземпляром класса yii\di\ServiceLocator или его дочернего класса.

            yii\di\ServiceLocator::set() - регистрация в Service Locator
            yii\di\ServiceLocator::has() - проверка регистрации в Service Locator
            yii\di\ServiceLocator::get() - вызов компонента
        ================
        ================
        Dependency Injection Container (контейнер внедрения зависимостей):
            \Yii::$container - ссылка на контейнер DI
            Контейнер внедрения зависимостей — это объект, который знает, как создать и настроить экземпляр класса и зависимых от него объектов.

            Yii создаёт контейнер внедрения зависимостей когда вы подключаете файл Yii.php во входном скрипте вашего приложения. 
            При вызове Yii::createObject(), метод на самом деле вызовет метод контейнера get(), чтобы создать новый объект.
            Как упомянуто выше, контейнер внедрения зависимостей автоматически разрешит зависимости (если таковые имеются) и внедрит их получаемый объект.
            Поскольку Yii использует Yii::createObject() в большей части кода своего ядра для создания новых объектов, это означает, 
                что вы можете настроить глобальные объекты, имея дело с Yii::$container.

            Yii обеспечивает функционал контейнера внедрения зависимостей через класс yii\di\Container. Он поддерживает следующие виды внедрения зависимостей:
                Внедрение зависимости через конструктор;
                Внедрение зависимости через метод;
                Внедрение зависимости через сеттер и свойство;
                Внедрение зависимости через PHP callback;

            Регистрация зависимостей:
                yii\di\Container::set() - используется для регистрации зависимостей
                Зависимость, зарегистрированная через set() создаёт экземпляр каждый раз, когда зависимость необходима. 
                Вы можете использовать yii\di\Container::setSingleton() для регистрации зависимости, которая создаст только один экземпляр:
                При регистрации требуется имя зависимости, а также определение зависимости:
                    1) именем зависимости может быть имя класса, интерфейса или алиас
                    2) определением зависимости может быть имя класса, конфигурационным массивом, или PHP callback'ом.
            
                Когда следует регистрировать зависимости:
                    Поскольку зависимости необходимы тогда, когда создаются новые объекты, то их регистрация должна быть сделана как можно раньше. 
                    Ниже приведены рекомендуемые практики:
                        Если вы разработчик приложения, то вы можете зарегистрировать зависимости в конфигурации вашего приложения. 
                            Как это сделать описано в подразделе Конфигурация приложения раздела Конфигурации.
                        Если вы разработчик распространяемого расширения, то вы можете зарегистрировать зависимости в загрузочном классе расширения.
            
            Разрешение зависимостей:
                yii\di\Container::get() - используется для создания или получения объектов и разрещения зависимостей, метод принимает имя зависимости, которым может быть имя класса, 
                    имя интерфейса или псевдоним. Имя зависимости может быть зарегистрировано через set() или setSingleton(). 
                    Вы можете опционально предоставить список параметров конструктора класса и конфигурацию для настройки созданного объекта.
                После регистрации зависимостей, вы можете использовать контейнер внедрения зависимостей для создания новых объектов, 
                и контейнер автоматически разрешит зависимости их экземпляра и их внедрений во вновь создаваемых объектах. 
                Разрешение зависимостей рекурсивно, то есть если зависимость имеет другие зависимости, эти зависимости также будут автоматически разрешены.

            Yii реализует свой service locator поверх контейнера внедрения зависимостей. Когда service locator пытается создать новый экземпляр объекта, 
            он перенаправляет вызов на контейнер внедрения зависимостей. Последний будет разрешать зависимости автоматически, как описано выше.
        ================

    Существует два вида приложений: 
        веб приложения (занимается обработкой веб запросов)
        консольные приложения (занимается обработкой консольных команд)

!!!СВОЙСТВА!!!
    Свойства приложений (обязательные):
        1) id - это уникальный индекс приложения, который отличает его от других приложений. В основном это используется внутрисистемно. 
            Хоть это и не обязательно, но для лучшей совместимости рекомендуется использовать буквенно-цифровые символы при указании индекса приложения.
        2) basePath - указывает на корневую директорию приложения.
    
    Свойства приложений (важные):
        1) aliases - это свойство позволяет настроить вам множество псевдонимов в рамках массива. Ключами массива являются имена псевдонимов, 
            а значениями массива - соответствующие значения пути.
        2) bootstrap - данное свойство является очень удобным, оно позволяет указать массив компонентов, которые должны быть загружены в процессе начальной загрузки приложения.
            Например, если вы хотите, чтобы модуль производил тонкую настройку URL правил, вы можете указать его ID в качестве элемента данного свойства.
            Каждый из элементов данного свойства, может быть указан в одном из следующих форматов:
                ID, указанный в компонентах;
                ID модуля, указанный в модулях;
                название класса;
                массив конфигурации;
                анонимная функция, которая создаёт и возвращает компонент.
            В процессе начальной загрузки, каждый компонент будет создан. Если класс компонента имеет интерфейс yii\base\BootstrapInterface, 
            то также будет вызван метод bootstrap().
            Примечание: 
                Указывание слишком большого количества компонентов в bootstrap приведет к снижению производительности приложения, 
                потому что для каждого запроса одно и то же количество компонентов должно быть загружено. 
                Таким образом вы должны использовать начальную загрузку разумно.
        3) catchAll - данное свойство поддерживается только веб приложениями. Оно указывает действие контроллера, которое должно обрабатывать 
            все входящие запросы от пользователя. В основном это используется, когда приложения находится в режиме обслуживания и должно обрабатывать 
            все запросы через одно действие.
        4) components - данное свойство является наиболее важным. Оно позволяет вам зарегистрировать список именованных компонентов,
            называемых компоненты приложения, которые Вы можете использовать в других местах.
            Каждый компонент приложения указан массивом в формате ключ-значение. Ключ представляет собой ID компонента приложения, 
            в то время как значение представляет собой название класса или конфигурацию.
            Вы можете зарегистрировать любой компонент в приложении, позже этот компонент будет глобально доступен через выражение \Yii::$app->componentID.
        5) controllerMap - данное свойство позволяет вам задавать соответствия(mapping) между ID контроллера и произвольным классом контроллера. 
            По-умолчанию, Yii задает соответствие между ID контроллера и его классом согласно данному соглашению 
            (таким образом, ID post будет соответствовать app\controllers\PostController ). 
            Задавая эти свойства вы можете переопределить соответствия для необходимых контроллеров.
        6) controllerNamespace - данное свойство указывает пространство имен, в котором по умолчанию должны находится названия классов контроллеров. 
            По-умолчанию значение равно app\controllers. Если ID контроллера post, то согласно соглашению, соответствующий класс контроллера (без пространства имен) 
            будет равен PostController, а полное название класса будет равно app\controllers\PostController.
        7) language - данное свойство указывает язык приложения, на котором содержимое страницы должно быть отображено конечному пользователю. 
            По-умолчанию значение данного свойства равно en, что означает "Английский". 
            Если ваше приложение должно поддерживать несколько языков, вы должны настроить данное свойство.
        8) modules - данное свойство указывает модули, которые содержатся в приложении. - ????????????????????????????????????????
        9) name - свойство указывает название приложения, которое может быть показано конечным пользователям. 
            В отличие от свойства id, которое должно быть уникальным, значение данного свойства нужно в основном для отображения и не обязательно должно быть уникальным.
            Если ваш код не использует данное свойство, то вы можете не настраивать его.
        10) params - данное свойство указывает массив глобально доступных параметров приложения. 
            Вместо того, чтобы использовать жестко фиксированные числа и строки в вашем коде, лучше объявить их параметрами приложения в едином месте и 
            использовать в нужных вам местах кода.
        11) sourceLanguage - данное свойство указывает язык на котором написан код приложения. По-умолчанию значение равно 'en-US', что означает "Английский" (США). 
            Вы должны настроить данное свойство соответствующим образом, если содержимое в вашем коде является не английским языком.
        12) timeZone - данное свойство предоставляет альтернативный способ установки временной зоны в процессе работы приложения. 
            Путем указания данного свойства, вы по существу вызываете PHP функцию date_default_timezone_set().
        13) version - данное свойство указывает версию приложения. По-умолчанию значение равно '1.0'. 
            Вы можете не настраивать это свойство, если ваш код не использует его.
        
    Свойства приложений (полезные):
        1) charset - свойство указывает кодировку, которую использует приложение. По-умолчанию значение равно 'UTF-8' - должно быть оставлено как есть 
            для большинства приложения, только если вы не работаете с устаревшим кодом, который использует большее количество данных не юникода.
        2) defaultRoute - свойство указывает маршрут, который должно использовать приложение, когда он не указан во входящем запросе. 
            Маршрут может состоять из ID модуля, ID контроллера и/или ID действия. Например, help, post/create, admin/post/create. 
            Если действие не указано, то будет использовано значение по умолчанию указанное в yii\base\Controller::$defaultAction.
            Для веб приложений, значение по умолчанию для данного свойства равно 'site', что означает контроллер SiteController и его действие по умолчанию 
            должно быть использовано. Таким образом, если вы попытаетесь получить доступ к приложению не указав маршрут, 
            оно покажет вам результат действия app\controllers\SiteController::actionIndex().
            Для консольных приложений, значение по умолчанию равно 'help', означающее, что встроенная команда yii\console\controllers\HelpController::actionIndex() 
            должна быть использована. Таким образом, если вы выполните команду yii без аргументов, вам будет отображена справочная информация.
        3) extensions - данное свойство указывает список расширений, которые установлены и используются приложением. 
            По-умолчанию, значением данного свойства будет массив, полученный из файла @vendor/yiisoft/extensions.php. 
            Файл extensions.php генерируется и обрабатывается автоматически, когда вы используете Composer для установки расширений. 
            Таким образом, в большинстве случаев вам не нужно настраивать данное свойство.
        4) layout - данное свойство указывает имя шаблона по умолчанию, который должен быть использовать при формировании представлений. 
            Значение по умолчанию равно 'main', означающее, что должен быть использован шаблон main.php в папке шаблонов. 
            Если оба свойства папка шаблонов и папка представлений имеют значение по умолчанию, 
            то файл шаблона по умолчанию может быть представлен псевдонимом пути как @app/views/layouts/main.php.
            Для отключения использования шаблона, вы можете указать данное свойство как false, хотя это используется очень редко.
        5) layoutPath - свойство указывает путь, по которому следует искать шаблоны. Значение по умолчанию равно layouts, означающее подпапку в папке представлений. 
            Если значение папки представлений является значением по умолчанию, то папка шаблонов по умолчанию может быть представлена псевдонимом пути как @app/views/layouts.
            Вы можете настроить данное свойство как папку так и как псевдоним.
        6) runtimePath - свойство указывает путь, по которому хранятся временные файлы, такие как: лог файлы, кэш файлы. 
            По-умолчанию значение равно папке, которая представлена псевдонимом пути @app/runtime.
            Для упрощения работы с данной папкой, Yii предоставляет предопределенный псевдоним пути @runtime.
        7) viewPath - данное свойство указывает базовую папку,где содержаться все файлы представлений. 
            Значение по умолчанию представляет собой псевдоним @app/views. Вы можете настроить данное свойство как папку так и как псевдоним.
        8) vendorPath - свойство указывает папку сторонних библиотек, которые используются и управляются Composer. 
            Она содержит все сторонние библиотеки используемые приложением, включая Yii фреймворк. Значение по умолчанию представляет собой псевдоним @app/vendor.
            Вы можете настроить данное свойство как папку так и как псевдоним. 
            При изменении данного свойства, убедитесь что вы также изменили соответствующим образом настройки Composer.
            Для упрощения работы с данной папкой, Yii предоставляет предопределенный псевдоним пути @vendor.
        9) enableCoreCommands - данное свойство поддерживается только консольными приложениями. 
            Оно указывает нужно ли использовать встроенные в Yii консольные команды. Значение по умолчанию равно true.

*************************************************************************
*************************************************************************
*************************************************************************

!!!СОБЫТИЯ ПРИЛОЖЕНИЯ!!!
    В течение жизненного цикла приложения, возникает несколько событий. 
    Вы можете назначать обработчики событий в конфигурации приложения следующим образом в конфигурациях:
        [
            'on beforeRequest' => function ($event) {
                // ...
            },
        ]
    
    EVENT_BEFORE_REQUEST - данное событие возникает до того, как приложение начинает обрабатывать входящий запрос. 
        Настоящее имя события - beforeRequest.
    EVENT_AFTER_REQUEST - данное событие возникает после того, как приложение заканчивает обработку запроса, но до того как произойдет отправка ответа. 
        Настоящее имя события - afterRequest.
    EVENT_BEFORE_ACTION - событие возникает до того, как будет выполнено действие контроллера. 
        Настоящее имя события - beforeAction.
    EVENT_AFTER_ACTION - событие возникает после выполнения действия контроллера. 
        Настоящее имя события - afterAction.

!!!ВАЖНО!!!
    Жизненный цикл приложения (когда входной скрипт выполняется для обработки запроса, приложение будет развиваться согласно следующему жизненному циклу):
        1) Входной скрипт загружает конфигурацию приложения в качестве массива;
        2) Входной скрипт создаёт новый объект приложения:
            Вызывается метод preInit(), который настраивает некоторые жизненно важные свойства приложения, такие как basePath;
            Регистрируется обработчик ошибок;
            Настраиваются свойства приложения;
            Вызывается метод init(), который затем вызывает метод bootstrap() для начальной загрузки компонентов.
        3) Входной скрипт вызывает метод yii\base\Application::run() для запуска приложения:
            Возникает событие EVENT_BEFORE_REQUEST;
            Обработка запроса: 
                разбор информации запроса в маршрут с соответствующими параметрами; 
                создание объектов модуля, контроллера и действия согласно указанному маршруту; 
                запуск действия;
            Возникает событие EVENT_AFTER_REQUEST;
            Ответ отсылается конечному пользователю.
        4) Входной скрипт получает значение статуса выхода от приложения и заканчивает обработку запроса.


    Компоненты приложения
    ---------------------
        Каждый компонент приложения имеет свой уникальный ID, который позволяет идентифицировать его среди других различных компонентов в одном и том же приложении. 
        Вы можете получить доступ к компоненту следующим образом:
            \Yii::$app->componentID

            Например:
                \Yii::$app->db для получения соединения с БД, или
                \Yii::$app->cache для получения доступа к основному компоненту кэша, зарегистрированному в приложении.

        Компонентами приложения могут быть любые объекты. 
        Вы можете зарегистрировать их с помощью свойства yii\base\Application::$components в конфигурации приложения:
             // регистрация "cache" компонента с помощью имени класса
             // регистрация "db" компонента с помощью массива конфигурации
             // регистрация "search" компонента с помощью анонимной функции

        Компонент приложения будет создан только при первом обращении к нему. 
            Однако может возникнуть необходимость в наличии созданного компонента при каждом запросе, даже если напрямую к нему ни разу не обращались. 
            Для этого необходимо указать ID компонента в качестве элемента свойства bootstrap.

        Встроенные компоненты приложения:            
            - assetManager: используется для управления и опубликования ресурсов приложения. Более детальная информация представлена в разделе Ресурсы;
            - db: представляет собой соединение с базой данных, через которое вы можете выполнять запросы. 
                Обратите внимание, что когда вы конфигурируете данный компонент, вы должны указать класс компонента также как и остальные необходимые параметры, 
                такие как yii\db\Connection::$dsn. Более детальная информация представлена в разделе Объекты доступа к данным (DAO);
            - errorHandler: осуществляет обработку PHP ошибок и исключений. Более детальная информация представлена в разделе Обработка ошибок;
            - formatter: форматирует данные для отображения их конечному пользователю. 
                Например, число может быть отображено с различными разделителями, дата может быть отображена в формате long. 
                Более детальная информация представлена в разделе Форматирование данных;
            - i18n: используется для перевода сообщений и форматирования. Более детальная информация представлена в разделе Интернационализация;
            - log: обработка и маршрутизация логов. Более детальная информация представлена в разделе Логирование;
            - yii\swiftmailer\Mailer: предоставляет возможности для составления и рассылки писем. Более детальная информация представлена в разделе Отправка почты;
            - response: представляет собой данные от сервера, которые будет направлены пользователю. Более детальная информация представлена в разделе Ответы;
            - request: представляет собой запрос, полученный от конечных пользователей. Более детальная информация представлена в разделе Запросы;
            - session: информация о сессии. Данный компонент доступен только в веб приложениях. Более детальная информация представлена в разделе Сессии и куки;
            - urlManager: используется для разбора и создания URL. Более детальная информация представлена в разделе Разбор и генерация URL;
            - user: представляет собой информацию аутентифицированного пользователя. Данный компонент доступен только в веб приложениях. Более детальная информация представлена в разделе Аутентификация;
            - view: используется для отображения представлений. Более детальная информация представлена в разделе Представления.

    Компоненты — это главные строительные блоки приложений основанных на Yii.
        Наследование от класса:
            yii\base\BaseObject или его наследников - доступны только свойства
            yii\base\Component или его наследников - доступны только свойства, события, поведения

        При наследовании ваших классов от yii\base\Component или yii\base\BaseObject, рекомендуется следовать некоторым соглашениям:
            Если вы переопределяете конструктор, то добавьте последним аргументом параметр $config и затем передайте его в конструктор предка.
            Всегда вызывайте конструктор предка в конце вашего переопределенного конструктора.
            Если вы переопределяете метод yii\base\BaseObject::init(), убедитесь, что вы вызываете родительскую реализацию этого метода в начале вашего метода init().
        
        Жизненный цикл объектов класса yii\base\BaseObject содержит следующие этапы:
            1) Предварительная инициализация в конструкторе. Здесь вы можете установить значения свойств по умолчанию.
            2) Конфигурация объекта с помощью $config. Во время конфигурации могут быть перезаписаны значения свойств по умолчанию, установленные в конструкторе.
            3) Конфигурация после инициализации в методе init(). Вы можете переопределить этот метод, для проверки готовности объекта и нормализации свойств.
            4) Вызов методов объекта.

        Свойства компонентов:
            При определении свойств класса при помощи геттеров и сеттеров нужно помнить о некоторых правилах и ограничениях:
                - Имена таких свойств регистронезависимы. Таким образом, $object->label и $object->Label — одно и то же. 
                    Это обусловлено тем, что имена методов в PHP регистронезависимы.
                - Если имя такого свойства уже используется переменной-членом класса, то последнее будет иметь более высокий приоритет. 
                    Например, если в классе Foo объявлено свойство label, то при вызове $object->label = 'abc' будет напрямую изменено значение свойства label. 
                    А метод setLabel() не будет вызван.
                - Свойства, объявленные таким образом, не поддерживают модификаторы видимости. 
                    Это значит, что объявление геттера или сеттера как public, protected или private никак не скажется на области видимости свойства.
                - Свойства могут быть объявлены только с помощью не статичных геттеров и/или сеттеров. Статичные методы не будут обрабатываться подобным образом.
                - Обычный вызов property_exists() не работает для магических свойств. Для них необходимо использовать canGetProperty() или canSetProperty().

        События компонентов:
            События - это механизм, внедряющий элементы собственного кода в существующий код в определенные моменты его исполнения.
            К событию можно присоединить собственный код, который будет выполняться автоматически при срабатывании события.
            Если класс должен инициировать события, его нужно унаследовать от yii\base\Component или потомка этого класса.

            Обработчики событий:
                Обработчик события - это callback-функция PHP, которая выполняется при срабатывании события, к которому она присоединена.
                Можно использовать следующие callback-функции:
                    - глобальную функцию PHP, указав строку с именем функции (без скобок), например, 'trim';
                    - метод объекта, указав массив, содержащий строки с именами объекта и метода (без скобок), например, [$object, 'methodName'];
                    - статический метод класса, указав массив, содержащий строки с именами класса и метода (без скобок), например, ['ClassName', 'methodName'];
                    - анонимную функцию, например, function ($event) { ... }.
                
                Сигнатура обработчика события выглядит следующим образом:
                    Через параметр $event обработчик события может получить следующую информацию о возникшем событии:
                        event name: имя события
                        event sender: объект, метод trigger() которого был вызван
                        custom data: данные, которые были предоставлены во время присоединения обработчика события (будет описано ниже)

                    function ($event) {
                        // $event - это объект класса yii\base\Event или его потомка
                    }

                Присоединение обработчиков событий:
                    Обработчики события присоединяются с помощью метода yii\base\Component::on()
                    Например:
                        $foo = new Foo;

                        // обработчик - глобальная функция
                        $foo->on(Foo::EVENT_HELLO, 'function_name');

                        // обработчик - метод объекта
                        $foo->on(Foo::EVENT_HELLO, [$object, 'methodName']);

                        // обработчик - статический метод класса
                        $foo->on(Foo::EVENT_HELLO, ['app\components\Bar', 'methodName']);

                        // обработчик - анонимная функция
                        $foo->on(Foo::EVENT_HELLO, function ($event) {
                            // логика обработки события
                        });
                    Также обработчики событий можно присоединять с помощью конфигураций.
                    Присоединяя обработчик события, можно передать дополнительные данные с помощью третьего параметра метода yii\base\Component::on(). 
                    Эти данные будут доступны в обработчике, когда сработает событие и он будет вызван. 
                    Например:
                        // Следующий код выводит "abc" при срабатывании события
                        // так как в $event->data содержатся данные, которые переданы в качестве третьего аргумента метода "on"
                        $foo->on(Foo::EVENT_HELLO, 'function_name', 'abc');

                        function function_name($event) {
                            echo $event->data;
                        }

                Порядок обработки событий:
                    К одному событию можно присоединить несколько обработчиков. При срабатывании события обработчики будут вызываться в том порядке, 
                    в котором они присоединялись к событию. Чтобы запретить в обработчике вызов всех следующих за ним обработчиков, 
                    необходимо установить свойство yii\base\Event::$handled параметра $event в true:
                        $foo->on(Foo::EVENT_HELLO, function ($event) {
                            $event->handled = true;
                        });

                    По умолчанию, новые обработчики присоединяются к концу очереди обработчиков, уже существующей у события. 
                    В результате при срабатывании события обработчик выполнится последним. 
                    Чтобы обработчик присоединился к началу очереди и запускался первым, при вызове yii\base\Component::on() 
                    в качестве четвертого параметра $append следует передать false:
                        $foo->on(Foo::EVENT_HELLO, function ($event) {
                            // ...
                        }, $data, false);

                Инициирование событий:
                    События инициируются при вызове метода yii\base\Component::trigger(). 
                    Методу нужно передать имя события, а при необходимости - объект события, в котором описываются параметры, передаваемые обработчикам событий.

                    Подсказка: 
                        Желательно для обозначения имен событий использовать константы класса. В предыдущем примере константа EVENT_HELLO обозначает событие hello. 
                        У такого подхода три преимущества. Во-первых, исключаются опечатки. Во-вторых, для событий работает автозавершение в различных средах разработки. 
                        В-третьих, чтобы узнать, какие события поддерживаются классом, достаточно проверить константы, объявленные в нем.

                Отсоединение обработчиков событий:
                    Для отсоединения обработчика от события используется метод yii\base\Component::off().
                    Например:
                        // обработчик - глобальная функция
                        $foo->off(Foo::EVENT_HELLO, 'function_name');

                        // обработчик - метод объекта
                        $foo->off(Foo::EVENT_HELLO, [$object, 'methodName']);

                        // обработчик - статический метод класса
                        $foo->off(Foo::EVENT_HELLO, ['app\components\Bar', 'methodName']);

                        // обработчик - анонимная функция
                        $foo->off(Foo::EVENT_HELLO, $anonymousFunction);

                    Чтобы отсоединить ВСЕ обработчики от события, достаточно вызвать yii\base\Component::off() без второго параметра:
                        $foo->off(Foo::EVENT_HELLO);

                Обработчики событий на уровне класса:
                    События, которые инициируются любым экземпляром класса, а не только конкретным экземпляром,
                    достаточно присоединить обработчик на уровне класса, вызвав статический метод yii\base\Event::on().
                    https://www.yiiframework.com/doc/guide/2.0/ru/concept-events
                
                Обработчики событий на уровне интерфейсов:
                    https://www.yiiframework.com/doc/guide/2.0/ru/concept-events

                Глобальные события:
                    Yii поддерживает так называемые глобальные события, которые на самом деле основаны на нестандартном использовании описанного выше механизма событий. 
                    Для глобальных событий нужен глобально доступный объект-синглтон, например, экземпляр приложения - application.
                    Чтобы создать глобальное событие, отправитель сообщения вызывает метод trigger() синглтона, а не свой собственный метод trigger(). 
                    Аналогичным образом обработчики события также присоединяются к событиям синглтона.
                    Например:
                        use Yii;
                        use yii\base\Event;
                        use app\components\Foo;

                        Yii::$app->on('bar', function ($event) {
                            echo get_class($event->sender);  // выводит "app\components\Foo"
                        });

                        Yii::$app->trigger('bar', new Event(['sender' => new Foo]));

            Поведения:
                Поведения (behaviors) — это экземпляры класса yii\base\Behavior или класса, унаследованного от него. 
                Поведения, также известные как примеси, позволяют расширять функциональность существующих компонентов без необходимости изменения дерева наследования. 
                После прикрепления поведения к компоненту, его методы и свойства "внедряются" в компонент, и становятся доступными так же, как если бы они были объявлены 
                в самом классе компонента. 
                Кроме того, поведение может реагировать на события, создаваемые компонентом, что позволяет тонко настраивать или модифицировать обычное выполнение кода компонента.

                Создание поведений:
                    Поведения создаются путем расширения базового класса yii\base\Behavior или его наследников.
                    Подсказка: 
                        Внутри поведения возможно обращаться к компоненту, к которому оно прикреплено, используя свойство yii\base\Behavior::$owner.
                    Примечание: 
                        При переопределении метода поведения yii\base\Behavior::__get() и/или yii\base\Behavior::__set() необходимо также 
                        переопределить yii\base\Behavior::canGetProperty() и/или yii\base\Behavior::canSetProperty().

                Обработка событий компонента:
                    Если поведению требуется реагировать на события компонента, к которому оно прикреплено, то необходимо переопределить метод yii\base\Behavior::events().
                    Метод events() должен возвращать список событий и соответствующих им обработчиков.
                    Указать обработчик события, можно одним из следующих способов:
                        - строка с именем метода текущего поведения, как в примере выше;
                        - массив, содержащий объект или имя класса, и имя метода, например, [$object, 'methodName'];
                        - анонимная функция.
                
                Прикрепление поведений:
                    Прикрепить поведение к компоненту можно как статически, так и динамически.
                    
                    Статическое прикрепление - необходимо переопределить метод behaviors() компонента, к которому его планируется прикрепить. 
                        Метод behaviors() должен возвращать список конфигураций поведений. 
                        Конфигурация поведения представляет собой имя класса поведения, либо массив его настроек.
                        https://www.yiiframework.com/doc/guide/2.0/ru/concept-behaviors

                        Вы можете связать имя с поведением, указав его в качестве ключа элемента массива, соответствующего конфигурации поведения. 
                        В таком случае, поведение называется именованным. В примере выше, два именованных поведения: myBehavior2 и myBehavior4. 
                        Если с поведением не связано имя, такое поведение называется анонимным.

                    Динамическое прикрепление - для того, чтобы прикрепить поведение динамически, 
                        необходимо вызвать метод yii\base\Component::attachBehavior() требуемого компонента.
                        use app\components\MyBehavior;

                        // прикрепляем объект поведения
                        $component->attachBehavior('myBehavior1', new MyBehavior);

                        // прикрепляем по имени класса поведения
                        $component->attachBehavior('myBehavior2', MyBehavior::class);

                        // прикрепляем используя массив конфигураций
                        $component->attachBehavior('myBehavior3', [
                            'class' => MyBehavior::class,
                            'prop1' => 'value1',
                            'prop2' => 'value2',
                        ]);

                    Использование поведений:
                        Вы можете обращаться к публичным переменным или свойствам, объявленным с использованием геттеров и сеттеров в поведении, 
                        через компонент, к которому оно прикреплено:
                        // публичное свойство "prop1" объявленное в классе поведения
                        echo $component->prop1;
                        $component->prop1 = $value;
                        
                        Аналогично, вы можете вызывать публичные методы поведения,
                        // публичный метод foo() объявленный в классе поведения
                        $component->foo();

                        Если при прикреплении поведения к компоненту указано имя, можно обращаться к поведению по этому имени, как показано ниже:
                        $behavior = $component->getBehavior('myBehavior');

                        Также можно получить все поведения, прикрепленные к компоненту:
                        $behaviors = $component->getBehaviors();

                    Отвязывание поведений:
                        Чтобы отвязать поведение от компонента, необходимо вызвать метод yii\base\Component::detachBehavior(), указав имя, связанное с поведением:
                            $component->detachBehavior('myBehavior1');

                        Так же, возможно отвязать все поведения:
                            $component->detachBehaviors();
                    
                    Использование поведения TimestampBehavior:
                        yii\behaviors\TimestampBehavior — поведение, которое позволяет автоматически обновлять атрибуты с метками времени при 
                            сохранении Active Record моделей через insert(), update() или save().
                        yii\behaviors\BlameableBehavior - автоматически заполняет указанные атрибуты ID текущего пользователя.
                        yii\behaviors\SluggableBehavior - автоматически заполняет указанные атрибут пригодным для URL текстом, получаемым из другого атрибута.
                        yii\behaviors\AttributeBehavior - автоматически задаёт указанное значение одному или нескольким атрибутам ActiveRecord при срабатывании 
                            определённых событий.
                        yii2tech\ar\softdelete\SoftDeleteBehavior - предоставляет методы для «мягкого» удаления и восстановления ActiveRecord. 
                            То есть выставляет статус или флаг, который показывает, что запись удалена.
                        yii2tech\ar\position\PositionBehavior - позволяет управлять порядком записей через специальные методы. Информация сохраняется в целочисленном поле.


========================================================================================================================================================
Контроллер
----------
    Контроллеры являются частью MVC архитектуры. 
    Это объекты классов, унаследованных от yii\base\Controller или их потомков:
        - в веб приложениях, контроллеры должны быть унаследованы от yii\web\Controller или его потомков. 
        - в консольных приложений, контроллеры должны быть унаследованы от yii\console\Controller или его потомков. 

    ID контроллеров:
        обычно контроллер сделан таким образом, что он должен обрабатывать запросы, связанные с определенным ресурсом. 
        Именно по этим причинам, ID контроллеров обычно являются существительные, ссылающиеся на ресурс, который они обрабатывают.
        ID контроллеров должны содержать только следующие символы: Английские буквы в нижнем регистре, цифры, подчеркивания, тире и слэш.
        ID контроллеров также могут содержать префикс подпапки.
        Например, вы можете использовать article в качестве ID контроллера, которые отвечает за обработку данных статей.

    Правила наименования классов контроллеров:
        Названия классов контроллеров могут быть получены из ID контроллеров следующими способами:
        1) Привести в верхний регистр первый символ в каждом слове, разделенном дефисами. Обратите внимание что, если ID контроллера содержит слэш, то данное правило распространяется только на часть после последнего слэша в ID контроллера;
        2) Убрать дефисы и заменить любой прямой слэш на обратный;
        3) Добавить суффикс Controller;
        4) Добавить в начало пространство имен контроллеров.

    В целом, контроллеры:
        могут иметь доступ к данным запроса;
        могут вызывать методы моделей и других компонентов системы с данными запроса;
        могут использовать представления для формирования ответа;
        не должны заниматься обработкой данных, это должно происходить в слое моделей;
        должны избегать использования HTML или другой разметки, лучше это делать в представлениях.

    Конфигурирование контроллера через приложение:
        Карта контроллеров (controllerMap):
            Вы можете сконфигурировать карту контроллеров для того, чтобы преодолеть описанные выше ограничения именования ID контроллеров и названий классов. 
            В основном это очень удобно, когда вы используете сторонние контроллеры, именование которых вы не можете контролировать.
        
        Контроллер по умолчанию (defaultRoute):
            Каждое приложение имеет контроллер по умолчанию, указанный через свойство yii\base\Application::$defaultRoute. 
            Когда в запросе не указан маршрут, тогда будет использован маршрут указанный в данном свойстве. 
            Для Веб приложений, это значение 'site', в то время как для консольных приложений, это 'help'. Таким образом, если задан URL https://hostname/index.php, это означает, что контроллер site выполнит обработку запроса.

    В сущности, после обработки запроса приложениями, контроллеры проанализируют входные данные, передадут их в модели, вставят результаты модели в представления, 
    и в конечном итоге сгенерируют исходящие ответы.

    Контроллеры состоят из действий, которые являются основными блоками, к которым может обращаться конечный пользователь и запрашивать исполнение того или иного функционала. 
    В контроллере может быть одно или несколько действий.

    Информация: 
        Как и действия, контроллеры также имеют идентификаторы, которые однозначно определяют их в приложении. 
        Идентификаторы контроллеров используют те же правила именования, что и идентификаторы действий. 
        Имена классов контроллеров получаются путём удаления дефисов из идентификатора, преобразования первой буквы каждого слова в верхний регистр 
        и добавления в конец Controller. Например, идентификатор контроллера post-comment соответствует имени класса контроллера PostCommentController.

    Методы (дествия)
    ----------------
        Информация: 
            Идентификаторы (MethodID) действий задаются в нижнем регистре. Если идентификатор состоит из нескольких слов, они соединяются дефисами, то есть create-comment. 
            Имена методов действий получаются путём удаления дефисов из идентификатора, преобразования первой буквы каждого слова в верхний регистр и добавления префикса action. 
            Например, идентификатор действия create-comment соответствует методу actionCreateComment.

        Виды:
            - методы-действия, это public метод, начинающийся с префикса "action" (пример: actionSay()).
                Название после префикса action считается идентификатором соответствующего действия.
            - обычные методы класса

        ID действий:
            В основном действие разрабатывается для какой-либо конкретной обработки ресурса. 
            По этой причине, ID действий в основном являются глаголами, такими как view, update, и т. д.
            ID действия должен содержать только следующие символы: Английские буквы в нижнем регистре, цифры, подчеркивания и дефисы. 
            Дефисы в ID действий используются для разделения слов.
            Названия имен действий являются регистрозависимыми.

        Создания действия (методов):
            1) Встроенные действия - является методом, определенным в классе контроллера.
                Встроенные действия требуют меньше усилий для создания и в основном используются если у вас нет надобности в повторном использовании действий.

                Названия методов действий могут быть получены из ID действий следующим образом:
                    Привести первый символ каждого слова в ID действия в верхний регистр;
                    Убрать дефисы;
                    Добавить префикс action.

            2) Отдельное действие - является экземпляром класса, унаследованного от yii\base\Action или его потомков.
                Отдельные действия, с другой стороны, в основном создаются для использования в различных контроллерах или при использовании в расширениях.

                Для использования отдельного действия, вы должны указать его в карте действий, с помощью переопределения 
                метода yii\base\Controller::actions() в вашем классе контроллера.

                Для создания отдельного действия, вы должны наследоваться от класса yii\base\Action или его потомков, и реализовать метод run() с областью видимости public. 
                Роль метода run() аналогична другим методам действий.

        Результат действий (методов):
            Возвращаемое значение может быть объектом response, который будет отослан конечному пользователю в качестве ответа.
                Для Веб приложений, возвращаемое значение также может быть произвольными данными, которые будут присвоены yii\web\Response::$data, а затем конвертированы в строку, представляющую тело ответа.
                Для Консольных приложений, возвращаемое значение также может быть числом, представляющим статус выхода исполнения команды.

        Параметры действий:
            Для Веб приложений, значение каждого из параметров действия берется из $_GET, используя название параметра в качестве ключа; 
            для консольных приложений, они соответствуют аргументам командной строки.

        Действие по умолчанию:
            Каждый контроллер имеет действие, указанное через свойство yii\base\Controller::$defaultAction. 
            Когда маршрут содержит только ID контроллера, то подразумевается, что действие контроллера по умолчанию было запрошено.            
            По-умолчанию, это действие имеет значение index. Если вы хотите изменить это значение, просто переопределите данное свойство в классе контроллера следующим образом:
                public $defaultAction = 'home';

        Жизненный цикл контроллера:
            При обработке запроса, приложение создаст контроллер, основываясь на запрошенном маршруте. 
            Для выполнения запроса, контроллер пройдет через следующие этапы жизненного цикла:
                1) Метод yii\base\Controller::init() будет вызван после того как контроллер будет создан и сконфигурирован;
                2) Контроллер создает объект действия, основываясь на запрошенном ID действия:
                    Если ID действия не указан, то будет использовано ID действия по умолчанию;
                    Если ID действия найдено в карте действий, то отдельное действие будет создано;
                    Если ID действия соответствует методу действия, то встроенное действие будет создано;
                    В противном случае, будет выброшено исключение yii\base\InvalidRouteException.
                3) Контроллер последовательно вызывает метод beforeAction() приложения, модуля (если контроллер принадлежит модулю) и самого контроллера.
                    Если один из методов вернул false, то остальные, не вызванные методы beforeAction будут пропущены, а выполнение действия будет отменено;
                    По-умолчанию, каждый вызов метода beforeAction() вызовет событие beforeAction, на которое вы можете назначить обработчики.
                4) Контроллер запускает действие:
                    Параметры действия будут проанализированы и заполнены из данных запроса.
                5) Контроллер последовательно вызывает методы afterAction контроллера, модуля (если контроллер принадлежит модулю) и приложения.
                    По-умолчанию, каждый вызов метода afterAction() вызовет событие afterAction, на которое вы можете назначить обработчики.
                6) Приложение, получив результат выполнения действия, присвоит его объекту response.

    Маршруты
    --------
        Конечные пользователи обращаются к действиям через так называемые маршруты. Маршрут это строка, состоящая из следующих частей:

        ID модуля: он существует, только если контроллер принадлежит не приложению, а модулю;
        ID контроллера: строка, которая уникально идентифицирует контроллер среди всех других контроллеров одного и того же приложения (или одного и того же модуля, если контроллер принадлежит модулю);
        ID действия: строка, которая уникально идентифицирует действие среди всех других действия одного и того же контроллера.

        Маршруты могут иметь следующий формат:
            ControllerID/ActionID
        или следующий формат, если контроллер принадлежит модулю:
            ModuleID/ControllerID/ActionID

========================================================================================================================================================
Фильтры
-------
    Фильтры — это объекты, которые могут запускаться как перед так и после действий контроллера.
    Фильтр может состоять из пре-фильтра (фильтрующая логика применяется перед действиями) и/или пост-фильтра (логика, применяемая после действий).

    Использование фильтров:
        Фильтры являются особым видом поведений. Их использование ничем не отличается от использования поведений. 
        Вы можете объявлять фильтры в классе контроллера (модуля или приложения) путём перекрытия метода behaviors().

        По умолчанию фильтры, объявленные в классе контроллера, будут применяться ко всем его действиям.
        Тем не менее, вы можете явно указать и конкретные действия задав свойство only.
        Вы можете настроить свойство except чтобы указать действия, к которым фильтр применяться не должен.

        Примечание: 
            При объявлении фильтров в модулях или приложениях, следует использовать маршруты вместо идентификаторов действий в свойствах only и except так как сами по себе, 
            идентификаторы действий не могут полностью идентифицировать действие в контексте модуля или приложения.

        Когда несколько фильтров указываются для одного действия, они применяются согласно следующим правилам:
            Пре-фильтрация
                Применяются фильтры, объявленные в приложении в том порядке, в котором они перечислены в behaviors().
                Применяются фильтры, объявленные в модуле в том порядке, в котором они перечислены в behaviors().
                Применяются фильтры, объявленные в контроллере в том порядке, в котором они перечислены в behaviors().
                Если, какой-либо из фильтров отменяет выполнение действия, оставшиеся фильтры (как пре-фильтры, так и пост-фильтры) не будут применены.
            Выполняется действие, если оно прошло пре-фильтрацию.
            Пост-фильтрация
                Применяются фильтры объявленные в контроллере, в порядке обратном, перечисленному в behaviors().
                Применяются фильтры объявленные в модуле, в порядке обратном, перечисленному в behaviors().
                Применяются фильтры объявленные в приложении, в порядке обратном, перечисленному в behaviors().

    Создание фильтров:
        При создании нового фильтра действия, необходимо наследоваться от yii\base\ActionFilter и переопределить методы beforeAction() и/или afterAction()
        Если вернётся false, то оставшиеся фильтры не будут применены и действие выполнено не будет.

    Стандартные фильтры:
        Yii предоставляет набор часто используемых фильтров, которые находятся, в основном, в пространстве имен yii\filters

        AccessControl - фильтр AccessControl обеспечивает простое управление доступом, основанное на наборе правил rules. 
            В частности, перед тем как действие начинает выполнение, фильтр AccessControl проверяет список указанных правил, 
            пока не найдёт соответствующее текущему контексту переменных (таких как IP адрес пользователя, статус аутентификации и так далее). 
            Найденное правило указывает, разрешить или запретить выполнение запрошенного действия. Если ни одно из правил не подходит, то доступ будет запрещён.
        Фильтр метода аутентификации - Фильтр метода аутентификации используется для аутентификации пользователя различными способами, такими как HTTP Basic Auth, OAuth 2. 
            Классы данных фильтров находятся в пространстве имён yii\filters\auth.
        ContentNegotiator - поддерживает согласование формата ответа и языка приложения. 
            Он пытается определить формат ответа и/или язык, путём проверки GET параметров и HTTP заголовка Accept.
        HttpCache - фильтр HttpCache реализовывает кэширование на стороне клиента, используя HTTP заголовки Last-Modified и Etag.
        PageCache - реализует кэширование целых страниц на стороне сервера.
        RateLimiter - ограничитель количества запросов в единицу времени (RateLimiter) реализует алгоритм ограничения запросов, основанный на алгоритме leaky bucket. 
            В основном, он используется при создании RESTful API. 
            Подробнее об использовании данного фильтра можно прочитать в разделе Ограничение запросов.
        VerbFilter - Фильтр по типу запроса (VerbFilter) проверяет, разрешено ли запросам HTTP выполнять затребованные ими действия.
            Если нет, то будет выброшено исключение HTTP с кодом 405. 
        Cors - совместное использование разными источниками CORS это механизм, который позволяет использовать различные ресурсы (шрифты, скрипты, и т.д.) 
            с отличных от основного сайта доменов. В частности, AJAX вызовы JavaScript могут использовать механизм XMLHttpRequest. 
            В противном случае, такие "междоменные" запросы были бы запрещены из-за политики безопасности same origin. 
            CORS задаёт способ взаимодействия сервера и браузера, определяющий возможность делать междоменные запросы.
            Фильтр Cors filter следует определять перед фильтрами Аутентификации / Авторизации, для того чтобы быть уверенными, что заголовки CORS будут всегда посланы.

========================================================================================================================================================
Модули
------
    Модули - это законченные программные блоки, состоящие из моделей, представлений, контроллеров и других вспомогательных компонентов.
    
    Создание модулей:
         следующем примере показано примерное содержимое модуля:
            forum/
                Module.php                   файл класса модуля
                controllers/                 содержит файлы классов контроллеров
                    DefaultController.php    файл класса контроллера по умолчанию
                models/                      содержит файлы классов моделей
                views/                       содержит файлы представлений контроллеров и шаблонов
                    layouts/                 содержит файлы представлений шаблонов
                    default/                 содержит файлы представления контроллера DefaultController
                        index.php            файл основного представления

    Классы модулей:
        Каждый модуль объявляется с помощью уникального класса, который наследуется от yii\base\Module.
        Во время доступа к модулю будет создан один экземпляр соответствующего класса модуля. 
        Как и экземпляры приложения, экземпляры модулей нужны, чтобы код модулей мог получить общий доступ к данным и компонентам.
    
    Контроллеры в модулях:
        При создании контроллеров модуля принято помещать классы контроллеров в подпространство controllers пространства имён класса модуля. 
        Это также подразумевает, что файлы классов контроллеров должны располагаться в директории controllers базового пути модуля.
    
    Представления в модулях:
        Представления модуля также следует поместить в поддиректорию views базового пути модуля. 
        Виды, которые рендерит контроллер модуля, должны располагаться в директории views/ControllerID, где ControllerID соответствует идентификатору контроллера.

    Консольные команды в модулях:
        Ваш модуль также может объявлять команды, которые будут доступны через консоль.
        Для того, чтобы команда стала доступна, надо изменить свойство yii\base\Module::$controllerNamespace для консольного режима так, 
        чтобы оно содержало пространство имён ваших команд.

        Этого можно добиться проверяя класс экземпляра приложения Yii в методе init модуля:
            public function init()
            {
                parent::init();
                if (Yii::$app instanceof \yii\console\Application) {
                    $this->controllerNamespace = 'app\modules\forum\commands';
                }
            }

            Ваши команды будут доступны из командной строки как:
            yii <module_id>/<command>/<sub_command>
        
    Использование модулей:
        Чтобы задействовать модуль в приложении, достаточно включить его в свойство modules в конфигурации приложения.
        Пример:
            [
                'modules' => [
                    'forum' => [
                        'class' => 'app\modules\forum\Module',
                        // ... другие настройки модуля ...
                    ],
                ],
            ]
        Информация:
            Для подключения консольных команд вашего модуля, нужно также включить его в конфигурации консольного приложения.

    Маршруты:
        Как маршруты приложения используются для обращения к контроллерам приложения, маршруты модуля используются, чтобы обращаться к контроллерам этого модуля.
        Маршрут контроллера в модуле должен начинаться с идентификатора модуля, за которым следуют идентификатор контроллера и идентификатор действия.
        Например, если в приложении задействован модуль forum, то маршрут forum/post/index соответствует действию index контроллера post этого модуля.
        Если маршрут состоит только из идентификатора модуля, то контроллер и действие определяются исходя из свойства yii\base\Module::$defaultRoute, 
        которое по умолчанию равно default. Таким образом, маршрут forum соответствует контроллеру default модуля forum.
    
        Получение доступа к модулям:
            Получения доступа к модулю из модуля:
            $module = MyModuleClass::getInstance();

            Информация:
                При разработке модуля нельзя исходить из предположения, что модулю будет назначен конкретный идентификатор.
                Это связано с тем, что идентификатор, назначаемый модулю при использовании в приложении или в другом модуле, может быть выбран совершенно произвольно.
                Чтобы получить идентификатор модуля, нужно вначале выбрать экземпляр модуля, как это описано выше, а затем получить доступ к идентификатору через свойство $module->id.
            
            Доступ к экземпляру модуля можно получить следующими способами:
                // получение дочернего модуля с идентификатором "forum"
                $module = \Yii::$app->getModule('forum');

                // получение модуля, к которому принадлежит запрошенный в настоящее время контроллер
                $module = \Yii::$app->controller->module;

                Имея экземпляр модуля можно получить доступ к параметрам и компонентам, зарегистрированным в модуле. Например,
                    $maxPostCount = $module->params['maxPostCount'];

    Вложенные модули:
        Модули могут вкладываться друг в друга без ограничений по глубине. Иными словами, в модуле содержится модуль, в который входит еще один модуль, и т. д.
        Первый модуль называется родительским, остальные - дочерними. Дочерние модули объявляются в свойстве modules родительских модулей.      

    Лучшие практики:
        Модули лучше всего подходят для крупных приложений, функционал которых можно разделить на несколько групп, в каждой из которых функции тесно связаны между собой. 
        Каждая группа функций может разрабатываться в виде модуля, над которым работает один разработчик или одна команда.
        Модули - это хороший способ повторно использовать код на уровне групп функций. В виде модулей можно реализовать такую функциональность, 
        как управление пользователями или управление комментариями, а затем использовать эти модули в будущих разработках.

========================================================================================================================================================
Модель
------
    Модели являются частью архитектуры MVC.
    Они представляют собой объекты бизнес данных, правил и логики.
    Это объекты классов, унаследованных от yii\base\Model или их потомков 
    (например класс Model также является базовым классом для многих расширенных моделей, таких как yii\db\ActiveRecord).
    Название класса модели будет связано с таким же именем таблицы в базе данных.
    Информация: 
        Если нет возможности задать прямую зависимость между именем таблицы и именем класса, вы можете переопределить метод yii\db\ActiveRecord::tableName(), 
        чтобы явно задать имя связанной таблицы.
    Информация: 
        Вы не обязаны основывать свои классы моделей на yii\base\Model. Однако, поскольку в yii есть много компонентов, 
        созданных для поддержки yii\base\Model, обычно так делать предпочтительнее для базового класса модели.

    Атрибуты модели:
        Модели предоставляют рабочие данные в терминах атрибутах.
        Каждый атрибут представляет собой public доступное свойство модели.
        Метод yii\base\Model::attributes() определяет какие атрибуты имеет класс модели (возвращает массив имен атрибутов).
        Также возможно получить доступ к атрибутам как к элементам массива, спасибо поддержке ArrayAccess и Traversable в yii\base\Model.

        Определение Атрибутов:
            По умолчанию, если ваш класс модели расширяется напрямую от yii\base\Model, то все не статичные публичные переменные являются атрибутами.
            Вы можете переопределить метод yii\base\Model::attributes(), чтобы определять атрибуты другим способом. Метод должен возвращать имена атрибутов в модели. 
            Например yii\db\ActiveRecord делает так, возвращая имена столбцов из связанной таблицы базы данных в качестве имён атрибутов. 
            Также может понадобиться переопределить магические методы, такие как __get(), __set() для того, чтобы атрибуты могли быть доступны как обычные свойства объекта.

        Метки атрибутов:
            При отображении значений или при получении ввода значений атрибутов, часто требуется отобразить некоторые надписи, связанные с атрибутами. 
            Например, если атрибут назван firstName, Вы можете отобразить его как First Name, что является более удобным для пользователя, 
            в тех случаях, когда атрибут отображается конечным пользователям в таких местах, как форма входа и сообщения об ошибках.
            
            Получить метку атрибута, вызвав yii\base\Model::getAttributeLabel().

            Если Вы не хотите использовать автоматически сгенерированные метки, 
            Переопределить метку атрибута, вызвав метод yii\base\Model::attributeLabels(), чтобы явно объявить метку атрибута.
            Можно даже условно определять метки атрибутов. Например, на основе сценариев и использованной в нём модели , 
            Вы можете возвращать различные метки для одного и того же атрибута.
    
    Сценании модели:
        Модель использует свойство yii\base\Model::$scenario, чтобы отслеживать сценарий, в котором она используется.
        По умолчанию, модель поддерживает только один сценарий с именем default.
        Пример установки сценария:
            // сценарий задается как свойство
            $model = new User;
            $model->scenario = User::SCENARIO_LOGIN;

            // или сценарий задается через конфигурацию
            $model = new User(['scenario' => User::SCENARIO_LOGIN]);

        По умолчанию сценарии, поддерживаемые моделью, определяются правилами валидации объявленными в модели. 
        Однако Вы можете изменить это поведение путем переопределения метода yii\base\Model::scenarios().
        Метод scenarios() возвращает массив, ключами которого являются имена сценариев, а значения - соответствующие активные атрибуты. 
        Активные атрибуты могут быть массово присвоены и подлежат валидации. 
        Пример:
            const SCENARIO_LOGIN = 'login';
            const SCENARIO_REGISTER = 'register';

            public function scenarios()
            {
                return [
                    self::SCENARIO_LOGIN => ['username', 'password'],
                    self::SCENARIO_REGISTER => ['username', 'email', 'password'],
                ];
            }

        По умолчанию реализация scenarios() вернёт все найденные сценарии в правилах валидации, задекларированных в методе yii\base\Model::rules(). 
        При переопределении метода scenarios(), если Вы хотите ввести новые сценарии помимо стандартных, Вы можете написать код на основе следующего примера:
        Пример:
            public function scenarios()
            {
                $scenarios = parent::scenarios();
                $scenarios[self::SCENARIO_LOGIN] = ['username', 'password'];
                $scenarios[self::SCENARIO_REGISTER] = ['username', 'email', 'password'];
                return $scenarios;
            }
        
    Правила валидации:
        Когда данные модели, получены от конечных пользователей, они должны быть проверены, для того чтобы убедиться, 
        что данные удовлетворяют определенным правилам (так называемым правилам валидации также известными как бизнес-правила).
        
        Вы можете вызвать yii\base\Model::validate() для проверки полученных данных. 
        Данный метод будет использовать правила валидации определённые в yii\base\Model::rules() для проверки каждого соответствующего атрибута. 
        Если ошибок не найдено, то возвращается true, в противном случае возвращается false, а ошибки содержит свойство yii\base\Model::$errors.
        Пример:
            $model = new \app\models\ContactForm;

            // модель заполнения атрибутов данными, вводимыми пользователем
            $model->attributes = \Yii::$app->request->post('ContactForm');

            if ($model->validate()) {
                // все данные верны
            } else {
                // проверка не удалась:  $errors - это массив содержащий сообщения об ошибках
                $errors = $model->errors;
            }

        Объявляем правила валидации связанные с моделью, переопределяем метод yii\base\Model::rules() возврата правил атрибутов модели которые следует удовлетворить.
        Правило может использоваться для проверки одного или нескольких атрибутов, также и атрибут может быть проверен одним или несколькими правилами. 
        Пример:
            public function rules()
            {
                return [
                    // name, email, subject и body атрибуты обязательны
                    [['name', 'email', 'subject', 'body'], 'required'],

                    // атрибут email должен быть правильным email адресом
                    ['email', 'email'],
                ];
            }

        Иногда необходимо, чтобы правила применялись только в определенных сценариях. Чтобы это сделать необходимо указать свойство on в правилах, следующим образом:
        Пример:
            public function rules()
            {
                return [
                    // username, email и password требуются в сценарии "register"
                    [['username', 'email', 'password'], 'required', 'on' => self::SCENARIO_REGISTER],

                    // username и password требуются в сценарии "login"
                    [['username', 'password'], 'required', 'on' => self::SCENARIO_LOGIN],
                ];
            }
            
        Если не указать свойство on, то правило применяется во всех сценариях. 
        Правило называется активным правилом если оно может быть применено в текущем сценарии scenario.
        Атрибут будет проверяться тогда и только тогда если он является активным атрибутом объявленным в scenarios() и 
        связанным с одним или несколькими активными правилами, объявленными в rules().
        
    Массовое Присвоение атрибутов модели:
        Массовое присвоение - это удобный способ заполнения модели данными вводимыми пользователем с помощью одной строки кода. 
        Он заполняет атрибуты модели путем присвоения входных данных непосредственно свойству yii\base\Model::$attributes.
        Пример:
            $model = new \app\models\ContactForm;
            $model->attributes = \Yii::$app->request->post('ContactForm');

        Безопасные Атрибуты:
            Массовое присвоение применяется только к так называемым безопасным атрибутам, которые являются атрибутами, 
            перечисленными в yii\base\Model::scenarios() в текущем сценарии scenario модели.

            Информация:
                Причиной того, что массовое присвоение атрибутов применяется только к безопасным атрибутам, является то, что необходимо контролировать 
                какие атрибуты могут быть изменены конечными пользователями. Например, если модель User имеет атрибут permission, 
                который определяет разрешения, назначенные пользователю, то необходимо быть уверенным, 
                что данный атрибут может быть изменён только администраторами через бэкэнд-интерфейс.

            По умолчанию yii\base\Model::scenarios() будет возвращать все сценарии и атрибуты найденные в yii\base\Model::rules(), 
            если не переопределить этот метод, атрибут будет считаться безопасным только в случае, если он участвует в любом из активных правил проверки.
            По этой причине существует специальный валидатор с псевдонимом safe, он предоставляет возможность объявить атрибут безопасным без фактической его проверки. 
            Например, следующие правила определяют, что оба атрибута title и description являются безопасными атрибутами.
                public function rules()
                {
                    return [
                        [['title', 'description'], 'safe'],
                    ];
                }

        Небезопасные Атрибуты:
            Как сказано выше, метод yii\base\Model::scenarios() служит двум целям: определения, какие атрибуты должны быть проверены, 
            и определения, какие атрибуты являются безопасными (т.е. не требуют проверки). 
            В некоторых случаях необходимо проверить атрибут не объявляя его безопасным. 
            Вы можете сделать это с помощью префикса восклицательный знак ! в имени атрибута при объявлении его в scenarios() как атрибут secret в следующем примере:
            public function scenarios()
            {
                return [
                    self::SCENARIO_LOGIN => ['username', 'password', '!secret'],
                ];
            }
            Когда модель будет присутствовать в сценарии login, то все три эти атрибута будут проверены. 
            Однако, только атрибуты username и password могут быть массово присвоены. Назначить входное значение атрибуту secret нужно явно следующим образом,
            $model->secret = $secret;

    Экспорт Данных:
        Часто нужно экспортировать модели в различные форматы. Например, может потребоваться преобразовать коллекцию моделей в JSON или Excel формат. 
        Процесс экспорта может быть разбит на два самостоятельных шага. На первом этапе модели преобразуются в массивы; 
        на втором этапе массивы преобразуются в целевые форматы. Вы можете сосредоточиться только на первом шаге потому, 
        что второй шаг может быть достигнут путем универсального инструмента форматирования данных, такого как yii\web\JsonResponseFormatter.

        Самый простой способ преобразования модели в массив - использовать свойство yii\base\Model::$attributes. Например
            $post = \app\models\Post::findOne(100);
            $array = $post->attributes;

        По умолчанию свойство yii\base\Model::$attributes возвращает значения всех атрибутов объявленных в yii\base\Model::attributes().
        Более гибкий и мощный способ конвертирования модели в массив - использовать метод yii\base\Model::toArray(). 
        Его поведение по умолчанию такое же как и у yii\base\Model::$attributes. Тем не менее, он позволяет выбрать, какие элементы данных, 
        называемые полями, поставить в результирующий массив и как они должны быть отформатированы. 
        На самом деле, этот способ экспорта моделей по умолчанию применяется при разработке в RESTful Web service, как описано в Response Formatting.

        Поля:
            Поле - это просто именованный элемент в массиве, который может быть получен вызовом метода yii\base\Model::toArray() модели.
            По умолчанию имена полей эквивалентны именам атрибутов. Однако, это поведение можно изменить, переопределив методы fields() и/или extraFields().
            https://www.yiiframework.com/doc/guide/2.0/ru/structure-models#attribute-labels - подробнее

            Внимание: 
                по умолчанию все атрибуты модели будут включены в экспортируемый массив, вы должны проверить ваши данные и убедиться, 
                что они не содержат конфиденциальной информации. Если такая информация присутствует, вы должны переопределить fields() и отфильтровать поля.

База данных
-----------
    Объекты доступа к данным (DAO)
    ------------------------------
        Построенные поверх PDO, Yii DAO (объекты доступа к данным) обеспечивают объектно-ориентированный API для доступа к реляционным базам данных. 
        Это основа для других, более продвинутых, методов доступа к базам данных, включая построитель запросов и Active Record.

        При использовании Yii DAO вы в основном будете использовать чистый SQL и массивы PHP. Как результат, это самый эффективный способ доступа к базам данных. 
        Тем не менее, так как синтаксис SQL может отличаться для разных баз данных, используя Yii DAO вам нужно будет приложить дополнительные усилия, 
        чтобы сделать приложение не зависящим от конкретной базы данных.

        Создание подключения к базе данных:
            1) Необходимо создать экземляр yii\db\Connection
                $db = new yii\db\Connection([
                    'dsn' => 'mysql:host=localhost;dbname=example',
                    'username' => 'root',
                    'password' => '',
                    'charset' => 'utf8',
                ]);
            2) или настроить его как компонента приложения:
                return [
                    // ...
                    'components' => [
                        // ...
                        'db' => [
                            ...
                        ],
                    ],
                    // ...
                ];
            Подсказка: Вы можете настроить несколько компонентов подключения, если в вашем приложении используется несколько баз данных.
            Информация: При создании экземпляра соединения к БД, фактическое соединение с базой данных будет установлено только при выполнении первого SQL запроса 
                или при явном вызове метода open().
            Подсказка: Иногда может потребоваться выполнить некоторые запросы сразу после соединения с базой данных, для инициализации переменных окружения. 
                Например, чтобы задать часовой пояс или кодировку. Сделать это можно зарегистрировав обработчик для события afterOpen в конфигурации приложения:
                    'db' => [
                        // ...
                        'on afterOpen' => function($event) {
                            // $event->sender содержит соединение с базой данных
                            $event->sender->createCommand("SET time_zone = 'UTC'")->execute();
                        }
                    ]   
        Выполнение SQL запросов:
            После создания экземпляра соединения, вы можете выполнить SQL запрос, выполнив следующие шаги:
                1) Создать yii\db\Command из запроса SQL;
                2) Привязать параметры (не обязательно);
                3) Вызвать один из методов выполнения SQL из yii\db\Command.
                    ->queryAll(); - возвращает набор строк. каждая строка - это ассоциативный массив с именами столбцов и значений, 
                        если выборка ничего не вернёт, то будет получен пустой массив.
                    ->queryOne(); - вернёт одну строку (первую строку), false, если ничего не будет выбрано
                    ->queryColumn(); - вернёт один столбец (первый столбец), пустой массив, при отсутствии результата
                    ->queryScalar(); - вернёт скалярное значение или false, при отсутствии результата
                Примечание: Чтобы сохранить точность, данные извлекаются как строки, даже если тип поля в базе данных является числовым.

            Привязка параметров:
                При создании команды из SQL запроса с параметрами, вы почти всегда должны использовать привязку параметров для предотвращения атак через SQL инъекции.
                В SQL запрос, вы можете встраивать один или несколько маркеров (например :id в примере выше). 
                
                Маркеры должны быть строкой, начинающейся с двоеточия. Далее вам нужно вызвать один из следующих методов для привязки значений к параметрам:
                    bindValue(): привязка одного параметра по значению
                    bindValues(): привязка нескольких параметров в одном вызове
                    bindParam(): похоже на bindValue(), но привязка происходит по ссылке.
                Привязка переменных реализована через подготавливаемые запросы. Помимо предотвращения атак путём SQL инъекций, это увеличивает производительность, 
                так как запрос подготавливается один раз, а потом выполняется много раз с разными параметрами.

            Выполнение Не-SELECT запросов:
                Для запросов не возвращающих данные, вы должны использовать метод yii\db\Command::execute().
                Например:
                    Yii::$app->db->createCommand('UPDATE post SET status=1 WHERE id=1')->execute();
                Метод yii\db\Command::execute() возвращает количество строк обработанных SQL запросом.
                Для запросов INSERT, UPDATE и DELETE, вместо написания чистого SQL, вы можете вызвать методы 
                    insert()
                    update()
                    delete()
                    batchInsert() для вставки множества строк за один вызов.
            
            Экранирование имён таблиц и столбцов:
                При написании независимого от базы данных кода, правильно экранировать имена таблиц и столбцов довольно трудно, так как в разных базах данных правила экранирования разные.
                Чтоб преодолеть данную проблему вы можете использовать следующий синтаксис экранирования используемый в Yii:
                    [[column name]]: заключайте имя столбца в двойные квадратные скобки;
                    {{table name}}: заключайте имя таблицы в двойные фигурные скобки.
                Yii DAO будет автоматически преобразовывать подобные конструкции в SQL в правильно экранированные имена таблиц и столбцов.

                Использование префиксов таблиц:
                    Если большинство ваших таблиц использует общий префикс в имени, вы можете использовать свойство Yii DAO для указания префикса.
                    yii\db\Connection::$tablePrefix
                    return [
                        // ...
                        'components' => [
                            // ...
                            'db' => [
                                // ...
                                'tablePrefix' => 'tbl_',
                            ],
                        ],
                    ];
                    Затем в коде, когда вам нужно ссылаться на таблицу, имя которой содержит такой префикс, используйте синтаксис {{%table name}}. 
                    Символ процента будет автоматически заменён на префикс таблицы, который вы указали во время конфигурации соединения с базой данных.
            
            Исполнение транзакций:
                https://www.yiiframework.com/doc/guide/2.0/ru/db-dao#performing-transactions
                Следующий код показывает типичное использование транзакций:
                    Yii::$app->db->transaction(function($db) {
                        $db->createCommand($sql1)->execute();
                        $db->createCommand($sql2)->execute();
                        // ... executing other SQL statements ...
                    });
                
                Указание уровня изоляции:
                    https://www.yiiframework.com/doc/guide/2.0/ru/db-dao#specifying-isolation-levels

                Вложенные транзакции:
                    https://www.yiiframework.com/doc/guide/2.0/ru/db-dao#nesting-transactions
                    Если ваша СУБД поддерживает Savepoint, вы можете вкладывать транзакции как показано ниже:
                        Yii::$app->db->transaction(function ($db) {
                            // внешняя транзакция
                            
                            $db->transaction(function ($db) {
                                // внутренняя транзакция
                            });
                        });

            Репликация и разделение запросов на чтение и запись:
                https://www.yiiframework.com/doc/guide/2.0/ru/db-dao#read-write-splitting
                Многие СУБД поддерживают репликацию баз данных для лучшей доступности базы данных и уменьшения времени ответа сервера. 
                С репликацией базы данных, данные копируются из master servers на slave servers. Все вставки и обновления должны происходить на основном сервере, 
                хотя чтение может производится и с подчинённых серверов.
                Чтоб воспользоваться преимуществами репликации и достичь разделения чтения и записи, вам необходимо настроить компонент yii\db\Connection

            Работа со схемой базы данных:
                Yii DAO предоставляет целый набор методов для управления схемой базы данных, таких как создание новых таблиц, удаление столбцов из таблицы, и т.д. 
                Эти методы описаны ниже:
                    createTable(): создание таблицы
                    renameTable(): переименование таблицы
                    dropTable(): удаление таблицы
                    truncateTable(): удаление всех записей в таблице
                    addColumn(): добавление столбца
                    renameColumn(): переименование столбца
                    dropColumn(): удаление столбца
                    alterColumn(): преобразование столбца
                    addPrimaryKey(): добавление первичного ключа
                    dropPrimaryKey(): удаление первичного ключа
                    addForeignKey(): добавление внешнего ключа
                    dropForeignKey(): удаление внешнего ключа
                    createIndex(): создания индекса
                    dropIndex(): удаление индекса
                Вы также сможете получить описание схемы таблицы через вызов метода getTableSchema().

    Построитель запросов
    --------------------
        Построенный поверх DAO, построитель запросов позволяет конструировать SQL выражения в программируемом и независимом от СУБД виде. 
        В сравнении с написанием чистого SQL выражения, использование построителя помогает вам писать более читаемый связанный с SQL код и 
        генерировать более безопасные SQL выражения.
        Использование построителя запросов, как правило, включает два этапа:
            1) Создание объекта yii\db\Query представляющего различные части (такие как SELECT, FROM) SQL выражения SELECT.
            2) Выполнить запрос методом yii\db\Query (таким как all()) для извлечения данных из базы данных.
        Информация:
            В основном вы будете работать с yii\db\Query вместо yii\db\QueryBuilder. Последний вызывается неявно при вызове одного из методов запроса. 
            yii\db\QueryBuilder это класс, отвечающий за генерацию зависимого от СУБД SQL выражения (такие как экранирование имён таблиц/столбцов) из независимых от 
            СУБД объектов yii\db\Query. 
        
        Построение запросов:
            Создав объект yii\db\Query, вы можете вызвать различные методы для создания различных частей SQL выражения. 
            Имена методов напоминают ключевые слова SQL, используемые в соответствующих частях SQL запроса.
            Все методы построителя запросов возвращают свой объект, который позволяет объединять несколько вызовов в цепочку.
            Если вы не вызываете метод select() при создании запроса, будет использована *, что означает выбрать все столбцы.

            select()
            --------
                Метод select() определяет фрагмент SELECT SQL запроса. Вы можете указать столбцы, которые должны быть выбраны, они должны быть указаны в виде массива или строки. 
                Имена столбцов автоматически экранируются при создании SQL-запроса при его генерации из объекта yii\db\Query.
                Кроме имён столбцов, вы можете также использовать SQL выражения. Вы должны использовать формат массива для использования выражений, 
                которые содержат запятые для предотвращения некорректного автоматического экранирования. Например,
                    $query->select(["CONCAT(first_name, ' ', last_name) AS full_name", 'email']); 
                Начиная с версии 2.0.1, вы также можете использовать подзапросы. Вы должны указывать каждый подзапрос в выражении как объект yii\db\Query. 
                Например,
                    $subQuery = (new Query())->select('COUNT(*)')->from('user');

                    // SELECT `id`, (SELECT COUNT(*) FROM `user`) AS `count` FROM `post`
                    $query = (new Query())->select(['id', 'count' => $subQuery])->from('post');

                Чтоб выбрать конкретные строки, вы можете вызвать метод distinct():
                    // SELECT DISTINCT `user_id` ...
                    $query->select('user_id')->distinct();

                Вы можете вызвать addSelect() для добавления полей. Например,
                    $query->select(['id', 'username'])
                        ->addSelect(['email']);

            from()
            ------
                Метод from() указывает фрагмент FROM SQL запроса.

            where()
            -------
                Метод where() определяет фрагмент WHERE SQL выражения. Вы можете использовать один из трёх форматов:
                    1) строковый формат, Например, 'status=1'
                    2) формат массива, Например, ['status' => 1, 'type' => 2]
                    3) формат операторов, Например, ['like', 'name', 'test']

                1- Строковый формат
                    Строковый формат - это лучший выбор для простых условий. Он работает так, будто вы просто пишете SQL запрос. Например,
                        $query->where('status=1');

                        // или используя привязку параметров
                        $query->where('status=:status', [':status' => $status]);

                    При использовании привязки параметров, вы можете вызывать params() или addParams() для раздельного указания параметров.
                        $query->where('status=:status')
                            ->addParams([':status' => $status]);

                2- Формат массива
                    Формат массива лучше всего использовать для указания нескольких объединяемых через AND условий, каждое из которых является простым равенством. 
                    Он описывается в виде массива, ключами которого являются имена столбцов, а значения соответствуют значениям столбцов.
                        // ...WHERE (`status` = 10) AND (`type` IS NULL) AND (`id` IN (4, 8, 15))
                        $query->where([
                            'status' => 10,
                            'type' => null,
                            'id' => [4, 8, 15],
                        ]);
                    Вы также можете использовать подзапросы:
                        $userQuery = (new Query())->select('id')->from('user');

                        // ...WHERE `id` IN (SELECT `id` FROM `user`)
                        $query->where(['id' => $userQuery]);
                    Используя формат массива, Yii автоматически привязывает значения массива как параметры, потому в отличие от строкового формата, привязывать параметры вручную не требуется.
                    Обратите внимание, что Yii никогда НЕ экранирует имена столбцов (ключи массива), потому если вы используете как ключ массива переменную, 
                    полученную от пользователя без дополнительной проверки, ваше приложение становится подверженным атаке через SQL инъекцию. 
                    Чтобы избежать этого, используйте для имён столбцов только проверененные данные, предпочитая фильтрацию по «белому списку». 
                    Если вам нужно использовать имя столбца, полученное от пользователя, вам может быть полезным раздел Фильтрация данных.
                
                3- Формат операторов
                    Формат оператора позволяет задавать произвольные условия в программном стиле. Он имеет следующий вид:
                    [operator, operand1, operand2, ...]

                    Операнды могут быть заданы в виде строкового формата, формата массива или формата операторов рекурсивно, 
                    в то время как оператор может быть одним из следующих:
                    and
                    or
                    between
                    not between
                    in
                    not in
                    like
                    or like
                    not like
                    or not like
                    exists
                    not exists
                    >, <=, или другие валидные операторы БД, которые требуют двух операндов: первый операнд должен быть именем столбца, второй операнд это значение
                    
                    Используя формат операторов, Yii автоматически привязывает значения массива как параметры, потому в отличие от строкового формата, привязывать параметры вручную не требуется.
                    Обратите внимание, что Yii никогда НЕ экранирует имена столбцов (ключи массива), потому если вы используете как ключ массива переменную, 
                    полученную от пользователя без дополнительной проверки, ваше приложение становится подверженным атаке через SQL инъекцию. 
                    Чтобы избежать этого, используйте для имён столбцов только проверененные данные, предпочитая фильтрацию по «белому списку». 
                    Если вам нужно использовать имя столбца, полученное от пользователя, вам может быть полезным раздел Фильтрация данных.

                Добавление условий:
                    Вы можете использовать andWhere() или orWhere() для добавления дополнительных условий. 
                    Вы можете использовать эти вызовы несколько раз для добавления нескольких условий.

                Условия для фильтров:
                    Когда условие WHERE формируется на основе пользовательского ввода, обычно, хочется проигнорировать не заданные значения. 
                    Например, в форме поиска, которая позволяет осуществлять поиск по имени пользователя или email, вы хотели бы игнорировать username/email условие, 
                    если пользователь ничего не ввёл в поле ввода. Вы можете достичь этого используя метод filterWhere().
                    Единственное отличие между filterWhere() и where() заключается в игнорировании пустых значений, переданных в условие в форме массива.
                    Также вместо andWhere() и orWhere(), вы можете использовать andFilterWhere() и orFilterWhere() для добавления дополнительных условий фильтрации.
            
            orderBy()
            ---------
                Метод orderBy() определяет фрагмент ORDER BY SQL выражения. 
                Например,
                    // ... ORDER BY `id` ASC, `name` DESC
                    $query->orderBy([
                        'id' => SORT_ASC,
                        'name' => SORT_DESC,
                    ]);

                В данном коде, ключи массива - это имена столбцов, а значения массива - это соответствующее направление сортировки. 
                PHP константа SORT_ASC определяет сортировку по возрастанию и SORT_DESC сортировка по умолчанию.
                Если ORDER BY содержит только простые имена столбцов, вы можете определить их с помощью столбцов, также как и при написании обычного SQL.
                Например,
                    $query->orderBy('id ASC, name DESC');

                Примечание: Вы должны использовать массив для указания ORDER BY содержащих выражения БД.
                Вы можете вызывать addOrderBy() для добавления столбцов во фрагмент ORDER BY.
                    $query->orderBy('id ASC')
                        ->addOrderBy('name DESC');

            groupBy()
            ---------
                Метод groupBy() определяет фрагмент GROUP BY SQL запроса.
                    // ... GROUP BY `id`, `status`
                    $query->groupBy(['id', 'status']);

                Если фрагмент GROUP BY содержит только простые имена столбцов, вы можете указать их используя строку, также как в обычном SQL выражении.
                    $query->groupBy('id, status');

                Примечание: Вы должны использовать массив для указания GROUP BY содержащих выражения БД.
                Вы можете вызывать addGroupBy() для добавления имён столбцов во фрагмент GROUP BY. Например,
                    $query->groupBy(['id', 'status'])
                        ->addGroupBy('age');

            having()
            --------
                Метод having() определяет фрагмент HAVING SQL запроса. Он принимает условия, которое может быть определено тем же способом, что и для where().
                    // ... HAVING `status` = 1
                    $query->having(['status' => 1]);

                Пожалуйста, обратитесь к документации для where() для более подробной информации об определении условий.
                Вы можете вызывать andHaving() или orHaving() для добавления дополнительных условий во фрагмент HAVING.
                    // ... HAVING (`status` = 1) AND (`age` > 30)
                    $query->having(['status' => 1])
                        ->andHaving(['>', 'age', 30]);
                
            limit() и offset()
            ------------------
                Методы limit() и offset() определяют фрагменты LIMIT и OFFSET SQL запроса.
                Если вы определяете неправильный limit или offset (например отрицательное значение), они будут проигнорированы.
                Информация: 
                    Для СУБД, которые не поддерживают LIMIT и OFFSET (такие как MSSQL), построитель запросов будет генерировать SQL выражения, 
                    которые эмулирует поведение LIMIT/OFFSET.

            join()
            ------
                Метод join() принимает четыре параметра:
                    $type: тип объединения, например, 'INNER JOIN', 'LEFT JOIN'.
                    $table: имя таблицы, которая должна быть присоединена.
                    $on: необязательное условие объединения, то есть фрагмент ON. Пожалуйста, обратитесь к документации для where() для более подробной информации об определении условий. Отметим, что синтаксис массивов не работает для задания условий для столбцов, то есть ['user.id' => 'comment.userId'] будет означать условие, где ID пользователя должен быть равен строке 'comment.userId'. Вместо этого стоит указывать условие в виде строки 'user.id = comment.userId'.
                    $params: необязательные параметры присоединяемые к условию объединения.

            Вы можете использовать следующие сокращающие методы для указания INNER JOIN, LEFT JOIN и RIGHT JOIN, в указанном порядке.
                innerJoin()
                leftJoin()
                rightJoin()

            Кроме соединения с таблицами, вы можете также присоединять подзапросы. Чтобы это сделать, укажите объединяемый подзапрос как объект yii\db\Query.
                $subQuery = (new \yii\db\Query())->from('post');
                $query->leftJoin(['u' => $subQuery], 'u.id = author_id');
                В этом случае вы должны передать подзапросы в массиве и использовать ключи для определения алиасов.

            union()
            -------
                Метод union() определяет фрагмент UNION SQL запроса.
                $query1 = (new \yii\db\Query())
                    ->select("id, category_id AS type, name")
                    ->from('post')
                    ->limit(10);

                $query2 = (new \yii\db\Query())
                    ->select('id, type, name')
                    ->from('user')
                    ->limit(10);

                $query1->union($query2);
                Вы можете вызвать union() несколько раз для присоединения фрагментов UNION.
            
        Методы выборки:
            yii\db\Query предоставляет целый набор методов для разных вариантов выборки:
                all(): возвращает массив строк, каждая из которых это ассоциативный массив пар ключ-значение.
                one(): возвращает первую строку запроса.
                    Примечание: 
                    метод one() вернёт только первую строку результата запроса. Он НЕ добавляет LIMIT 1 в генерируемый SQL.
                    Это хорошо и предпочтительно если вы знаете, что запрос вернёт только одну или несколько строк данных (например, при запросе по первичному ключу). 
                    Однако если запрос потенциально может вернут много строк данных, вы должны вызвать limit(1) для повышения производительности, 
                    Например, (new \yii\db\Query())->from('user')->limit(1)->one().
                column(): возвращает первый столбец результата.
                scalar(): возвращает скалярное значение первого столбца первой строки результата.
                exists(): возвращает значение указывающее, что выборка содержит результат.
                count(): возвращает результат COUNT запроса.
                Другие методы агрегирования запросов, включая sum($q), average($q), max($q), min($q). 
                    Параметр $q обязателен для этих методов и могут содержать либо имя столбца, либо выражение БД.

                При вызове методов выборки yii\db\Query, внутри на самом деле проводится следующая работа:
                    1) Вызывается yii\db\QueryBuilder для генерации SQL запроса на основе текущего yii\db\Query;
                    2) Создаёт объект yii\db\Command со сгенерированным SQL запросом;
                    3) Вызывается выбирающий метод (например queryAll()) из yii\db\Command для выполнения SQL запроса и извлечения данных.

                Иногда вы можете захотеть увидеть или использовать SQL запрос построенный из объекта yii\db\Query. Этой цели можно добиться с помощью следующего кода:
                    $command = (new \yii\db\Query())
                        ->select(['id', 'email'])
                        ->from('user')
                        ->where(['last_name' => 'Smith'])
                        ->limit(10)
                        ->createCommand();
                        
                    // показать SQL запрос
                    echo $command->sql;
                    // показать привязываемые параметры
                    print_r($command->params);

                    // возвращает все строки запроса
                    $rows = $command->queryAll();

            Индексация результатов запроса:
                При вызове all() возвращается массив строк индексированный последовательными целыми числами. Иногда вам может потребоваться индексировать его по-другому, 
                например, сделать индекс по указанному столбцу или значением выражения. Вы можете реализовать такое поведение через вызов indexBy() перед вызовом all().
                
                или для индексации по значению выражения, передайте анонимную функцию в метод indexBy():
                    $query = (new \yii\db\Query())
                        ->from('user')
                        ->indexBy(function ($row) {
                            return $row['id'] . $row['username'];
                        })->all();

                Анонимная функция должна принимать параметр $row, который содержит текущую строку запроса и должна вернуть скалярное значение, 
                которое будет использоваться как значение индекса для текущей строки.

            Пакетная выборка:
                При работе с большими объемами данных, методы наподобие yii\db\Query::all() не подходят, потому что они требуют загрузки всех данных в память. 
                Чтобы сохранить требования к памяти минимальными, Yii предоставляет поддержку так называемых пакетных выборок. 
                Пакетная выборка делает возможным курсоры данных и выборку данных пакетами.

                Пакетная выборка может использоваться следующим образом:

                    use yii\db\Query;

                    $query = (new Query())
                        ->from('user')
                        ->orderBy('id');

                    foreach ($query->batch() as $users) {
                        // $users это массив из 100 или менее строк из таблицы пользователей
                    }

                    // или если вы хотите перебрать все строки по одной
                    foreach ($query->each() as $user) {
                        // $user представляет одну строку из выборки
                    }

                Метод yii\db\Query::batch() и yii\db\Query::each() возвращает объект yii\db\BatchQueryResult, который реализует интерфейс Iterator и 
                может использоваться в конструкции foreach. Во время первой итерации будет выполнен SQL запрос к базе данных. 
                Данные будут выбираться пакетами в следующих итерациях. По умолчанию, размер пакета имеет размер 100, то есть при каждой выборке будет выбираться по 100 строк.
                Вы можете изменить размер пакета, передав первый параметр в метод batch() или each().

                По сравнению с yii\db\Query::all(), пакетная выборка загружает только по 100 строк данных за раз в память. 
                Если вы обрабатываете данные и затем сразу выбрасываете их, пакетная выборка может помочь уменьшить использование памяти.

                Если указать индексный столбец через yii\db\Query::indexBy(), в пакетной выборке индекс будет сохраняться. 
                Например,
                    $query = (new \yii\db\Query())
                        ->from('user')
                        ->indexBy('username');

                    foreach ($query->batch() as $users) {
                        // $users индексируется по столбцу "username"
                    }

                    foreach ($query->each() as $username => $user) {
                        // ...
                    }
    Active Record
    -------------
        Active Record — мощный способ доступа и манипулирования данными БД в объектно-ориентированном стиле. 
        Active Record обеспечивает объектно-ориентированный интерфейс для доступа и манипулирования данными, хранящимися в базах данных. 
        Класс Active Record соответствует таблице в базе данных, объект Active Record соответствует строке этой таблицы, 
        а атрибут объекта Active Record представляет собой значение отдельного столбца строки. 
        Вместо непосредственного написания SQL-выражений вы сможете получать доступ к атрибутам Active Record и вызывать методы Active Record для доступа и 
        манипулирования данными, хранящимися в таблицах базы данных.

        Объявление классов Active Record:
        ---------------------------------
            Для начала объявите свой собственный класс, унаследовав класс yii\db\ActiveRecord.

            Настройка имени таблицы:
                Метод tableName() получает имя таблицы из имени класса с помощью yii\helpers\Inflector::camel2id().
                Если таблица не названа соответственно, вы можете переопределить данный метод.
                Также может быть применён tablePrefix по умолчанию. Например, если tablePrefix задан как tbl_, Customer преобразуется в tbl_customer, 
                    а OrderItem в tbl_order_item.
                Если имя таблицы указано в формате {{%TableName}}, символ % заменяется префиксом. Например {{%post}} становится {{tbl_post}}. 
                    Фигуриные скобки используются для экранирования в SQL-запросах.

            Классы Active record называются "моделями":
                Объекты Active Record являются моделями. Именно поэтому мы обычно задаём классам Active Record пространство имён app\models 
                    (или другое пространство имён, предназначенное для моделей).
                    Т.к. класс yii\db\ActiveRecord наследует класс yii\base\Model, он обладает всеми возможностями моделей, такими как атрибуты, 
                    правила валидации, способы сериализации данных и т.д.

        Подключение к базам данных:
        ---------------------------
            По умолчанию Active Record для доступа и манипулирования данными БД использует компонент приложения db в качестве компонента DB connection.
            Если вы хотите использовать для подключения к базе данных другой компонент подключения, отличный от db, вам нужно переопределить метод getDb():
                class Customer extends ActiveRecord
                {
                    // ...

                    public static function getDb()
                    {
                        // использовать компонент приложения "db2"
                        return \Yii::$app->db2;  
                    }
                }
        
        Получение данных:
        -----------------
            После объявления класса Active Record вы можете использовать его для получения данных из соответствующей таблицы базы данных. 
            Этот процесс, как правило, состоит из следующих трёх шагов:
                1) Создать новый объект запроса вызовом метода yii\db\ActiveRecord::find();
                2) Настроить объект запроса вызовом методов построения запросов;
                3) Вызвать один из методов получения данных для извлечения данных в виде объектов Active Record.

            Эти шаги очень похожи на работу с построителем запросов. Различие лишь в том, что для создания объекта запроса вместо оператора new используется 
            метод yii\db\ActiveRecord::find(), возвращающий новый объект запроса, являющийся представителем класса yii\db\ActiveQuery.
            Информация: 
                Т.к. класс yii\db\ActiveQuery наследует yii\db\Query, вы можете использовать в нём все методы построения запросов и все методы класса Query 
                как описано в разделе Построитель запросов.
            
            Т.к. извлечение данных по первичному ключу или значениям отдельных столбцов достаточно распространённая задача, Yii предоставляет два коротких метода для 
            её решения:
                yii\db\ActiveRecord::findOne(): возвращает один объект Active Record, заполненный первой строкой результата запроса.
                yii\db\ActiveRecord::findAll(): возвращает массив объектов Active Record, заполненных всеми полученными результатами запроса.

                Оба метода могут принимать параметры в одном из следующих форматов:
                    скалярное значение: значение интерпретируется как первичный ключ, по которому следует искать. 
                        Yii прочитает информацию о структуре базы данных и автоматически определит, какой столбец таблицы содержит первичные ключи.
                    массив скалярных значений: массив интерпретируется как набор первичных ключей, по которым следует искать.
                    ассоциативный массив: ключи массива интерпретируются как названия столбцов, а значения - как содержимое столбцов, которое следует искать. 
                        За подробностями вы можете обратиться к разделу Hash Format

                Внимание: 
                    Если вам нужно передать в эти методы данные, полученные от пользователя, убедитесь что передаваемое значение – это скаляр, 
                    а если необходимо указать условия в формате массива – убедитесь, что пользовательские данные не могут изменить структуру этого массива.

                Примечание: 
                    Ни метод yii\db\ActiveRecord::findOne(), ни yii\db\ActiveQuery::one() не добавляет условие LIMIT 1 к генерируемым SQL-запросам. 
                    Если ваш запрос может вернуть много строк данных, вы должны вызвать метод limit(1) явно в целях улучшения производительности, 
                    например: Customer::find()->limit(1)->one().
                Помимо использования методов построения запросов вы можете также писать запросы на "чистом" SQL для получения данных и заполнения ими объектов Active Record. 
                Вы можете делать это посредством метода yii\db\ActiveRecord::findBySql():
                    // возвращает всех неактивных покупателей
                    $sql = 'SELECT * FROM customer WHERE status=:status';
                    $customers = Customer::findBySql($sql, [':status' => Customer::STATUS_INACTIVE])->all();

        Доступ к данным:
        ----------------
            Как сказано выше, получаемые из базы данные заполняют объекты Active Record и каждая строка результата запроса соответствует одному объекту Active Record. 
            Вы можете получить доступ к значениям столбцов с помощью атрибутов этих объектов.

            Примечание: 
                Атрибуты объекта Active Record названы в соответствии с названиями столбцов связной таблицы с учётом регистра. 
                Yii автоматически объявляет для каждого столбца связной таблицы атрибут в Active Record. Вы НЕ должны переопределять какие-либо из этих атрибутов.

            Атрибуты Active Record названы в соответствии с именами столбцов таблицы. Если столбцы вашей таблицы именуются через нижнее подчёркивание, то может оказаться, 
            что вам придётся писать PHP-код вроде этого: $customer->first_name - в нём будет использоваться нижнее подчёркивание для разделения слов в названиях атрибутов. 
            Если вы обеспокоены единообразием стиля кодирования, вам придётся переименовать столбцы вашей таблицы соответствующим образом 
            (например, назвать столбцы в стиле camelCase).

            Преобразование данных:
                https://www.yiiframework.com/doc/guide/2.0/ru/db-active-record#data-transformation

            Получение данных в виде массива:
                Несмотря на то, что получение данных в виде Active Record объектов является удобным и гибким, этот способ не всегда подходит при получении 
                большого количества данных из-за больших накладных расходов памяти. В этом случае вы можете получить данные в виде PHP-массива, 
                используя перед выполнением запроса метод asArray():
                    // возвращает всех покупателей
                    // каждый покупатель будет представлен в виде ассоциативного массива
                    $customers = Customer::find()
                        ->asArray()
                        ->all();

                Примечание: В то время как этот способ бережёт память и улучшает производительность, он ближе к низкому слою абстракции базы данных и вы 
                потеряете многие возможности Active Record. Важное отличие заключается в типах данных значений столбцов. Когда вы получаете данные в 
                виде объектов Active Record, значения столбцов автоматически приводятся к типам, соответствующим типам столбцов; с другой стороны, 
                когда вы получаете данные в массивах, значения столбцов будут строковыми (до тех пор, пока они являются результатом работы PDO-слоя без какой-либо обработки), 
                несмотря на настоящие типы данных соответствующих столбцов.

            Пакетное получение данных:
                В главе Построитель запросов мы объясняли, что вы можете использовать пакетную выборку для снижения расходов памяти при получении большого количества данных из базы. 
                Вы можете использовать такой же подход при работе с Active Record. 
                Например:
                    // получить 10 покупателей одновременно
                    foreach (Customer::find()->batch(10) as $customers) {
                        // $customers - это массив, в котором находится 10 или меньше объектов класса Customer
                    }

                    // получить одновременно десять покупателей и перебрать их одного за другим
                    foreach (Customer::find()->each(10) as $customer) {
                        // $customer - это объект класса Customer
                    }

                    // пакетная выборка с жадной загрузкой
                    foreach (Customer::find()->with('orders')->each() as $customer) {
                        // $customer - это объект класса Customer
                    }

        Сохранение данных:
        ------------------
            Используя Active Record, вы легко можете сохранить данные в базу данных, осуществив следующие шаги:
                1) Подготовьте объект Active Record;
                2) Присвойте новые значения атрибутам Active Record;
                3) Вызовите метод yii\db\ActiveRecord::save() для сохранения данных в базу данных.

                $customer->save();

            Метод save() может вставить или обновить строку данных в зависимости от состояния Active Record объекта. Если объект создан с помощью оператора new, 
            вызов метода save() приведёт к вставке новой строки данных; если объект был получен с помощью запроса на получение данных, вызов save() обновит строку таблицы, 
            соответствующую объекту Active Record.
            Вы можете различать два состояния Active Record объекта с помощью проверки значения его свойства isNewRecord. Это свойство также используется внутри метода save()
            как показано ниже:
                public function save($runValidation = true, $attributeNames = null)
                {
                    if ($this->getIsNewRecord()) {
                        return $this->insert($runValidation, $attributeNames);
                    } else {
                        return $this->update($runValidation, $attributeNames) !== false;
                    }
                }
            Подсказка: Вы можете вызвать insert() или update() непосредственно, чтобы вставить или обновить строку данных в таблице.

            Валидация данных:
                Т.к. класс yii\db\ActiveRecord наследует класс yii\base\Model, он обладает такими же возможностями валидации данных. 
                Вы можете объявить правила валидации переопределив метод rules() и осуществлять валидацию данных посредством вызовов метода validate().

                Подсказка: 
                    Если вы уверены, что ваши данные не требуют валидации (например, данные пришли из доверенного источника), вы можете вызвать save(false), 
                    чтобы пропустить валидацию.

            Массовое присваивание:
                Как и обычные модели, объекты Active Record тоже обладают возможностью массового присваивания. Как будет показано ниже, используя эту возможность, 
                вы можете одним PHP выражением присвоить значения множества атрибутов Active Record объекту. Запомните однако, 
                что только безопасные атрибуты могут быть массово присвоены.
                    $values = [
                        'name' => 'James',
                        'email' => 'james@example.com',
                    ];

                    $customer = new Customer();

                    $customer->attributes = $values;
                    $customer->save();

            Обновление счётчиков:
                Распространённой задачей является инкремент или декремент столбца в таблице базы данных. Назовём такие столбцы столбцами-счётчиками. 
                Вы можете использовать метод updateCounters() для обновления одного или нескольких столбцов-счётчиков. Например:
                    $post = Post::findOne(100);

                    // UPDATE `post` SET `view_count` = `view_count` + 1 WHERE `id` = 100
                    $post->updateCounters(['view_count' => 1]);

                Примечание:
                    Если вы используете метод yii\db\ActiveRecord::save() для обновления столбца-счётчика, вы можете прийти к некорректному результату, т.к. вполне вероятно, 
                    что этот же счётчик был сохранён сразу несколькими запросами, которые читают и записывают этот же столбец-счётчик.

            Dirty-атрибуты:
                Когда вы вызываете save() для сохранения Active Record объекта, сохраняются только dirty-атрибуты. Атрибут считается dirty-атрибутом, 
                если его значение было изменено после чтения из базы данных или же он был сохранён в базу данных совсем недавно. 
                Заметьте, что валидация данных осуществляется независимо от того, имеются ли dirty-атрибуты в объекте Active Record или нет.

                Active Record автоматически поддерживает список dirty-атрибутов. Это достигается за счёт хранения старых значений атрибутов и сравнения их с новыми. 
                Вы можете вызвать метод yii\db\ActiveRecord::getDirtyAttributes() для получения текущего списка dirty-атрибутов. 
                Вы также можете вызвать yii\db\ActiveRecord::markAttributeDirty(), чтобы явно пометить атрибут в качестве dirty-атрибута.

                Если вам нужны значения атрибутов, какими они были до их изменения, вы можете вызвать getOldAttributes() или getOldAttribute().
                
                Примечание: 
                    Сравнение старых и новых значений будет осуществлено с помощью оператора ===, так что значение будет считаться dirty-значением даже в том случае, 
                    если оно осталось таким же, но изменило свой тип. Это часто происходит, когда модель получает пользовательский ввод из HTML-форм, 
                    где каждое значение представлено строкой. Чтобы убедиться в корректности типа данных, например для целых значений, 
                    вы можете применить фильтрацию данных: ['attributeName', 'filter', 'filter' => 'intval'].

            Значения атрибутов по умолчанию:
                Некоторые столбцы ваших таблиц могут иметь значения по умолчанию, объявленные в базе данных. Иногда вы можете захотеть предварительно заполнить этими значениями вашу 
                веб-форму, которая соответствует Active Record объекту. Чтобы избежать повторного указания этих значений, вы можете вызвать метод loadDefaultValues() 
                для заполнения соответствующих Active Record атрибутов значениями по умолчанию, объявленными в базе данных:
                    $customer = new Customer();
                    $customer->loadDefaultValues();
                    // $customer->xyz получит значение по умолчанию, которое было указано при объявлении столбца "xyz"

            Приведение типов атрибутов:
                https://www.yiiframework.com/doc/guide/2.0/ru/db-active-record#attributes-typecasting

            Обновление нескольких строк данных:
                Методы, представленные выше, работают с отдельными Active Record объектами, инициируя вставку или обновление данных для отдельной строки таблицы. 
                Вместо них для обновления нескольких строк одновременно можно использовать метод updateAll(), который является статическим.
                    // UPDATE `customer` SET `status` = 1 WHERE `email` LIKE `%@example.com%`
                    Customer::updateAll(['status' => Customer::STATUS_ACTIVE], ['like', 'email', '@example.com']);
                Подобным образом можно использовать метод updateAllCounters() для обновления значений столбцов-счётчиков в нескольких строках одновременно.
                    // UPDATE `customer` SET `age` = `age` + 1
                    Customer::updateAllCounters(['age' => 1]);

        Удаление данных:
        ----------------
            Для удаления одной отдельной строки данных сначала получите Active Record объект, соответствующий этой строке, а затем вызовите метод yii\db\ActiveRecord::delete().
                $customer = Customer::findOne(123);
                $customer->delete();

                Вы можете вызвать yii\db\ActiveRecord::deleteAll() для удаления всех или нескольких строк данных одновременно. Например:
                    Customer::deleteAll(['status' => Customer::STATUS_INACTIVE]);
                Примечание: 
                    будьте очень осторожны, используя метод deleteAll(), потому что он может полностью удалить все данные из вашей таблицы, 
                    если вы сделаете ошибку при указании условий удаления.

        Жизненные циклы Active Record:
        ------------------------------
            Жизненный цикл создания нового объекта
                Когда создаётся новый объект Active Record с помощью оператора new, следующий жизненный цикл имеет место:
                    Вызывается конструктор класса;
                    Вызывается init(): инициируется событие EVENT_INIT.

            Жизненный цикл получения данных
                Когда происходит получение данных посредством одного из методов получения данных, каждый вновь создаваемый объект Active Record при заполнении данными проходит следующий жизненный цикл:
                    Вызывается конструктор класса.
                    Вызывается init(): инициируется событие EVENT_INIT.
                    Вызывается afterFind(): инициируется событие EVENT_AFTER_FIND.

            Жизненный цикл сохранения данных
                Когда вызывается метод save() для вставки или обновления объекта Active Record, следующий жизненный цикл имеет место:
                    Вызывается beforeValidate(): инициируется событие EVENT_BEFORE_VALIDATE. Если метод возвращает false или свойство события yii\base\ModelEvent::$isValid равно false, оставшиеся шаги не выполняются.
                    Осуществляется валидация данных. Если валидация закончилась неудачей, после 3-го шага остальные шаги не выполняются.
                    Вызывается afterValidate(): инициируется событие EVENT_AFTER_VALIDATE.
                    Вызывается beforeSave(): инициируется событие EVENT_BEFORE_INSERT или событие EVENT_BEFORE_UPDATE. Если метод возвращает false или свойство события yii\base\ModelEvent::$isValid равно false, оставшиеся шаги не выполняются.
                    Осуществляется фактическая вставка или обновление данных в базу данных;
                    Вызывается afterSave(): инициируется событие EVENT_AFTER_INSERT или событие EVENT_AFTER_UPDATE.

            Жизненный цикл удаления данных
                Когда вызывается метод delete() для удаления объекта Active Record, следующий жизненный цикл имеет место:
                    Вызывается beforeDelete(): инициируется событие EVENT_BEFORE_DELETE. Если метод возвращает false или свойство события yii\base\ModelEvent::$isValid равно false, остальные шаги не выполняются.
                    Осуществляется фактическое удаление данных из базы данных.
                    Вызывается afterDelete(): инициируется событие EVENT_AFTER_DELETE.

            Примечание: Вызов следующих методов НЕ инициирует ни один из вышеприведённых жизненных циклов:
                yii\db\ActiveRecord::updateAll()
                yii\db\ActiveRecord::deleteAll()
                yii\db\ActiveRecord::updateCounters()
                yii\db\ActiveRecord::updateAllCounters()

        Работа с транзакциями:
        ----------------------
            https://www.yiiframework.com/doc/guide/2.0/ru/db-active-record#transactional-operations
            
            Есть два способа использования транзакций при работе с Active Record.
                1) явно заключить все вызовы методов Active Record в блок транзакции
                    $customer = Customer::findOne(123);

                    Customer::getDb()->transaction(function($db) use ($customer) {
                        $customer->id = 200;
                        $customer->save();
                        // ...другие операции с базой данных...
                    });
                    // или по-другому

                    $transaction = Customer::getDb()->beginTransaction();
                    try {
                        // ...операции с базой данных...
                        $transaction->commit();
                    } catch(\Throwable $e) {
                        $transaction->rollBack();
                        throw $e;
                    }
                2) второй способ заключается в том, чтобы перечислить операции с базой данных, которые требуют тразнакционного выполнения, 
                    в методе yii\db\ActiveRecord::transactions().
                        class Customer extends ActiveRecord
                        {
                            public function transactions()
                            {
                                return [
                                    'admin' => self::OP_INSERT,
                                    'api' => self::OP_INSERT | self::OP_UPDATE | self::OP_DELETE,
                                    // вышеприведённая строка эквивалентна следующей:
                                    // 'api' => self::OP_ALL,
                                ];
                            }
                        }
                    Метод yii\db\ActiveRecord::transactions() должен возвращать массив, ключи которого являются именами сценариев, а значения соответствуют операциям, 
                    которые должны быть выполнены с помощью транзакций. Вы должны использовать следующие константы для обозначения различных операций базы данных:
                        OP_INSERT: операция вставки, осуществляемая с помощью метода insert();
                        OP_UPDATE: операция обновления, осуществляемая с помощью метода update();
                        OP_DELETE: операция удаления, осуществляемая с помощью метода delete().
                    Используйте операторы | для объединения вышеприведённых констант при обозначении множества операций. 
                    Вы можете также использовать вспомогательную константу OP_ALL, чтобы обозначить одной константой все три вышеприведённые операции.

        Оптимистическая блокировка:
        ---------------------------
            https://www.yiiframework.com/doc/guide/2.0/ru/db-active-record#optimistic-locks
            Оптимистическая блокировка - это способ предотвращения конфликтов, которые могут возникать, когда одна и та же строка данных обновляется несколькими пользователями. 
            Например, пользователь A и пользователь B одновременно редактируют одну и ту же wiki-статью. После того, как пользователь 
            A сохранит свои изменения, пользователь B нажимает на кнопку "Сохранить" в попытке также сохранить свои изменения. 
            Т.к. пользователь B работал с фактически-устаревшей версией статьи, было бы неплохо иметь способ предотвратить сохранение его варианта статьи и 
            показать ему некоторое сообщение с подсказкой о том, что произошло.

            Для использования оптимистической блокировки:
                1) Создайте столбец в таблице базы данных, ассоциированной с классом Active Record, для сохранения номера версии каждой строки данных. 
                    Столбец должен быть типа big integer (в Mysql это будет BIGINT DEFAULT 0).
                2) Переопределите метод yii\db\ActiveRecord::optimisticLock() таким образом, чтобы он возвращал название этого столбца.
                    В веб-форме, которая принимает пользовательский ввод, добавьте скрытое поле для сохранения текущей версии обновляемой строки. 
                    Убедитесь, что для вашего атрибута с версией объявлены правила валидации, и валидация проходит успешно.
                3) В действии контроллера, которое занимается обновлением строки данных с использованием Active Record, оберните в блок try...catch код и 
                    перехватывайте исключение yii\db\StaleObjectException. Реализуйте необходимую бизнес-логику (например, возможность слияния изменений, подсказку о том, 
                    что данные устарели) для разрешения возникшего конфликта.

        Работа со связными данными:
        ---------------------------
            Помимо работы с отдельными таблицами баз данных, Active Record также имеет возможность объединять связные данные, 
            что делает их легко-доступными для получения через основные объекты данных. 
            Например, данные покупателя связаны с данными заказов, потому что один покупатель может осуществить один или несколько заказов. 
            С помощью объявления этой связи вы можете получить возможность доступа к информации о заказе покупателя с помощью выражения $customer->orders, 
            которое возвращает информацию о заказе покупателя в виде массива объектов класса Order, которые являются Active Record объектами.

            Объявление связей:
                https://www.yiiframework.com/doc/guide/2.0/ru/db-active-record#declaring-relations
                Для работы со связными данными посредством Active Record вы прежде всего должны объявить связи в классе Active Record. 
                Эта задача решается простым объявлением методов получения связных данных для каждой интересующей вас связи как показано ниже:
                    class Customer extends ActiveRecord
                    {
                        public function getOrders()
                        {
                            return $this->hasMany(Order::class, ['customer_id' => 'id']);
                        }
                    }

                    class Order extends ActiveRecord
                    {
                        public function getCustomer()
                        {
                            return $this->hasOne(Customer::class, ['id' => 'customer_id']);
                        }
                    }
                В вышеприведённом коде мы объявили связь orders для класса Customer и связь customer для класса Order.
                Каждый метод получения связных данных должен быть назван в формате getXyz. Мы называем xyz (первая буква в нижнем регистре) именем связи. 
                Помните, что имена связей чувствительны к регистру.
                При объявлении связи, вы должны указать следующую информацию:
                    - кратность связи: указывается с помощью вызова метода hasMany() или метода hasOne(). 
                        В вышеприведённом примере вы можете легко увидеть в объявлениях связей, что покупатель может иметь много заказов в то время, 
                        как заказ может быть сделан лишь одним покупателем.
                    - название связного Active Record класса: указывается в качестве первого параметра для метода hasMany() или для метода hasOne(). 
                        Рекомендуется использовать код Xyz::class, чтобы получить строку с именем класса, при этом вы сможете воспользоваться возможностями авто-дополнения кода, 
                        встроенного в IDE, а также получите обработку ошибок на этапе компиляции.
                    - связь между двумя типами данных: указываются столбцы с помощью которых два типа данных связаны. Значения массива - это столбцы основного объекта данных 
                        (представлен классом Active Record, в котором объявляется связь), в то время как ключи массива - столбцы связанных данных.
                    - Есть простой способ запомнить это правило: как вы можете увидеть в примере выше, столбец связной Active Record указывается сразу после указания 
                        самого класса Active Record. Вы видите, что customer_id - это свойство класса Order, а id - свойство класса Customer.

                Внимание: Имя связи relation зарезервировано. Его использование приведёт к ошибке ArgumentCountError.

            Доступ к связным данным:
                https://www.yiiframework.com/doc/guide/2.0/ru/db-active-record#accessing-relational-data
                После объявления связей вы можете получать доступ к связным данным с помощью имён связей. Это происходит таким же образом, каким осуществляется доступ к 
                свойству объекта объявленному с помощью метода получения связных данных. По этой причине, мы называем его свойством связи. Например:
                    // SELECT * FROM `customer` WHERE `id` = 123
                    $customer = Customer::findOne(123);

                    // SELECT * FROM `order` WHERE `customer_id` = 123
                    // $orders - это массив объектов Order
                    $orders = $customer->orders;
                
                Информация: 
                    когда вы объявляете связь с названием xyz посредством геттера getXyz(), у вас появляется возможность доступа к свойству xyz подобно свойству объекта. 
                    Помните, что название связи чувствительно к регистру.

                Если связь объявлена с помощью метода hasMany(), доступ к свойству связи вернёт массив связных объектов Active Record; если связь объявлена с помощью метода hasOne(), 
                доступ к свойству связи вернёт связный Active Record объект или null, если связные данные не найдены.

                Когда вы запрашиваете свойство связи в первый раз, выполняется SQL-выражение как показано в примере выше. Если то же самое свойство запрашивается вновь, 
                будет возвращён результат предыдущего SQL-запроса без повторного выполнения SQL-выражения. Для принудительного повторного выполнения SQL-запроса, 
                вы можете удалить свойство связи с помощью операции: unset($customer->orders).

                Примечание: 
                    Несмотря на то, что эта концепция выглядит похожей на концепцию свойств объектов, между ними есть важное различие. 
                    Для обычных свойств объектов значения свойств имеют тот же тип, который возвращает геттер. 
                    Однако метод получения связных данных возвращает объект yii\db\ActiveQuery, в то время как доступ к свойству связи возвращает объект yii\db\ActiveRecord 
                    или массив таких объектов. `php $customer->orders; // массив объектов Order $customer->getOrders(); // объект ActiveQuery ` 
                    Это полезно при тонкой настройке запросов к связным данным, что будет описано в следующем разделе.

            Динамические запросы связных данных:
                https://www.yiiframework.com/doc/guide/2.0/ru/db-active-record#dynamic-relational-query
                Т.к. метод получения связных данных возвращает объект запроса yii\db\ActiveQuery, вы можете в дальнейшем перед его отправкой в базу данных настроить 
                этот запрос, используя методы построения запросов. Например:
                    $customer = Customer::findOne(123);

                    // SELECT * FROM `order` WHERE `customer_id` = 123 AND `subtotal` > 200 ORDER BY `id`
                    $orders = $customer->getOrders()
                        ->where(['>', 'subtotal', 200])
                        ->orderBy('id')
                        ->all();

            Связывание посредством промежуточной таблицы:
                https://www.yiiframework.com/doc/guide/2.0/ru/db-active-record#junction-table
                При проектировании баз данных, когда между двумя таблицами имеется кратность связи many-to-many, обычно вводится промежуточная таблица. 
                Например, таблицы order и item могут быть связаны посредством промежуточной таблицы с названием order_item. Один заказ будет соотноситься с несколькими товарами, 
                в то время как один товар будет также соотноситься с несколькими заказами.
                При объявлении подобных связей вы можете пользоваться методом via() или методом viaTable() для указания промежуточной таблицы. 
                Разница между методами via() и viaTable() заключается в том, что первый метод указывает промежуточную таблицу с помощью названия связи, 
                в то время как второй метод непосредственно указывает промежуточную таблицу. Например:
                    class Order extends ActiveRecord
                    {
                        public function getItems()
                        {
                            return $this->hasMany(Item::class, ['id' => 'item_id'])
                                ->viaTable('order_item', ['order_id' => 'id']);
                        }
                    }

                или по-другому:
                    class Order extends ActiveRecord
                    {
                        public function getOrderItems()
                        {
                            return $this->hasMany(OrderItem::class, ['order_id' => 'id']);
                        }

                        public function getItems()
                        {
                            return $this->hasMany(Item::class, ['id' => 'item_id'])
                                ->via('orderItems');
                        }
                    }

                Использовать связи, объявленные с помощью промежуточных таблиц, можно точно также, как и обычные связи. Например:
                    // SELECT * FROM `order` WHERE `id` = 100
                    $order = Order::findOne(100);

                    // SELECT * FROM `order_item` WHERE `order_id` = 100
                    // SELECT * FROM `item` WHERE `item_id` IN (...)
                    // возвращает массив объектов Item
                    $items = $order->items;

            Отложенная и жадная загрузка:
                https://www.yiiframework.com/doc/guide/2.0/ru/db-active-record#lazy-eager-loading
                



    Миграции баз данных
    -------------------
        https://www.yiiframework.com/doc/guide/2.0/ru/db-migrations#migracii-baz-dannyh
        В ходе разработки и ведения баз данных приложений, которые управляют данными, структуры используемых баз данных развиваются, как и исходный код приложений. 
        Например, при разработке приложения, в будущем может оказаться необходимой новая таблица; уже после того, как приложение будет развернуто в рабочем режиме (продакшене), 
        также может быть обнаружено, что для повышения производительности запросов должен быть создан определённый индекс; и так далее. 
        В связи с тем, что изменение структуры базы данных часто требует изменение исходного кода, yii поддерживает так называемую возможность миграции баз данных, 
        которая позволяет отслеживать изменения в базах данных при помощи терминов миграции баз данных, которые являются системой контроля версий вместе с исходным кодом.

========================================================================================================================================================
Представления (виды)
--------------------
    Это обыкновенный скрипты, которые используются для формирования тела ответа.
    Виды управляются компонентом приложения view, который содержит часто используемые методы для упорядочивания видов и их рендеринга.
    Когда метод render() вызывается в действии, он будет искать PHP файл с именем вида views/ControllerID/ViewName.php.

    Информация: 
        Новая страница использует ту же шапку и футер, что и другие страницы, потому что метод render() автоматически вставляет результат представления в, 
        так называемый, макет views/layouts/main.php.

    Внутри вида, вы можете использовать $this, которое представляет собой компонент вид, управляющий этим шаблоном и обеспечивающий его рендеринг.

    Совет: 
        Переданные переменные могут быть перечислены в блоке комментария в начале скрипта, чтобы их смогли распознать IDE. 
        К тому же, это хороший способ добавления документации в вид.
        Пример:
            после use
            /* @var $this yii\web\View */
            /* @var $form yii\widgets\ActiveForm */
            /* @var $model app\models\LoginForm */

    Безопасность:
        При создании видов, которые генерируют HTML страницы, важно кодировать и/или фильтровать данные, которые приходят от пользователей перед тем как их показывать.
        В противном случае ваше приложение может стать жертвой атаки типа межсайтовый скриптинг.
        Используйте для показа обыного текста yii\helpers\Html::encode()
        Используйте для показа HTML содержимого yii\helpers\HtmlPurifier
        Подсказка:
            Несмотря на то, что HTMLPurifier отлично справляется с тем, чтобы сделать вывод безопасным, работает он довольно медленно.
            Если от приложения требуется высокая производительность, рассмотрите возможность кэширования отфильтрованного результата.
        
    Организация видов:
        - Виды, которые рендерятся из контроллера, по умолчанию должны располагаться в папке @app/views/ControllerID, где ControllerID это ID контроллера.
        - Виды, которые рендерятся из виджетов, должны располагаться в ПутьВиджета/views, где ПутьВиджета - это папка, которая содержит класс виджета.
        - С видами, которые рендерятся из других объектов рекомендуется поступать по той же схеме, что и с видами виджетов.
        
        В контроллерах и виджетах вы можете изменить папки видов по умолчанию, переопределив метод yii\base\ViewContextInterface::getViewPath().

    Рендеринг видов:
        Рендеринг в контроллерах:
            Внутри контроллеров можно вызывать следующие методы рендеринга видов:
                1) render(): рендерит именованный вид и применяет шаблон к результату рендеринга.
                2) renderPartial(): рендерит именованный вид без шаблона.
                3) renderAjax(): рендерит именованный вид без шаблона, и добавляет все зарегистрированные JS/CSS скрипты и стили. 
                    Обычно этот метод применяется для рендеринга результата AJAX запроса.
                4) renderFile(): рендерит вид, заданный как путь к файлу или алиас.

        Рендеринг в виджетах:
            1) render(): рендерит именованный вид.
            2) renderFile(): рендерит вид, заданный как путь файла или алиас.

        Рендеринг в видах:
            Вы можете рендерить вид внутри другого вида используя методы, которые предоставляет компонент вида:
                1) render(): рендерит именованный вид.
                2) renderAjax(): рендерит именованный вид и добавляет зарегистрированные JS/CSS скрипты и стили. 
                    Обычно используется для рендеринга результата AJAX запроса.
                3) renderFile(): рендерит вид, заданный как путь к файлу или алиас.

        Рендеринг в других местах:
            Вы может получить доступ к виду как компоненту приложения вот так: Yii::$app->view, а затем вызвать вышеупомянутые методы, чтобы отрендерить вид. 
            Например:
                // показывает файл "@app/views/site/license.php"
                echo \Yii::$app->view->renderFile('@app/views/site/license.php');

        Именованные виды:
            При рендеринге вида, вы можете указать нужный вид, используя как имя вида, так и путь к файлу/алиас.
            В большинстве случаев вы будете использовать первый вариант, т.к. он более нагляден и гибок.
            Мы называем виды, которые были вызваны с помощью сокращенного имени именованные виды.

            Имя вида преобразуется в соответствующий ему путь файла в соответствии со следующими правилами:
                - Имя вида можно указывать без расширения. В таком случае в качестве расширения будет использоваться .php
                - Если имя вида начинается с двойного слеша //, соответствующий ему путь будет @app/views/ViewName.
                - Если имя вида начинается с одинарного слеша /, то вид будет искаться в папке видов по умолчанию текущего модуля .
                    Если активного модуля на данный момент нет, будет использована папка видов приложения по умолчанию, т.е. вид будет искаться в @app/views
                - Если вид рендеринтся с помощью контекста и контекст реализует интерфейс yii\base\ViewContextInterface, 
                    путь к виду образуется путем присоединения пути видов контекста к имени вида.
                    В основном это применимо к видам, которые рендерятся из контроллеров и виджетов. 
                    Например, about будет преобразован в @app/views/site/about.php если контекстом является контроллер SiteController.
                - Если вид рендерится из другого вида, папка, в которой находится текущий вид будет добавлена к пути вложенного вида. 
                    Например, item будет преобразован в @app/views/post/item если он рендерится из вида @app/views/post/index.php.

        Доступ к данным из видов:
            Данные можно передавать в вид явно или подгружать их динамически, обращаясь к контексту из вида.
            Передавая данные через второй параметр методов рендеринга вида, вы явно передаете данные в вид. 
            Данные должны быть представлены как обычный массив: ключ-значение. 
            При рендеринге вида, php вызывает встроенную функцию PHP extract() на переданном массиве, 
            чтобы переменные из массива "распаковались" в переменные вида.

            Другой подход, подход контекстного доступа, извлекает данные из компонента вида или других объектов, доступных в виде 
            (например через глобальный контейнер Yii::$app). Внутри вида вы можете вызывать объект контроллера таким образом: $this->context (см пример снизу), 
            и, таким образом, получить доступ к его свойствам и методам, например, как указано в примере, вы можете получить ID контроллера:
                ID контроллера: <?= $this->context->id ?>
            Явная передача данных в вид обычно более предпочтительна, т.к. она делает виды независимыми от контекста. 
            Однако, у нее есть недостаток - необходимость каждый раз вручную строить массив данных, что может быть довольно утомительно и привести к ошибкам, 
            если вид рендерится в разных местах.

        Передача данных между видами:
            Компонент вида имеет свойство params, которое вы можете использовать для обмена данными между видами.
            Например, в виде about вы можете указать текущий сегмент хлебных крошек с помощью следующего кода.
                $this->params['breadcrumbs'][] = 'О нас';

                Затем, в шаблоне, который также является видом, вы можете отобразить хлебные крошки используя данные, переданные через params.

                <?= yii\widgets\Breadcrumbs::widget([
                    'links' => isset($this->params['breadcrumbs']) ? $this->params['breadcrumbs'] : [],
                ]) ?>

        Шаблоны:
            Шаблоны - особый тип видов, которые представляют собой общие части разных видов.
            Создание шаблонов:
                Поскольку шаблоны это виды, их можно создавать точно так же, как и обычные виды. 
                По умолчанию шаблоны хранятся в папке @app/views/layouts. 
                Шаблоны, которые используются в конкретном модуле, хранятся в подпапке views/layouts папки модуля. 
                Вы можете изменить папку шаблонов по умолчанию, используя свойство yii\base\Module::$layoutPath приложения или модулей.
                В каждом шаблое доступен 
                    /* @var $this yii\web\View */ переменная $this - представляет собой вид компонент, как и в обычных видах
                    /* @var $content string */ переменная $content - содержит результат рендеринга вида, который рендерится при вызове метода render() в контроллерах

                Большинство шаблонов вызывают методы:
                    - beginPage(): Этот метод нужно вызывать в самом начале шаблона. Он вызывает событие EVENT_BEGIN_PAGE, которое происходит при начале обработки страницы.
                    - endPage(): Этот метод нужно вызывать в конце страницы. Он вызывает событие EVENT_END_PAGE . Оно указывает на обработку конца страницы.
                    - head(): Этот метод нужно вызывать в <head> секции страницы html. Он генерирует метку, которая будет заменена зарегистрированным ранее кодом HTML (тэги link, мета тэги), когда рендеринг страницы будет завершен.
                    - beginBody(): Этот метод нужно вызывать в начале секции <body>. Он вызывает событие EVENT_BEGIN_BODY и генерирует метку, которая будет заменена зарегистрированным HTML кодом (например, Javascript'ом), который нужно разместить в начале <body> страницы.
                    - endBody(): Этот метод нужно вызывать в конце секции <body>. Он вызывает событие EVENT_END_BODY и генерирует метку, которая будет заменена зарегистрированным HTML кодом (например, Javascript'ом), который нужно разместить в конце <body> страницы.

                Если вы хотите передать данные из вида шаблону необходимо использовать свойство params, которое вы можете использовать для обмена данными между видами.
                    Например, в виде about вы можете указать текущий сегмент хлебных крошек с помощью следующего кода.
                        $this->params['breadcrumbs'][] = 'О нас';
                    Затем, в шаблоне, который также является видом, вы можете отобразить хлебные крошки используя данные, переданные через params.
                        <?= yii\widgets\Breadcrumbs::widget([
                            'links' => isset($this->params['breadcrumbs']) ? $this->params['breadcrumbs'] : [],
                        ]) ?>

                Использование шаблонов:
                    По умолчанию будет использован шаблон @app/views/layouts/main.php
                    Данный шаблон можно переопределить с помощью свойств в контроллере:
                        yii\base\Application::$layout - переопределяет шаблон, который используется по умолчанию всеми контроллерами
                        yii\base\Controller::$layout - переопределяет шаблон в отдельном контроллере

                    Yii определяет какой шаблон использовать для контроллера в два этапа:

                    На первом этапе определяется значение шаблона и контекстный модуль.
                        - Если yii\base\Controller::$layout свойство контроллера отлично от null, используется оно, и модуль контроллера как контекстный модуль.
                        - Если layout равно null (не задано), происходит поиск среди родительских модулей контроллера, 
                        включая само приложение (которое по умолчанию является родительским модулем для контроллеров, не принадлежащих модулям) и находится первый модуль, 
                        свойство layout которого не равно null . Тогда используется найденное значение layout этого модуля и сам модуль в качестве контекста. 
                        - Если такой модуль не найден, значит шаблон применен не будет.

                    На втором этапе определяется сам файл шаблона для рендеринга на основании значения layout и контекстного модуля. Значением layout может быть:
                        - Алиас пути (например, @app/views/layouts/main).
                        - Абсолютный путь (например /main): значение layout начинается со слеша. Будет искаться шаблон из папки шаблонов приложения, по умолчанию это @app/views/layouts.
                        - Относительный путь (например main): Будет искаться шаблон из папки шаблонов контекстного модуля, по умолчанию это views/layouts в папке модуля.
                        - Булево значение false: шаблон не будет применен.

                        Если у значения layout нет расширения, будет использовано расширение по умолчанию - .php.

                Вложенные шаблоны:
                    Вы можете использовать вложенные шаблоны, вызывая beginContent() и endContent() в дочерних шаблонах таким образом:
                        <?php $this->beginContent('@app/views/layouts/base.php'); ?>
                            ...код дочернего шаблона...
                        <?php $this->endContent(); ?>

                Использование блоков:
                    Блоки позволяют "записывать" контент в одном месте, а показывать в другом.
                    Для определения блока вызываются методы beginBlock() и endBlock().
                    После определения, блок доступен через $view->blocks[$blockID], где $blockID - это уникальный ID, который вы присваиваете блоку в начале определения. 
                
                Использование компонентов вида:
                    Компоненты вида дают много возможностей. 
                    Несмотря на то, что существует возможность создавать индивидуальные экземпляры yii\base\View или дочерних классов, 
                    в большинстве случаев используется сам компонент view приложения.
                    
                    Компоненты вида предоставляют широкие возможности по работе с видами, они описаны в отдельных секциях документации:
                        1) темы: позволяет менять темы оформления для сайта.
                        2) кэширование фрагментов: позволяет кэшировать фрагменты веб-страниц.
                        3) работа с клиентскими скриптами: Поддерживает регистрацию и рендеринг CSS и Javascript.
                        4) управление связками: позволяет регистрацию и управление связками клиентского кода.
                        5) альтернативные движки шаблонов: позволяет использовать другие шаблонные движки, такие как Twig, Smarty.
                    
                        Установка заголовков страниц:
                            Чтобы передать заголовок из вида в шаблон, используется свойство title.
                            $this->title = 'Мой заголовок страницы';
                            В шаблоне: <title><?= Html::encode($this->title) ?></title>

                        Регистрация мета-тэгов:
                            Если вы хотите указать, какие мета-тэги генерировать в видах, вы можете вызвать метод yii\web\View::registerMetaTag()
                            Обратите внимание, что при вызове метода yii\web\View::registerMetaTag() несколько раз мета тэги будут регистрироваться каждый раз без проверки на уникальность.
                            Пример: $this->registerMetaTag(['name' => 'keywords', 'content' => 'yii, framework, php']);

                        Регистрация тэгов link:
                            Как и мета тэги, link тэги полезны во многих случаях, как, например, задание уникальной favicon, указание на RSS фид или указание OpenID сервера для авторизации. 
                            С link тэгами можно работать аналогично работе с мета тэгами, вызывая метод yii\web\View::registerLinkTag().
                            Пример:
                                $this->registerLinkTag([
                                    'title' => 'Сводка новостей по Yii',
                                    'rel' => 'alternate',
                                    'type' => 'application/rss+xml',
                                    'href' => 'https://www.yiiframework.com/rss.xml/',
                                ]);

                События в видах:
                    Компонент вида вызывает несколько событий во время рендеринга. 
                    Вы можете задавать обработчики для этих событий чтобы добавлять контент в вид или делать пост-обработку результатов рендеринга до того, 
                    как они будут отправлены конечным пользователям.
                        EVENT_BEFORE_RENDER: вызывается в начале рендеринга файла в контроллере. 
                            Обработчики этого события могут придать атрибуту yii\base\ViewEvent::$isValid значение false, чтобы отменить процесс рендеринга.
                        EVENT_AFTER_RENDER: событие инициируется после рендеринга файла вызовом yii\base\View::afterRender(). 
                            Обработчики события могут получать результат рендеринга через yii\base\ViewEvent::$output и могут изменять это свойство для изменения результата рендеринга.
                        EVENT_BEGIN_PAGE: инициируется вызовом yii\base\View::beginPage() в шаблонах.
                        EVENT_END_PAGE: инициируется вызовом yii\base\View::endPage() в шаблонах.
                        EVENT_BEGIN_BODY: инициируется вызовом yii\web\View::beginBody() в шаблонах.
                        EVENT_END_BODY: инициируется вызовом yii\web\View::endBody() в шаблонах.

                        Например, следующий код вставляет дату в конец body страницы:
                        \Yii::$app->view->on(View::EVENT_END_BODY, function () {
                            echo date('Y-m-d');
                        });

                Рендеринг статических страниц:
                    Статическими страницами мы считаем страницы, которые содержат в основном статические данные и 
                    для формирования которых не нужно строить динамические данные в контроллерах.

                Полезные советы:
                    Виды отвечают за представление данных моделей в формате, понятным конечным пользователям. В целом, виды
                    - должны в основном содержать код, отвечающий за представление, такой как HTML и простой PHP для обхода, форматирования и рендеринга данных.
                    - не должны содержать кода, который производит запросы к БД. Такими запросами должны заниматься модели.
                    - должны избегать прямого обращения к данным запроса, таким как $_GET, $_POST. Разбором запроса должны заниматься контроллеры. Если данные запросов нужны для построения вида, они должны явно передаваться в вид контроллерами.
                    - могут читать свойства моделей, но не должны их изменять.

                    Чтобы сделать виды более управляемыми, избегайте создания видов, которые содержат слишком сложную логику или большое количество кода. 
                    Используйте следующие подходы для их упрощения:
                    - используйте шаблоны для отображения основных секций разметки сайта (верхняя часть (хедер), нижняя часть (футер) и т.п.)
                    - разбивайте сложный вид на несколько видов попроще. Меньшие виды можно рендерить и объединять в больший используя методы рендеринга, описанный в настоящем документе.
                    - создавайте и используйте виджеты как строительный материал для видов.
                    - создавайте и используйте классы-хелперы для изменения и форматирования данных в видах.
    Виджет
    ------
        Виджеты представляют собой многоразовые строительные блоки, используемые в представлениях для создания сложных и настраиваемых элементов 
        пользовательского интерфейса в рамках объектно-ориентированного подхода.
        P.S. (моя заметка) - по простому это helper (мини компонента) для представления.

        yii\base\Widget::widget("массив настроек для инициализации виджета") : возвращает результат его рендеринга
            Создание своего нового виджета:
                Для того, чтобы создать виджет, следует унаследовать класс yii\base\Widget и 
                переопределить при необходимости методы yii\base\Widget::init() и/или yii\base\Widget::run().
            Использование готового виджета:
                Для того, чтобы использовать виджет в представлении, достаточно вызвать метод yii\base\Widget::widget(). 
                Метод принимает массив настроек для инициализации виджета и возвращает результат его рендеринга.

        Так же виджет можно создавать через yii\base\Widget::begin() и yii\base\Widget::end()
            yii\base\Widget::begin() - возвращает экземпляр виджета, который может быть использован в дальнейшем для формирования его внутреннего содержимого.
            yii\base\Widget::end() - завершает виджет

        Информация: 
            В Yii есть множество виджетов, позволяющих быстро строить сложные и динамичные представления. 
            Как вы узнаете позже, разрабатывать новые виджеты очень просто. 
            Многое из представлений можно вынести в виджеты, чтобы использовать это повторно в других местах и упростить тем самым разработку в будущем.

    Ресурсы
    -------
        Ресурс в Yii это файл который может быть задан в Web странице. Это может быть CSS файл, JavaScript файл, изображение или видео файл и т.д. 
        Ресурсы располагаются в Web доступных директориях и обслуживаются непосредственно Web серверами.

        Единица комплекта ресурсов:
        ---------------------------
            Yii управляет ресурсами как единицей комплекта ресурсов. Комплект ресурсов - это простой набор ресурсов расположенных в директории. 
            Когда Вы регистрируете комплект ресурсов в представлении, в отображаемой Web странице включается набор CSS и JavaScript файлов.
        
        Задание Единицы Комплекта Ресурсов 
        ----------------------------------
            yii\web\AssetBundle - комплект ресурсов определяется как PHP класс расширяющийся от yii\web\AssetBundle
            Класс комплекта ресурсов должен быть в состоянии возможности автозагрузки.
            При задании комплекта ресурсов обычно указывается где ресурсы находятся, какие CSS и JavaScript файлы содержит комплект, и как комплект зависит от других комплектов.
            https://www.yiiframework.com/doc/api/2.0/yii-web-assetbundle#$sourcePath-detail - описание свойств AssetBundle
        
        Расположение ресурсов
        ---------------------
            Ресурсы, в зависимости от их расположения, могут быть классифицированы как:
                - исходные ресурсы: файлы ресурсов, расположенные вместе с исходным кодом PHP, которые НЕ могут быть непосредственно доступны через Web. 
                    Для того, чтобы использовать исходные ресурсы на странице, они должны быть скопированы в Web директорию и превратиться в так называемые опубликованные ресурсы. 
                    Этот процесс называется публикацией ресурсов, который более подробно описан ниже
                - опубликованные ресурсы: файлы ресурсов, расположенные в Web директории и, таким образом, могут быть напрямую доступны через Web.
                - внешние ресурсы: файлы ресурсов, расположенные на другом Web сервере, отличного от веб-хостинга вашего приложения.

                Примечание: 
                    Не используйте @webroot/assets как source path. Эта директория по умолчанию используется менеджером ресурсов asset manager для сохранения файлов ресурсов, 
                    опубликованных из их исходного месторасположения. Любое содержимое этой директории расценивается как временное и может быть удалено.

        Зависимости ресурсов
        --------------------
            yii\web\AssetBundle::$depends - зависимость ресурсов в основном указываются через свойство 
            Зависимость между ресурсами - включение нескольких CSS или JavaScript файлов в Web страницу, в определенном порядке, чтобы избежать переопределения при выдаче.

        Параметры ресурсов
        ------------------
            Вы можете задать свойства cssOptions и jsOptions, чтобы настроить путь для включения CSS и JavaScript файлов в страницу. 
            Значения этих свойств будут приняты методами yii\web\View::registerCssFile() и yii\web\View::registerJsFile() соответственно, 
            когда они (методы) вызываются представлением происходит включение CSS и JavaScript файлов.

            Примечание: 
                Параметры, заданные в комплекте класса применяются для каждого CSS/JavaScript-файла в комплекте. 
                Если Вы хотите использовать различные параметры для разных файлов, Вы должны создать раздельные комплекты ресурсов, и использовать 
                одну установку параметров для каждого комплекта.

            По умолчанию, когда комплект ресурсов публикуется, всё содержимое в заданной директории yii\web\AssetBundle::$sourcePath будет опубликовано. 
            Вы можете настроить это поведение, сконфигурировав свойство publishOptions.
            Более сложную логику можно реализовать с помощью переопределения init().
        
        Установка ресурсов Bower и NPM
        ------------------------------
            https://www.yiiframework.com/doc/guide/2.0/ru/structure-assets#bower-npm-assets

        Использование Комплекта Ресурсов
        --------------------------------
            Для использования комплекта ресурсов, зарегистрируйте его в представлении вызвав метод yii\web\AssetBundle::register() : возвращает объект комплекта ресурсов
                use app\assets\AppAsset;
                AppAsset::register($this);  // $this - представляет собой объект представления
            
            Информация: 
                Метод yii\web\AssetBundle::register() возвращает объект комплекта ресурсов, содержащий информацию о публикуемых ресурсах, таких как basePath или baseUrl.

            Когда комплект ресурсов регистрируется в представлении, Yii регистрирует все зависимые от него комплекты ресурсов. 
            И, если комплект ресурсов расположен в директории не доступной из Web, то он будет опубликован в Web директории. 
            Затем, когда представление отображает страницу, сгенерируются теги <link> и <script> для CSS и JavaScript файлов, перечисленных в регистрируемых комплектах. 
            Порядок этих тегов определён зависимостью среди регистрируемых комплектов, и последовательность ресурсов перечислена 
            в yii\web\AssetBundle::$css и yii\web\AssetBundle::$js свойствах.
        
        Динамические Комплекты Ресурсов
        -------------------------------
            https://www.yiiframework.com/doc/guide/2.0/ru/structure-assets#dynamic-asset-bundles

        Настройка Комплектов Ресурсов
        -----------------------------
            https://www.yiiframework.com/doc/guide/2.0/ru/structure-assets#customizing-asset-bundles
            Yii управляет комплектами ресурсов через компонент приложения называемый assetManager, который реализован в yii\web\AssetManager. 
            Путём настройки свойства yii\web\AssetManager::$bundles, возможно настроить поведение комплекта ресурсов.

        Привязка ресурсов
        -----------------
            yii\web\AssetManager::$assetMap
            Ключи assetMap - это имена ресурсов, которые Вы хотите исправить, а значения - это требуемые пути для ресурсов.

        Публикация Ресурсов
        -------------------
            Как уже было сказано выше, если комплект ресурсов располагается в директории которая не доступна из Web, эти ресурсы будут скопированы в Web директорию, 
            когда комплект будет зарегистрирован в представлении. Этот процесс называется публикацией ресурсов, его автоматически выполняет asset manager.
            По умолчанию, ресурсы публикуются в директорию @webroot/assets которая соответствует URL @web/assets. 
            Можно настроить это местоположение сконфигурировав свойства basePath и baseUrl.

            Вместо публикации ресурсов путём копирования файлов, можно рассмотреть использование символических ссылок, 
            если Ваша операционная система или Web сервер это разрешают. Эта функция может быть включена путем установки linkAssets в true.
            return [
                // ...
                'components' => [
                    'assetManager' => [
                        'linkAssets' => true,
                    ],
                ],
            ];
            С конфигурацией, установленной выше, менеджер ресурсов будет создавать символические ссылки на исходные пути комплекта ресурсов когда он будет публиковаться. 
            Это быстрее, чем копирование файлов, а также может гарантировать, что опубликованные ресурсы всегда up-to-date(обновлённые/свежие).

        Перебор Кэша
        ------------
            Для Web приложения запущенного в режиме продакшена, считается нормальной практикой разрешить HTTP кэширование для ресурсов и других статичных источников. 
            Недостаток такой практики в том, что всякий раз, когда изменяется ресурс и разворачивается продакшен, 
            пользователь может по-прежнему использовать старую версию ресурса вследствие HTTP кэширования. 
            Чтобы избежать этого, можно использовать возможность перебора кэша, которая была добавлена в версии 2.0.3, 
            для этого можно настроить yii\web\AssetManager следующим образом:
            return [
                // ...
                'components' => [
                    'assetManager' => [
                        'appendTimestamp' => true,
                    ],
                ],
            ];
            Делая таким образом, к URL каждого опубликованного ресурса будет добавляться временная метка его последней модификации. 
            Например, URL для yii.js может выглядеть как /assets/5515a87c/yii.js?v=1423448645", где параметр v представляет собой временную метку последней 
            модификации файла yii.js. Теперь если изменить ресурс, его URL тоже будет изменен, это означает что клиент получит последнюю версию ресурса.

        Обычное Использование Комплекта Ресурсов
        ----------------------------------------
            Код ядра Yii содержит большое количество комплектов ресурсов. Среди них, следующие комплекты широко используются и могут упоминаться 
            в Вашем приложении или коде расширения:
                yii\web\YiiAsset: Включает основной yii.js файл который реализует механизм организации JavaScript кода в модулях. 
                    Также обеспечивает специальную поддержку для data-method и data-confirm атрибутов и содержит другие полезные функции.
                yii\web\JqueryAsset: Включает jquery.js файл из jQuery Bower пакета.
                yii\bootstrap\BootstrapAsset: Включает CSS файл из Twitter Bootstrap фреймворка.
                yii\bootstrap\BootstrapPluginAsset: Включает JavaScript файл из Twitter Bootstrap фреймворка для поддержки Bootstrap JavaScript плагинов.
                yii\jui\JuiAsset: Включает CSS и JavaScript файлы из jQuery UI библиотеки.
            Если Ваш код зависит от jQuery, jQuery UI или Bootstrap, Вам необходимо использовать эти предопределенные комплекты ресурсов, 
            а не создавать свои собственные варианты. Если параметры по умолчанию этих комплектов не удовлетворяют Вашим нуждам, 
            Вы можете настроить их как описано в подразделе Настройка Комплектов Ресурсов.

        Преобразование Ресурсов
        -----------------------
            LESS и т.д. https://www.yiiframework.com/doc/guide/2.0/ru/structure-assets#asset-conversion

        Объединение и Сжатие Ресурсов
        -----------------------------
        https://www.yiiframework.com/doc/guide/2.0/ru/structure-assets#combining-compressing-assets
            Web страница может включать много CSS и/или JavaScript файлов. Чтобы сократить количество HTTP запросов и общий размер загрузки этих файлов, 
            общепринятой практикой является объединение и сжатие нескольких CSS/JavaScript файлов в один или в более меньшее количество, 
            а затем включение этих сжатых файлов вместо исходных в Web страницы.
            Примечание: 
                Комбинирование и сжатие ресурсов обычно необходимо, когда приложение находится в режиме продакшена. В режиме разработки, 
                использование исходных CSS/JavaScript файлов часто более удобно для отладочных целей.

            1) Найдите все комплекты ресурсов в Вашем приложении, которые Вы планируете скомбинировать и сжать.
            2) Распределите эти комплекты в одну или несколько групп. Обратите внимание, что каждый комплект может принадлежать только одной группе.
            3) Скомбинируйте/сожмите CSS файлы каждой группы в один файл. Сделайте то же самое для JavaScript файлов.
            4) Определите новый комплект ресурсов для каждой группы:
                - Или установите css и js свойства. Соответствующие CSS и JavaScript файлы будут объединены.
                - Или настройте комплекты ресурсов каждой группы, установив их css и js свойства как пустые, и установите их depends свойство как новый комплект ресурсов, 
                    созданный для группы.

Расширения
----------
    Расширения - это распространяемые программные пакеты, специально разработанные для использования в приложениях Yii и содержащие готовые функции.
    Информация: 
        Мы используем термин "расширение" для специфичных для Yii программных пакетов. 
        Программные пакеты общего назначения, которые могут быть использованы без Yii, мы будем называть "пакет" или "библиотека".

    Использование расширений:
        Чтобы использовать расширение, вам необходимо установить его. Большинство расширений распространяются как пакеты Composer, 
        которые могут быть установлены посредством следующих двух шагов:
            1) Отредактируйте файл вашего приложения composer.json, указав, какие расширения (пакеты Composer) вы хотите установить.
            2) Выполните команду php composer.phar install, чтобы установить указанные расширения.

        Информация: 
            yiisoft/yii2-imagine является базовым расширением, которое разрабатывает и поддерживает команда разработчиков Yii. 
            Все базовые расширения размещены на Packagist и называются yiisoft/yii2-xyz, где xyz является названием расширения.

            Ручная установка расширений:
                Чтобы сделать это, вы должны
                    1) загрузить архив с файлами расширения и распаковать его в директорию vendor.
                    2) установить автозагрузчики классов, предоставляемые расширениями, если таковые имеются.
                    3) загрузить и установить все зависимые расширения в соответствии с инструкциями.

    Создание расширений:
        Вы можете захотеть создать расширение, когда чувствуете необходимость поделиться своим хорошим кодом с другими людьми. 
        Расширение может содержать любой код, который вам нравится, например, класс-помощник, виджет, модуль и т.д.
        Рекомендуется создавать расширение как пакет Composer, для того, чтобы его можно было легко установить и использовать, как описано в предыдущей главе.

        Ниже приведены основные шаги, которым нужно следовать, чтобы создать пакет Composer.
            1) Создайте проект для вашего расширения и разместите его в VCS репозитории, таком как github.com. 
                Разработка и поддержка расширения должна выполняться в этом репозитории.
            2) В корневой директории проекта создайте файл под названием composer.json, в соответствии с требованиями Composer. 
                Вы можете обратиться к следующему разделу за более подробной информацией.
            3) Зарегистрируйте ваше расширение в репозитории Composer, таком как Packagist, чтобы другие пользователи могли найти и установить ваше расширение, 
                используя Composer.

    Базовые расширения:
        yiisoft/yii2-apidoc: предоставляет расширяемый и высокопроизводительный генератор документации API. 
            Оно также используется для генерации документации API фреймворка.
        yiisoft/yii2-authclient: предоставляет набор наиболее часто используемых клиентов авторизации, таких, как Facebook OAuth2 клиент и GitHub OAuth2 клиент.
        yiisoft/yii2-bootstrap: предоставляет набор виджетов, которые являются компонентами и плагинами Bootstrap.
        yiisoft/yii2-debug: предоставляет поддержку отладки в приложениях Yii. Когда это расширение используется, отладочная панель появится в нижней части каждой страницы. 
            Это расширение также предоставляет набор отдельных страниц для отображения более подробной отладочной информации.
        yiisoft/yii2-elasticsearch: предоставляет поддержку использования Elasticsearch. Оно включает в себя поддержку основных поисковых запросов, 
            а также реализует шаблон проектирования Active Record, который позволяет хранить записи Active Record в Elasticsearch.
        yiisoft/yii2-faker: предоставляет поддержку использования Faker для генерации фиктивных данных.
        yiisoft/yii2-gii: предоставляет веб-интерфейс для генерации кода, который является весьма расширяемым и может быть использован для быстрой генерации 
            моделей, форм, модулей, CRUD и т.д.
        yiisoft/yii2-httpclient: предоставляет HTTP клиент.
        yiisoft/yii2-imagine: предоставляет часто используемые функции для работы с изображениями, основанные на библиотеке Imagine.
        yiisoft/yii2-jui: предоставляет набор виджетов, основанный на взаимодействиях и виджетах JQuery UI.
        yiisoft/yii2-mongodb: предоставляет поддержку использования MongoDB. Оно включает такие возможности, как базовые запросы, Active Record, 
            миграции, кэширование, генерация кода и т.д.
        yiisoft/yii2-redis: предоставляет поддержку использования redis. Оно включает такие возможности, как базовые запросы, Active Record, кэширование и т.д.
        yiisoft/yii2-smarty: предоставляет шаблонизатор, основанный на Smarty.
        yiisoft/yii2-sphinx: предоставляет поддержку использования Sphinx. Оно включает такие возможности, как базовые запросы, Active Record, генерация кода и т.д.
        yiisoft/yii2-swiftmailer: предоставляет возможности отправки email, основанные на swiftmailer.
        yiisoft/yii2-twig: предоставляет шаблонизатор, основанный на Twig.

========================================================================================================================================================
Обработка запросов
------------------

1) Bootstraping (Предзагрузка)
------------------------------
    Предзагрузка - это процесс настройки рабочей среды до того, как будет запущено приложение и обработан входящий запрос. 
        Предзагрузка осуществляется в двух местах: во входном скрипте и в приложении.
    
    В конструкторе приложения происходит следующий процесс предзагрузки:
        1) Вызывается метод preInit(), которые конфигурирует свойства приложения, имеющие наивысший приоритет, такие как basePath;
        2) Регистрируется обработчик ошибок;
        3) Происходит инициализация свойств приложения согласно заданной конфигурации;
        4) Вызывается метод init(), который в свою очередь вызывает метод bootstrap() для запуска компонентов предзагрузки.
            - Подключается файл манифеста vendor/yiisoft/extensions.php;
            - Создаются и запускаются компоненты предзагрузки объявленные в расширениях;
            - Создаются и запускаются компоненты приложения и/или модули, объявленные в свойстве предзагрузка приложения.

2) Разбор и генерация URL
-------------------------
    При обработке запрошенного URL, Yii приложение первым делом разбирает URL в маршрут.

    Роутинг - создании соответствующего экземпляра действия контроллера для обработки запроса.
    Создание URL - обратный роутингу процесс, он отвечает за создание URL из заданного маршрута и соответствующих параметров запроса.
        При необходимости, созданный URL всегда может быть преобразован в первоначальные маршрут и параметры запроса.

    В основе роутинга и создания URL лежит использование URL manager.
    URL manager содержит:
        - метод parseRequest() для разбора входящего запроса на маршрут и параметры запроса
        - метод createUrl() для создания URL из заданного маршрута и параметров запроса
    
    =========================================================
    use yii\helpers\Url; - используется для создания маршрута
        https://www.yiiframework.com/doc/guide/2.0/ru/helper-url
        Получение общих URL (Url::home()):
            Url::home(); - домашний URL: /index.php?r=site/index
            Url::base(); - базовый URL, удобно использовать в случае, когда приложение расположено в подкаталоге относительно корневого каталога веб-сервера
            Url::canonical(); - канонический URL запрошенного URL подробнее https://support.google.com/webmasters/answer/139066?hl=ru
        
        Создание URL:
            Url::toRoute()
            Url::to()
        
        Запоминание URL:
            Url::remember(); - запомнить
            Url::previous(); - восстановить

        Проверить относительность URL:
            Url::isRelative()
    =========================================================

    Форматы URL:
    ------------
        URL manager поддерживает два формата URL 
        (переключение между двумя форматами URL осуществляется при помощи свойства enablePrettyUrl компонента URL manager без внесения изменений в код приложения):
            - Обычный (использует параметр r для передачи маршрута и любые другие параметры для передачи остальных параметров запроса)
            - Человекопонятные URL
    
    Роутинг:
    --------
        Роутинг осуществляется в два этапа:
            1) Входящий запрос разбирается в маршрут и параметры запроса.
            2) Для обработки запроса создается действие контроллера, соответствующее полученному маршруту.

        При использовании простого формата URL, получение маршрута из запроса заключается в получении параметра r из массива GET.
        При использовании ЧПУ, компонент URL manager ищет среди зарегистрированных правил подходящее для разрешения запроса в маршрут. 
            Если такое правило не найдено, вызывается исключение yii\web\NotFoundHttpException.
        
        Каждая из частей представляет собой идентификатор, который может ссылаться на модуль, контроллер или действие. 
        Начиная с первой части маршрута, приложение следует следующему алгоритму для создания модуля (если есть), контроллера и действия:
            1. Текущим модулем считаем приложение.
            2. Проверяем, содержит ли карта контроллеров текущего модуля текущий идентификатор. Если содержит, в соответствии с конфигурацией контроллера, 
                найденной в карте, создаем объект контроллера и переходим в п. 5 для обработки оставшейся части маршрута.
            3. Проверяем, есть ли модуль, соответствующий идентификатору в списке модулей (свойство modules) текущего модуля. 
                Если есть, в соответствии с конфигурацией модуля, найденной в списке модулей, создаем модуль и переходим в п. 2, считая только что созданный модуль текущим.
            4. Рассматриваем идентификатор как идентификатор контроллера и создаем объект контроллера. Для оставшейся части маршрута выполняем п. 5.
            5. Контроллер ищет текущий идентификатор в его карте действий. В случае нахождения, контроллер создает действие, в соответствии с конфигурацией, найденной в карте.
                Иначе, контроллер пытается создать встроенное действие, описанное методом, соответствующим текущему идентификатору действия.
        При возникновении ошибок на любом из описанных выше этапов, вызывается исключение yii\web\NotFoundHttpException, указывающее на ошибку в процессе роутинга.

    Маршрут по умолчанию:
    ---------------------
        По умол. site/index
        Указать свое значение можно при помощи свойства приложения defaultRoute, например так:
            [
                // ...
                'defaultRoute' => 'main/index',
            ];

        В добавок к маршруту по умолчанию приложения, существует маршрут по умолчанию модулей. Например, если у нас есть модуль user: user/default/index
            свойство defaultRoute
            свойство defaultAction
            
    Маршрут catchAll:
    -----------------
        Иногда возникает необходимость временно перевести приложение в режим обслуживания и отображать одно информационное сообщение для всех запросов:
            [
                // ...
                'catchAll' => ['site/offline'],
            ];
        Свойство catchAll должно принимать массив, первый элемент которого определяет маршрут, а остальные элементы (пары ключ-значение) определяют параметры, 
        передаваемые действию.

    Создание URL:
    -------------
        Для создания разных видов URL из заданных маршрутов и параметров, Yii предоставляет метод-помощник yii\helpers\Url::to().

        Маршрут, переданный методу yii\helpers\Url::to(), является контекстно-зависимым. Он может быть относительным или абсолютным, в зависимости от следующих правил:
            - Если маршрут является пустой строкой, будет использован текущий маршрут;
            - Если маршрут не содержит слешей вообще, он рассматривается как идентификатор действия текущего контроллера и 
                будет дополнен значением uniqueId текущего контроллера в качестве префикса;
            - Если маршрут не содержит слеша в начале, он будет рассматриваться как маршрут относительно текущего модуля и будет дополнен значением uniqueId текущего модуля, 
                в качестве префикса.
        Начиная с версии 2.0.2, при составлении маршрутов, стало возможным использовать псевдонимы. В таком случае, псевдоним будет преобразован в маршрут, 
        который будет использован для создания URL по правилам, указанным выше.

        В основе реализации метода yii\helpers\Url::to() лежит использование двух методов компонента URL manager: createUrl() и createAbsoluteUrl(). 
        Ниже будут рассмотрены способы конфигурации URL manager для создания URL в различных форматах.

    Использование человекопонятных URL:
    -----------------------------------
        Для активации ЧПУ, необходимо настроить компонент urlManager в конфигурации приложения следующим образом:
        [
            'components' => [
                'urlManager' => [
                    'enablePrettyUrl' => true,
                    'showScriptName' => false,
                    'enableStrictParsing' => false,
                    'rules' => [
                        // ...
                    ],
                ],
            ],
        ]

            - enablePrettyUrl является ключевым, активирует формат ЧПУ. Остальные свойства необязательные. 
            - showScriptName: это свойство определяет необходимость включения имени входного скрипта в создаваемый URL. 
                Например, при его значении false, вместо /index.php/post/100, будет сгенерирован URL /post/100.
            - enableStrictParsing: это свойство позволяет включить строгий разбор URL. Если строгий разбор URL включен, 
                запрошенный URL должен соответствовать хотя бы одному из правил, иначе будет вызвано исключение yii\web\NotFoundHttpException. 
                Если строгий разбор URL отключен и ни одно из правил не подходит для разбора запрошенного URL, часть этого URL, представляющая путь, 
                будет использована как маршрут.
            - rules: это свойство содержит набор правил для разбора и создания URL. Это основное свойство, с которым нужно работать, 
                чтобы URL создавались в формате, соответствующем требованиям приложения.

        Примечание: 
            Для того, чтобы скрыть имя входного скрипта в создаваемых URL, кроме установки значения свойства showScriptName в false, необходимо настроить веб-сервер, 
            чтобы он мог правильно определять PHP-скрипт, который должен быть запущен, если в запрошенном URL он не указан явно. 
            Рекомендованные настройки для Apache и Nginx описаны в разделе Установка Yii.

    Правила URL (rules):
    --------------------
        Правила URL - это экземпляр класса yii\web\UrlRule или класса, унаследованного от него.
        При включенном режиме ЧПУ, компонент URL manager использует правила URL, содержащиеся в его свойстве rules, для разбора входящих запросов и создания URL. 
        Правила задаются ассоциативным массивом, где ключи определяют шаблоны, а значения соответствующие маршруты. 
        Примечание: 
            Шаблон правила используется для поиска соответствия с частью URL, определяющей путь. 
            Например, в URL /index.php/post/100?source=ad путь определяет часть post/100 (начальный и конечный слеши игнорируются), 
            соответствующая регулярному выражению post/(\d+).

        Правила URL можно определять не только в виде пар шаблон-маршрут, но и в виде массива. Каждый массив используется для определения одного правила.
        Такой вид определения правил используется в случаях, когда необходимо указать другие параметры правила URL. Например,
            [
                // ...другие правила URL...
                
                [
                    'pattern' => 'posts',
                    'route' => 'post/index',
                    'suffix' => '.json',
                ],
            ]
        По умолчанию, если в конфигурации правила URL не указан явно параметр class, будет создано правило класса yii\web\UrlRule.

        Именованные параметры:
        ----------------------
            Правило URL может содержать несколько именованных параметров запроса, которые указываются в шаблоне в следующем формате: <ParamName:RegExp>, 
            где ParamName определяет имя параметра, а RegExp - необязательное регулярное выражение, используемое для определения значения параметра. 
            В случае, если RegExp не указан, значением параметра будет любая последовательность символов кроме слешей.

            Примечание: Возможно указание только регулярного выражения для параметров. В таком случае остальная часть шаблона будет считаться простым текстом.

            После разбора URL, параметры запроса, соответствующие шаблону правила, будут доступны в массиве $_GET через компонент приложения request. 
            При создании URL, значения указанных параметров будут вставлены в URL в соответствии с шаблоном правила.

        Параметры в маршрутах:
        ----------------------
            В маршруте правила URL возможно указание имен параметров. Это позволяет использовать правило URL для обработки нескольких маршрутов. 
            Например, следующие правила содержат параметры controller и action в маршрутах.
            [
                '<controller:(post|comment)>/<id:\d+>/<action:(create|update|delete)>' => '<controller>/<action>',
                '<controller:(post|comment)>/<id:\d+>' => '<controller>/view',
                '<controller:(post|comment)>s' => '<controller>/index',
            ]

            По умолчанию все параметры, указанные в правиле, являются обязательными. Если запрошенный URL не содержит обязательный параметр, или 
            если URL создается без обязательного параметра, данное правило не будет применено. Свойство yii\web\UrlRule::$defaults позволяет сделать 
            нужные параметры не обязательными. Параметры, перечисленные в данном свойстве, будут иметь заданные значения, в случае если они пропущены.
            [
                // ...другие правила...
                [
                    'pattern' => 'posts/<page:\d+>/<tag>',
                    'route' => 'post/index',
                    'defaults' => ['page' => 1, 'tag' => ''],
                ],
            ]

        Правила с именами серверов:
        ---------------------------
            Существует возможность включать имена серверов в шаблон правил URL. Главным образом, это удобно, когда требуется разное поведение приложения, 
            в зависимости от разных имен веб-серверов. Например, следующее правило позволит разобрать URL https://admin.example.com/login в маршрут admin/user/login и 
            https://www.example.com/login в site/login.
                [
                    'https://admin.example.com/login' => 'admin/user/login',
                    'https://www.example.com/login' => 'site/login',
                ]

            Также возможно комбинирование параметров и имени сервера для динамического извлечения данных из него. 
            Например, следующее правило позволит разобрать URL https://en.example.com/posts на маршрут и параметр language=en.
                [
                    'http://<language:\w+>.example.com/posts' => 'post/index',
                ]

                Примечание:
                    Правила, содержащие имя сервера, НЕ должны содержать в шаблоне подкаталог пути ко входному скрипту. 
                    Например, если приложение расположено в https://www.example.com/sandbox/blog, шаблон должен быть https://www.example.com/posts, 
                    вместо https://www.example.com/sandbox/blog/posts. Это позволит изменять расположение приложения без необходимости внесения изменений в его код.

        Суффиксы в URL:
        ---------------
            Компонент предоставляет возможность добавления к URL суффиксов. 
            При помощи соответствующего свойства yii\web\UrlManager::$suffix в конфигурации приложения:
                [
                    'components' => [
                        'urlManager' => [
                            'suffix' => '.html',
                            'rules' => [
                                // ...
                            ],
                        ],
                    ],
                ]
            Подсказка: При установке суффикса /, все URL будут заканчиваться слешем.
            Примечание: 
                При настроенном суффиксе, все URL не содержащие этот суффикс будут расценены как неизвестные URL. 
                Такое поведение рекомендовано для SEO (поисковая оптимизация).
            Иногда возникает необходимость использовать разные суффиксы для разных URL. Добиться этого можно настройкой свойства suffix у каждого правила. 
            Когда это свойство установлено, оно имеет приоритет перед общей конфигурацией компонента URL manager.
                'rules' => [
                    // ...
                    [
                        'pattern' => 'posts',
                        'route' => 'post/index',
                        'suffix' => '.json',
                    ],
                ],

        Нормализация URL:
        -----------------
            Начиная с версии 2.0.10 UrlManager может быть настроен на использование UrlNormalizer, что позволяет справиться с вариациями одного и 
            того же URL с присутствующим или отсутствующим слешем в конце.

            По умолчанию все правила используют нормализатор, заданный в менеджере URL. 
            Вы можете выставить UrlRule::$normalizer в false для отключения нормализации для конкретного правила.

            [
                'components' => [
                    'urlManager' => [
                        'suffix' => '.html',
                        'normalizer' => [
                            'class' => 'yii\web\UrlNormalizer',
                            'action' => UrlNormalizer::ACTION_REDIRECT_TEMPORARY, // используем временный редирект вместо постоянного
                        ],
                        'rules' => [
                            // ...
                            [
                                'pattern' => 'posts',
                                'route' => 'post/index',
                                'suffix' => '/',
                                'normalizer' => false, // отключаем нормализатор для этого правила
                            ],
                        ],
                    ],
                ],
            ]
            Примечание: По умолчанию UrlManager::$normalizer отключен. Чтобы использовать нормализацию, его необходимо сконфигурировать.

        Методы HTTP:
        ------------
            При реализации RESTful API, зачастую бывает необходимость в том, чтобы один и тот же URL был разобран в разные маршруты, в зависимости от HTTP-метода запроса.
            Это легко достигается указанием HTTP-методов, поддерживаемых правилом в начале шаблона. 
            Если правило поддерживает несколько HTTP-методов, их имена разделяются запятыми.
            [
                'PUT,POST post/<id:\d+>' => 'post/create',
                'DELETE post/<id:\d+>' => 'post/delete',
                'post/<id:\d+>' => 'post/view',
            ]

            Примечание: 
                Если правило URL содержит HTTP-метод в шаблоне, это правило будет использовано только при разборе URL. 
                Такое правило не будет учитываться компонентом URL manager при создании URL.

            Подсказка: 
                Для упрощения маршрутизации RESTful API, Yii предоставляет специальный класс yii\rest\UrlRule, который достаточно эффективен и 
                предоставляет такие удобные возможности, как автоматическое приведение идентификаторов контроллеров к множественной форме. 
                Более подробную информацию можно найти в разделе Веб-сервисы REST Роутинг.

        Гибкая настройка правил:
        ------------------------
            Достигается при помощи массива (rules):
                [
                    // ...другие правила URL...
                    
                    [
                        'pattern' => 'posts',
                        'route' => 'post/index',
                        'suffix' => '.json',
                    ],
                ]
                Информация: По умолчанию, если в конфигурации правила явно не задан параметр class, будет создано правило класса yii\web\UrlRule.

        Добавление правил URL динамически:
        ----------------------------------
            Правила URL могут быть динамически добавлены в компонент URL manager. Часто это необходимо подключаемым модулям для настройки своих правил URL. 
            Для того чтобы динамически добавленные правила могли влиять на процесс роутинга, они должны быть добавлены в процессе предзагрузки. 
            В частности, модули должны реализовываться интерфейс yii\base\BootstrapInterface и добавлять правила в методе bootstrap(), например:
            public function bootstrap($app)
            {
                $app->getUrlManager()->addRules([
                    // правила URL описываются здесь
                ], false);
            }
            Также необходимо включить данный модуль в yii\web\Application::bootstrap(), чтобы он смог участвовать в процессе предзагрузки.

        Создание классов правил:
        ------------------------
            https://www.yiiframework.com/doc/guide/2.0/ru/runtime-routing#creating-rules

        Производительность:
        -------------------
            При разработке сложных веб-приложений, важно оптимизировать правила URL так, чтобы разбор запросов и создание URL занимали минимальное время.
            Использование параметров в маршрутах позволяет уменьшить количество правил, что значительно увеличивает производительность.
            При разборе или создании URL, компонент URL manager проверяет правила в порядке их определения. 
            Поэтому следует более узконаправленные и/или часто используемые правила размещать раньше прочих.
            В случае, если несколько правил имеют один и тот же префикс в шаблоне или маршруте, можно рассмотреть использование yii\web\GroupUrlRule, 
            что позволит компоненту URL manager более эффективно обрабатывать правила группами. Часто это бывает полезно в случае, 
            если приложение состоит из модулей, каждый из которых имеет свой набор правил с идентификатором модуля в качестве общего префикса.

    
    Запросы:
    --------
        Запросы, сделанные к приложению, представлены в терминах yii\web\Request объектов, которые предоставляют информацию о параметрах запроса, 
        HTTP заголовках, cookies и т.д. Для получения доступа к текущему запросу вы должны обратиться к объекту request application component, 
        который по умолчанию является экземпляром yii\web\Request.

        Параметры запроса:
        ------------------
            Чтобы получить параметры запроса, вы должны вызвать методы get() и post() компонента request. 
            Они возвращают значения переменных $_GET и $_POST соответственно. Например,
                $request = Yii::$app->request;
                $get = $request->get(); // эквивалентно: $get = $_GET;
                $post = $request->post(); // эквивалентно: $post = $_POST;

            Информация:
                Вместо того, чтобы обращаться напрямую к переменным $_GET и $_POST для получения параметров запроса, рекомендуется чтобы вы обращались 
                к ним через компонент request как было показано выше. Это упростит написание тестов, поскольку вы можете создать mock компонент запроса 
                с не настоящими данными запроса.

            При реализации RESTful API, зачастую вам требуется получить параметры, которые были отправлены через PUT, PATCH или другие методы запроса. 
            Вы можете получить эти параметры, вызвав метод yii\web\Request::getBodyParam(). Например,
                $request = Yii::$app->request;
                $params = $request->bodyParams; // возвращает все параметры       
                $param = $request->getBodyParam('id'); // возвращает параметр "id"

            Информация: 
                В отличие от GET параметров, параметры, которые были переданы через POST, PUT, PATCH и д.р. отправляются в теле запроса. 
                Компонент request будет обрабатывать эти параметры, когда вы попробуете к ним обратиться через методы, описанные выше. 
                Вы можете настроить способ обработки этих параметров через настройку свойства yii\web\Request::$parsers.

        Методы запроса:
        ---------------
            Вы можете получить названия HTTP метода, используемого в текущем запросе, обратившись к выражению Yii::$app->request->method.
                $request = Yii::$app->request;
                if ($request->isAjax) { /* текущий запрос является AJAX запросом */ }
                if ($request->isGet)  { /* текущий запрос является GET запросом */ }
                if ($request->isPost) { /* текущий запрос является POST запросом */ }
                if ($request->isPut)  { /* текущий запрос является PUT запросом */ }

        URL запроса:
        ------------
            Компонент request предоставляет множество способов изучения текущего запрашиваемого URL.
            Если предположить, что URL запроса будет https://example.com/admin/index.php/product?id=100, то вы можете получить различные части этого 
            адреса так как это показано ниже:
                - url: вернёт адрес /admin/index.php/product?id=100, который содержит URL без информации об имени хоста.
                - absoluteUrl: вернёт адрес https://example.com/admin/index.php/product?id=100, который содержит полный URL, включая имя хоста.
                - hostInfo: вернёт адрес https://example.com, который содержит только имя хоста.
                - pathInfo: вернёт адрес /product, который содержит часть между адресом начального скрипта и параметрами запроса, идущих после знака вопроса.
                - queryString: вернёт адрес id=100, который содержит часть URL после знака вопроса.
                - baseUrl: вернёт адрес /admin, который является частью URL после информации о хосте и перед именем входного скрипта.
                - scriptUrl: вернёт адрес /admin/index.php, который содержит URL без информации о хосте и параметрах запроса.
                - serverName: вернёт адрес example.com, который содержит имя хоста в URL.
                - serverPort: вернёт 80, что является адресом порта, который использует веб-сервер.

        HTTP заголовки:
        ---------------
            Вы можете получить информацию о HTTP заголовках через header collection, возвращаемыми свойством yii\web\Request::$headers. Например,
                $headers = Yii::$app->request->headers; // переменная $headers является объектом yii\web\HeaderCollection 
                $accept = $headers->get('Accept'); // возвращает значения заголовка Accept
            
            if ($headers->has('User-Agent')) { /* в запросе есть заголовок User-Agent */ }

            Компонент request также предоставляет доступ к некоторым часто используемым заголовкам, включая
                - userAgent: возвращает значение заголовка User-Agent.
                - contentType: возвращает значение заголовка Content-Type, который указывает на MIME тип данных в теле запроса.
                - acceptableContentTypes: возвращает список MIME типов данных, которые принимаются пользователем. Возвращаемый список типов будет отсортирован по показателю качества. Типы с более высокими показателями будут первыми в списке.
                - acceptableLanguages: возвращает языки, которые поддерживает пользователь. Список языков будет отсортирован по уровню предпочтения. Наиболее предпочитаемый язык будет первым в списке.

            Если ваше приложение поддерживает множество языков и вы хотите показать страницу на языке, который предпочитает пользователь, 
            то вы можете воспользоваться языковым методом согласования (negotiation) yii\web\Request::getPreferredLanguage(). 
            Этот метод принимает список поддерживаемых языков в вашем приложении, сравнивает их с acceptableLanguages и возвращает наиболее подходящий язык.

            Подсказка: 
                Вы также можете использовать фильтр ContentNegotiator для динамического определения какой тип содержимого и язык должен использоваться в ответе. 
                Фильтр реализует согласование содержимого на основе свойств и методов, описанных выше.

        Информация о клиенте:
        ---------------------
            Вы можете получить имя хоста и IP адрес пользователя через свойства userHost и userIP соответственно. Например,
                $userHost = Yii::$app->request->userHost;
                $userIP = Yii::$app->request->userIP;

        Доверенные прокси и заголовки:
        ------------------------------
            https://www.yiiframework.com/doc/guide/2.0/ru/runtime-requests#trusted-proxies

    Ответы:
    -------
        Когда приложение заканчивает обработку запроса, оно генерирует объект ответа и отправляет его пользователю. 
        Объект ответа содержит такие данные, как HTTP-код состояния, HTTP-заголовки и тело ответа. 
        Конечная цель разработки Web-приложения состоит в создании объектов ответа на различные запросы.

        В большинстве случаев вам придется иметь дело с компонентом приложения response, который по умолчанию является экземпляром класса yii\web\Response. 
        Однако Yii также позволяет вам создавать собственные объекты ответа и отправлять их пользователям.

        Код состояния:
        --------------
            Первое, что вы делаете при построении ответа, — определяете, был ли успешно обработан запрос. 
            Это реализуется заданием свойству yii\web\Response::$statusCode значения, которое может быть одним из валидных HTTP-кодов состояния. 
            Например, чтобы показать, что запрос был успешно обработан, вы можете установить значение кода состояния равным 200:
                Yii::$app->response->statusCode = 200;
            
            Однако в большинстве случаев явная установка не требуется так как значение yii\web\Response::$statusCode по умолчанию равно 200. 
            Если вам нужно показать, что запрос не удался, вы можете выбросить соответствующее HTTP-исключение:
                throw new \yii\web\NotFoundHttpException;

            Когда обработчик ошибок поймает исключение, он извлечёт код состояния из исключения и назначит его ответу. 
            Исключение yii\web\NotFoundHttpException в коде выше представляет HTTP-код состояния 404. В Yii предопределены следующие HTTP-исключения:
                yii\web\BadRequestHttpException: код состояния 400.
                yii\web\ConflictHttpException: код состояния 409.
                yii\web\ForbiddenHttpException: код состояния 403.
                yii\web\GoneHttpException: код состояния 410.
                yii\web\MethodNotAllowedHttpException: код состояния 405.
                yii\web\NotAcceptableHttpException: код состояния 406.
                yii\web\NotFoundHttpException: код состояния 404.
                yii\web\ServerErrorHttpException: код состояния 500.
                yii\web\TooManyRequestsHttpException: код состояния 429.
                yii\web\UnauthorizedHttpException: код состояния 401.
                yii\web\UnsupportedMediaTypeHttpException: код состояния 415.

            Если в приведённом выше списке нет исключения, которое вы хотите выбросить, вы можете создать его, расширив класс yii\web\HttpException, 
            или выбросить его напрямую с кодом состояния, например:
                throw new \yii\web\HttpException(402);

        HTTP-заголовки:
        ---------------
            Вы можете отправлять HTTP-заголовки, работая с коллекцией заголовков компонента response:
                $headers = Yii::$app->response->headers;
                $headers->add('Pragma', 'no-cache'); // добавить заголовок Pragma. Уже имеющиеся Pragma-заголовки НЕ будут перезаписаны.
                $headers->set('Pragma', 'no-cache'); // установить заголовок Pragma. Любые уже имеющиеся Pragma-заголовки будут сброшены.
                $values = $headers->remove('Pragma'); // удалить заголовок (или заголовки) Pragma и вернуть их значения массивом

                Информация:
                    названия заголовков не чувствительны к регистру символов. Заново зарегистрированные заголовки не отсылаются пользователю 
                    до вызова yii\web\Response::send().

        Тело ответа:
        ------------
            Большинство ответов должны иметь тело, содержащее то, что вы хотите показать пользователям.
            Если у вас уже имеется отформатированная строка для тела, вы можете присвоить её свойству yii\web\Response::$content объекта запроса:
                Yii::$app->response->content = 'hello world!';

            Если ваши данные перед отправкой конечным пользователям нужно привести к определённому формату, вам следует установить значения двух свойств: format и data. 
            Свойство format определяет, в каком формате следует возвращать данные из data. Например:
                $response = Yii::$app->response;
                $response->format = \yii\web\Response::FORMAT_JSON;
                $response->data = ['message' => 'hello world'];

            Yii из коробки имеет поддержку следующих форматов, каждый из которых реализован классом форматтера. 
            Вы можете настроить эти форматтеры или добавить новые через свойство yii\web\Response::$formatters.
                HTML: реализуется классом yii\web\HtmlResponseFormatter.
                XML: реализуется классом yii\web\XmlResponseFormatter.
                JSON: реализуется классом yii\web\JsonResponseFormatter.
                JSONP: реализуется классом yii\web\JsonResponseFormatter.

            Хотя тело запроса может быть явно установлено показанным выше способом, в большинстве случаев вы можете задавать его неявно через 
            возвращаемое значение методов действий.

            Так как по умолчанию форматом ответа является HTML, в методе действия следует вернуть строку. Если вы хотите использовать другой формат ответа, 
            необходимо настроить его перед отправкой данных:
                public function actionInfo()
                {
                    \Yii::$app->response->format = \yii\web\Response::FORMAT_JSON;
                    return [
                        'message' => 'hello world',
                        'code' => 100,
                    ];
                }

        Перенаправление браузера:
        -------------------------
            Вы можете перенаправить браузер пользователя на URL-адрес, вызвав метод yii\web\Response::redirect(). 
            Этот метод использует указанный URL-адрес в качестве значения заголовка Location и возвращает сам объект ответа. 
            В методе действия вы можете вызвать короткую версию этого метода — yii\web\Controller::redirect(). Например:
                public function actionOld()
                {
                    return $this->redirect('https://example.com/new', 301);
                }

            В коде, находящемся вне методов действий, следует использовать yii\web\Response::redirect() и непосредственно после него — метод yii\web\Response::send(). 
            Так можно быть уверенным, что к ответу не будет добавлено нежелательное содержимое.
                \Yii::$app->response->redirect('https://example.com/new', 301)->send();

            Информация:
                По умолчанию метод yii\web\Response::redirect() устанавливает код состояния ответа равным 302, сообщая браузеру, что запрашиваемый ресурс 
                временно находится по другому URI-адресу. Вы можете передать код состояния 301, чтобы сообщить браузеру, что ресурс перемещён навсегда.    

            Если текущий запрос является AJAX-запросом, отправка заголовка Location не заставит браузер автоматически осуществить перенаправление.
            Чтобы решить эту задачу, метод yii\web\Response::redirect() устанавливает значение заголовка X-Redirect равным URL для перенаправления.
            На стороне клиента вы можете написать JavaScript-код для чтения значения этого заголовка и перенаправления браузера соответственно.

            Информация:
                Yii поставляется с JavaScript-файлом yii.js, который предоставляет набор часто используемых JavaScript-утилит, включая и перенаправление браузера
                на основе заголовка X-Redirect. Следовательно, если вы используете этот JavaScript-файл (зарегистрировав пакет ресурсов yii\web\YiiAsset),
                вам не нужно писать дополнительный код для поддержки AJAX-перенаправления.   

        Отправка файлов:
        ----------------
            https://www.yiiframework.com/doc/guide/2.0/ru/runtime-responses#sending-files

        Отправка ответа:
        ----------------
            Содержимое ответа не отправляется пользователю до вызова метода yii\web\Response::send(). 
            По умолчанию он вызывается автоматически в конце метода yii\base\Application::run(). 
            Однако чтобы ответ был отправлен немедленно, вы можете вызвать этот метод явно.

            Для отправки ответа метод yii\web\Response::send() выполняет следующие шаги:
                1) Инициируется событие yii\web\Response::EVENT_BEFORE_SEND.
                2) Для форматирования данных ответа в содержимое ответа вызывается метод yii\web\Response::prepare().
                3) Инициируется событие yii\web\Response::EVENT_AFTER_PREPARE.
                4) Для отправки зарегистрированных HTTP-заголовков вызывается метод yii\web\Response::sendHeaders().
                5) Для отправки тела ответа вызывается метод yii\web\Response::sendContent().
                6) Инициируется событие yii\web\Response::EVENT_AFTER_SEND.

            Повторный вызов yii\web\Response::send() игнорируется. Это означает, что если ответ уже отправлен, то к нему уже ничего не добавить.
            Как видно, метод yii\web\Response::send() инициирует несколько полезных событий. Реагируя на эти события, можно настраивать или декорировать ответ.

    Сессии и куки:
    --------------
        Сессии и куки позволяют сохранять пользовательские данные между запросами. При использовании чистого PHP можно получить доступ к этим данным через 
        глобальные переменные $_SESSION и $_COOKIE, соответственно. Yii инкапсулирует сессии и куки в объекты, что дает возможность обращаться к ним в 
        объектно-ориентированном стиле и дает дополнительное удобство в работе.

        Сессии:
        -------
            К сессии можно получить доступ через session компонент приложения, который по умолчанию является экземпляром yii\web\Session.        
            
            Открытие и закрытие сессии:
            ---------------------------
                Открыть и закрыть сессию можно следующим образом:

                $session = Yii::$app->session;

                // проверяем что сессия уже открыта
                if ($session->isActive) ...

                // открываем сессию
                $session->open();

                // закрываем сессию
                $session->close();

                // уничтожаем сессию и все связанные с ней данные.
                $session->destroy();

                Можно вызывать open() и close() многократно без возникновения ошибок; внутри компонента все методы проверяют сессию на факт того, открыта она или нет.

            Доступ к данным сессии:
            -----------------------
                https://www.yiiframework.com/doc/guide/2.0/ru/runtime-sessions-cookies#access-session-data

                Информация:
                    При получении данных из сессии через компонент session, сессия будет автоматически открыта, если она не была открыта до этого.
                    В этом заключается отличие от получения данных из глобальной переменной $_SESSION, которое требует обязательного вызова session_start().

            Пользовательское хранилище для сессии:
            --------------------------------------
                По умолчанию класс yii\web\Session сохраняет данные сессии в виде файлов на сервере. 
                Однако Yii предоставляет ряд классов, которые реализуют различные способы хранения данных сессии:
                    - yii\web\DbSession: сохраняет данные сессии в базе данных.
                    - yii\web\CacheSession: хранение данных сессии в предварительно сконфигурированном компоненте кэша кэш.
                    - yii\redis\Session: хранение данных сессии в redis.
                    - yii\mongodb\Session: хранение сессии в MongoDB.

                Все эти классы поддерживают одинаковый набор методов API. В результате вы можете переключаться между различными хранилищами сессий 
                без модификации кода приложения.

                Примечание:
                    Если вы хотите получить данные из переменной $_SESSION при использовании пользовательского хранилища, вы должны быть уверены, 
                    что сессия уже стартовала yii\web\Session::open(), в связи с тем, что обработчики хранения пользовательских сессий регистрируются в этом методе.

                Чтобы узнать, как настроить и использовать эти компоненты, обратитесь к документации по API. 
                Ниже приведен пример конфигурации yii\web\DbSession для использования базы данных для хранения сессии:
                    return [
                        'components' => [
                            'session' => [
                                'class' => 'yii\web\DbSession',
                                // 'db' => 'mydb',  // ID компонента для взаимодействия с БД. По умолчанию 'db'.
                                // 'sessionTable' => 'my_session', // название таблицы для хранения данных сессии. По умолчанию 'session'.
                            ],
                        ],
                    ];

                Также необходимо создать таблицу для хранения данных сессии:
                    CREATE TABLE session
                    (
                        id CHAR(40) NOT NULL PRIMARY KEY,
                        expire INTEGER,
                        data BLOB
                    )

                    где 'BLOB' соответствует типу данных предпочитаемой вами DBMS. Ниже приведены примеры соответствия типов BLOB в наиболее популярных DBMS:

                        MySQL: LONGBLOB
                        PostgreSQL: BYTEA
                        MSSQL: BLOB

                Примечание:
                    В зависимости от настроек параметра session.hash_function в вашем php.ini, может понадобиться изменить длину поля id. 
                    Например, если session.hash_function=sha256, нужно установить длину поля в 64 вместо 40.

            Flash-сообщения:
            ----------------
                Flash-сообщения - это особый тип данных в сессии, которые устанавливаются один раз во время запроса и доступны только 
                на протяжении следующего запроса, затем они автоматически удаляются. Такой способ хранения информации в сессии наиболее 
                часто используется для реализации сообщений, которые будут отображены конечному пользователю один раз, например подтверждение 
                об успешной отправке формы.

                Установить и получить flash-сообщения можно через компонент приложения session. Например:
                    $session = Yii::$app->session;

                    // Запрос #1
                    // установка flash-сообщения с названием "postDeleted"
                    $session->setFlash('postDeleted', 'Вы успешно удалили пост.');

                    // Запрос #2
                    // отображение flash-сообщения "postDeleted"
                    echo $session->getFlash('postDeleted');

                    // Запрос #3
                    // переменная $result будет иметь значение false, так как flash-сообщение было автоматически удалено
                    $result = $session->hasFlash('postDeleted');

                Так как flash-сообщения хранятся в сессии как обычные данные, в них можно записывать произвольную информацию, 
                и она будет доступна лишь в следующем запросе.

                При вызове yii\web\Session::setFlash(), происходит перезаписывание flash-сообщений c таким же названием. 
                Для того, чтобы добавить новые данные к уже существующему flash-сообщению, необходимо вызвать yii\web\Session::addFlash(). Например:
                    $session = Yii::$app->session;

                    // Запрос #1
                    // добавить новое flash-сообщение с названием "alerts"
                    $session->addFlash('alerts', 'Вы успешно удалили пост.');
                    $session->addFlash('alerts', 'Вы успешно добавили нового друга.');
                    $session->addFlash('alerts', 'Благодарим.');

                    // Запрос #2
                    // Переменная $alerts теперь содержит массив flash-сообщений с названием "alerts"
                    $alerts = $session->getFlash('alerts');

                Примечание:
                    Старайтесь не использовать yii\web\Session::setFlash() совместно с yii\web\Session::addFlash() для flash-сообщений с одинаковым названием. 
                    Это связано с тем, что последний метод автоматически преобразует хранимые данные в массив, чтобы иметь возможность хранить и 
                    добавлять новые данные в flash-сообщения с тем же названием. В результате, при вызове yii\web\Session::getFlash() можно обнаружить, 
                    что возвращается массив, в то время как ожидалась строка.

            Куки:
            -----
                Yii представляет каждую куку как объект yii\web\Cookie. Оба компонента приложения yii\web\Request и yii\web\Response поддерживают коллекции кук 
                через свойство cookies. В первом случае коллекция кук является их представлением из HTTP-запроса, во втором - представляет куки, 
                которые будут отправлены пользователю.

                Чтение кук:
                -----------
                    https://www.yiiframework.com/doc/guide/2.0/ru/runtime-sessions-cookies#reading-cookies

                Отправка кук:
                -------------
                    https://www.yiiframework.com/doc/guide/2.0/ru/runtime-sessions-cookies#sending-cookies

                Валидация кук:
                --------------
                    https://www.yiiframework.com/doc/guide/2.0/ru/runtime-sessions-cookies#cookie-validation

    Обработка ошибок:
    -----------------
        В состав Yii входит встроенный обработчик ошибок, делающий работу с ошибками гораздо более приятным занятием. А именно:
            - Все не фатальные ошибки PHP (то есть warning, notice) конвертируются в исключения, которые можно перехватывать.
            - Исключения и фатальные ошибки PHP отображаются в режиме отладки с детальным стеком вызовов и исходным кодом.
            - Можно использовать для отображения ошибок действие контроллера.
            - Поддерживаются различные форматы ответа.
        По умолчанию обработчик ошибок включен. Вы можете выключить его объявив константу YII_ENABLE_ERROR_HANDLER со значением false во входном скрипте 
        вашего приложения.

        Использование обработчика ошибок:
        ---------------------------------
            Обработчик ошибок регистрируется в качестве компонента приложения с именем errorHandler. Вы можете настраивать его следующим образом:
                return [
                    'components' => [
                        'errorHandler' => [
                            'maxSourceLines' => 20,
                        ],
                    ],
                ];

        Настройка отображения ошибок:
        -----------------------------
            Обработчик ошибок меняет отображение ошибок в зависимости от значения константы YII_DEBUG. При YII_DEBUG равной true (режим отладки), 
            обработчик ошибок будет отображать для облегчения отладки детальный стек вызовов и исходный код. При YII_DEBUG равной false отображается 
            только сообщение об ошибке, тем самым не позволяя получить информацию о внутренностях приложения.

            Информация:
                Если исключение является наследником yii\base\UserException, стек вызовов не отображается вне зависимости от значения YII_DEBUG так как 
                такие исключения считаются ошибками пользователя и исправлять что-либо разработчику не требуется.

            По умолчанию обработчик ошибок показывает ошибки используя два представления:
                - @yii/views/errorHandler/error.php: используется для отображения ошибок БЕЗ стека вызовов. 
                    При YII_DEBUG равной false используется только это преставление.
                - @yii/views/errorHandler/exception.php: используется для отображения ошибок СО стеком вызовов.

            Вы можете настроить свойства errorView и exceptionView для того, чтобы использовать свои представления.

            Использование действий для отображения ошибок:
            ----------------------------------------------
                https://www.yiiframework.com/doc/guide/2.0/ru/runtime-handling-errors#using-error-actions

            Изменение формата ответа:
            -------------------------
                https://www.yiiframework.com/doc/guide/2.0/ru/runtime-handling-errors#error-format

        Логирование:
        ------------
            