# SQLite
Ссылки:  
[SQLite - wikipedia](https://ru.wikipedia.org/wiki/SQLite)  
[Про SQLite](https://blog.skillfactory.ru/glossary/sqlite/)  
[Про SQLite 2](https://habr.com/ru/post/149356/)  
[Коды ошибок](https://sqlite.org/rescode.html)

<u>SQLite</u> - это быстрая и легкая встраиваемая однофайловая (кроссплатформенная) СУБД на языке C, которая не имеет сервера и позволяет хранить всю базу локально на одном устройстве. Для работы SQLite не нужны сторонние библиотеки или службы. Движок SQLite — не отдельно работающий процесс, с которым взаимодействует программа, а библиотека с которой происходить взаимодействие с помощью различных функций (API) (в ОС Windows это DLL файл).

<u>SQLite3</u> — это консольная утилита для работы с SQLite от разработчиков СУБД.  
<u>Что такое SQLite API?</u> - Это набор функций sqlite3_XXX на языке C.

Поддерживаемые типы данных:
* NULL - нулевое значение;
* INTEGER - для целых чисел, содержащих от 1 до 8 байтов;
* REAL - числа с плавающей запятой;
* TEXT - текстовые строки, хранящиеся с использованием кодировки базы данных (UTF-8 или UTF-16);
* BLOB - двоичные данные, хранящиеся точно так, как они были введены (рисунки, код и др.);    
        + Размеры значений типа TEXT и BLOB не ограничены ничем, кроме константы SQLITE_MAX_LENGTH в исходниках SQLite, равной миллиарду.

# MySQL - база данных (БД или BD)
Ссылки:  
[Офиициальная документация - mysql.com](https://dev.mysql.com/doc/refman/8.0/en/)  

Октрытие консоли для работы в OpenServer:  
`C:\OSPanel\modules\database\MySQL-5.7-x64\bin\mysql.exe -u root`  
Основные команды:
* `SHOW DATABASES` - просмотр всех баз данных
* `USE 'названи_базы_данных'` - использовать указанную базу данных

## Индексы
Поиск по индексам (желательно уникальным значениям) или бинарный поиск работает в
([источник](https://php.zone/php-i-mysql-s-nulya/indeksy-v-mysql)):
* WHERE;
* ORDER BY;
* внутри функций MIN и MAX
        
1. Можно делать составной индекс  
`CREATE INDEX gender_name_idx ON users(gender, name);`
1. Желательно делать с начала по ключи с большими вариантами изменений (имя, перед полом и др.).  
`CREATE INDEX name_gender_idx ON users(name, gender);`  
Чем меньше в столбце одинаковых значений, тем выше селективность по нему. Селективность столбца `name` выше, чем столбца `gender`. Поля с наиболее высокой селективностью должны быть ПЕРВЫМИ в составных индексах.
1. Удаления индекса 
`DROP INDEX gender_name_idx ON users;`  

## Анализ запросов
EXPLAIN - анализ запроса (желательно проверить с индексом и без, чтобы увидеть разницу)  
Например: `EXPLAIN SELECT * FROM users WHERE name="Иван";)`  
### Значения получившихся полей таблицы на экрание:  
* key - используемый индекс (в нашем случае никаких индексов для поля name пока не создано, поэтому тут null)
* possible_keys - все возможные индексы, подходящие для запроса (аналогично написанному выше)
* rows - число записей, которые пришлось проверить прежде чем отдать результат (в нашей таблице по-прежнему 9 записей)

## Транзакции в MySQL
Зачастую нам нужно чтобы несколько запросов точно применились и выполнились одновременно", либо не выполнился ни один из них, если что-то пойдёт не так.   
В качестве примера можно привести систему оплаты на сайте. В момент покупки заказ должен быть помечен как оплаченный, и вместе с этим, одновременно нужно списать деньги с баланса пользователя. Если что-то одно не выполнится - будет либо пользователь без купленного товара и без денег, либо магазин без товара и без денег. Избежать таких ситуаций позволяют транзакции - это механизм, который позволяет выполнить несколько запросов одной операцией.  

Выглядит весь процесс следующим образом:
1. Начинается транзакция (`BEGIN`)
1. Перечисляются запросы, которые должны быть выполнены одной операцией
1. Транзакция завершается  

При этом транзакцию можно завершить двумя способами:
* либо подтвердить её и тогда все запросы, перечисленные после начала транзакции, будут выполнены. (`COMMIT`)
* либо откатить все изменения и тогда ни один запрос не выполнится. (`ROLLBACK`) 
> в `phpMyAdmin` нет возможности сделать `ROLLBACK` возможно.

#### Пример:
```sql
BEGIN;
        UPDATE `orders` SET `state`="paid" WHERE order_id=313;
        UPDATE `users` SET `balance`=`balance`-100 WHERE id=37;
COMMIT;
```
В MySQL не существует механизма вложенных транзакций. Одно соединение с БД — одна транзакция. 
Новая транзакция в пределах одного соединения может начаться только после завершения предыдущей.

## Резервное копирование
### Создание резервной копии
Можно использовать специальную утилиту mysqldump - она создает файл с SQL-запросами:  
`mysqldump -u root my_db > my_backup.sql`  
Чтобы создать резервную копию конкретной таблицы нужно добавить имя таблицы после имени базы данных:  
`mysqldump -u root my_db users > my_backup_users.sql`

### Восстановление из резервной копии
`mysql -u root my_db < my_backup.sql`

# MySQLi в PHP
## Соединяемся с базой данных
Устанавливаем доступы к базе данных:
* `$host = 'localhost';` //имя хоста, на локальном компьютере это localhost
* `$user = 'root';` //имя пользователя, по умолчанию это root
* `$password = '';` //пароль, по умолчанию пустой
* `$db_name = 'test';` //имя базы данных

1. Процедурный стиль:  
`mysqli_connect($host, $user, $password, $db_name) or die(mysqli_error($link));`
1. ООП:  
`$mysqli = new mysqli('localhost', 'my_user', 'my_password', 'my_db');`

## Проблемы с кодировками
Правило 1: База данных и таблицы в ней должны быть в кодировке `utf8_general_ci`.
Правило 2: Сам PHP файл должен быть в кодировке `utf8`.
Правило 3: В начале PHP файла должен быть следующий HTML тег: <meta charset="utf-8">
Правило 4: На всякий случай сразу после команды `mysqli_connect` добавьте такое запрос:  
`<?php mysqli_set_charset($mysqli, 'utf8'); ?>`  
/* Установите желаемую кодировку после установления соединения */  
1. Процедурный стиль:  
`mysqli_set_charset($mysqli, 'utf8');`
1. ООП:  
`$mysqli->set_charset('utf8');`

## Запросы
1. Запросы без подготовленных значений  
        Выполняются через "query".
```php
$menu = $db->query("SELECT * FROM menu")->fetch_all(MYSQLI_ASSOC);
$count = $db->query("SELECT count(*) FROM users")->fetch_row()[0];
```

2. Запросы с подготовленными значениями  
Выполняются через "prepare", "bind_param" и "execute".
```php
$stmt = $db->prepare("INSERT INTO users (email, password) VALUES (?,?)");
$stmt->bind_param("ss", $email, $password_hash);
$stmt->execute();
```
где "ss" - означает string, string
                
В bind_param() используется обозначения типов:        
* `i` для целых чисел
* `d` для чисел с плавающей запятой
* `s` для строк
* `b` для блобов

Получение результата: `$result = $stmt->get_result();`

Вывод результата:           
* `fetch_row()` которая возвращает нумерованный массив;
* `fetch_assoc()` которая возвращает ассоциативный массив;
* `fetch_object()` которая возвращает объект.

1. Одно значение:  
`mysqli_fetch_assoc()` - получение результата в виде ассоативного массива (одна строка из базы) (возвращает array или false)
1. Все значения:
`for ($data = []; $row = mysqli_fetch_assoc($result); $data[] = $row);`  
или  
`$data = $result->fetch_all(MYSQLI_ASSOC);`

# PDO (PHP Data Objects)
Ссылки:  
[Настройка и использование PDO](https://tproger.ru/translations/how-to-configure-and-use-pdo/)  
[Учебник Php.zone](https://php.zone/php-i-mysql-s-nulya)

## Установка соединения с сервером
<u>DSN (Data Source Name)</u> — сведения для подключения к базе.
```php
$options = [
        PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
        PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC
];
$dsn = "mysql:host=localhost;dbname=my_db;charset=utf8";
$dbh = new \PDO($dsn, 'root', '', $options); //установка соединения с БД
```
### Опции соединения
Также можно определить опции:
```php
$options = [
        PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
        PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC
];
```
или определить опции после создания объекта PDO с помощью:
```php
$pdo->SetAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
```

## Опеределение метода ошибок
* `PDO::ATTR_ERRMODE` - используется для определения поведения PDO в случае ошибок.
* `PDO::ERRMODE_SILENT` - вариант по умолчанию. PDO просто запишет информацию об ошибке, которую помогут получить методы `errorCode` и `errorInfo`.
* `PDO::ERRMODE_EXCEPTION` - это предпочтительный вариант, при котором в дополнение к информации об ошибке PDO выбрасывает исключение (PDOException). 
Исключение прерывает выполнение скрипта, что полезно при использовании транзакций PDO. Пример приведён ниже при описании транзакций.
* `PDO::ERRMODE_WARNING` - в этом случае PDO также записывает информацию об ошибке. Поток выполнения скрипта не прерывается, но выдаются предупреждения.

## Опеределение метода выборки
```php
$results = $stmt->fetch(PDO::DEFAULT_FETCH_MODE);
```
1. `PDO::FETCH_BOT` - Режим по умолчанию. Результат выборки индексируется как номерами (начиная с 0), так и именами столбцов.
1. `PDO::FETCH_ASSOC` - Результат сохраняется в ассоциативном массиве, в котором ключ — имя столбца, а значение — соответствующее значение строки.
1. `PDO::FETCH_NUM` - При использовании этого режима результат представляется в виде массива, индексированного номерами столбцов (начиная с 0).
1. `PDO::FETCH_COLUMN` - Этот вариант полезен, если нужно получить перечень значений одного поля в виде одномерного массива, нумерация которого начинается с 0.
1. `PDO::FETCH_KEY_PAIR` - Используем этот вариант, если нужно получить перечень значений двух полей в виде ассоциативного массива. Ключи массива — это данные первого столбца выборки, значения массива — данные второго столбца.
1. `PDO::FETCH_OBJECT` - При использовании PDO::FETCH_OBJECT для каждой извлеченной строки создаётся анонимный объект. Его общедоступные (public) свойства — имена столбцов выборки, а результаты запроса используются в качестве их значений.
1. `PDO::FETCH_CLASS` - В этом случае, как и в предыдущем, значения столбцов становятся свойствами объекта. Однако требуется указать существующий класс, который будет использоваться для создания объекта. Рассмотрим это на примере.
`$stmt->setFetchMode(PDO::FETCH_CLASS, 'НазваниеКласса');`
1. `PDO::FETCH_INTO` - При выборе этого варианта выборки PDO не создаёт новый объект, а обновляет свойства существующего. Однако это возможно только для общедоступных (public) свойств или при использовании в объекте «магического» метода __set.

### Получение результатова выборки
Получение всех результатов:
```php
while ($planet = $stmt->fetch()) {
        // обработка результатов
}
```
или
Получение результата запроса в виде массива:
```php
$results = $stmt->fetchAll(PDO::DEFAULT_FETCH_MODE);
```

## Запросы
1. Прямые запросы  
Прямые операторы используются только в том случае, если в запросе отсутствуют переменные и есть уверенность, что запрос безопасен и правильно экранирован.  
* query используется для операторов, которые не вносят изменения, например SELECT. 
                `$stmt = $pdo->query("SELECT * FROM FOO");`  
> Доп.
> * в переменной $stmt будет лежать массив, всех найденных строк в базе
> * используется без fetch и fetchAll
                        
* exec используется для операторов вроде INSERT, DELETE или UPDATE. Возвращает число обработанных запросом строк. (используется без fetch и fetchAll)
```php
$count = $stmt->exec("INSERT INTO staff (id, first, last) VALUES (23, 'Joe', 'Bloggs')");
```
> Доп.:
> * в переменной $count будет лежать число обработанных запросом строк
> * используется без fetch и fetchAll

2. Подготовленные  
prepare, который принимает как аргумент SQL-запрос с псевдопеременными (placeholders). Псевдопеременные могут быть двух типов: неименнованые и именованные.
* Неименованные псевдопеременные (positional placeholders) отмечаются символом `?`  
```php
$stmt = $pdo->prepare("INSERT INTO planets(name, color) VALUES(?, ?)");
$stmt->execute([$planet->name, $planet->color]);
```

* Именованные псевдопеременные
```php
$stmt = $pdo->prepare("INSERT INTO planets(name, color) VALUES(:name, :color)");
$stmt->execute(['name' => $planet->name, 'color' => $planet->color]);
```

* Подготовка переменных с помощью методов `bindValue` и `bindParam`  

`bindValue` - связывает значение переменной с псевдопеременной, которая использована при подготовке запроса
```php
$stmt = $pdo->prepare("INSERT INTO planets(name, color) VALUES(:name, :color)");
$stmt->bindValue('name', $planet->name, PDO::PARAM_STR);
$stmt->execute();
```

`bindParam` - привязывает переменную к псевдопеременной. В этом случае переменная связана с псевдопеременной ссылкой, а значение будет подставлено в запрос только после вызова метода execute.
```php
$stmt->bindParam('name', $planet->name, PDO::PARAM_STR);
$stmt->execute();
```

## Транзакции в PDO
```php
$pdo->beginTransaction(); //Начинается транзакция
/* какие действия с БД */
$pdo->commit(); //выполнения запросов
$pdo->rollBack(); //откатить все изменения и тогда ни один запрос не выполнится.
```

## Пример использования PDO
```php
$options = [
        PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
        PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC
];
$dsn = "mysql:host=localhost;dbname=my_db;charset=utf8";
$dbh = new \PDO($dsn, 'root', '', $options); //установка соединения с БД   
$dbh->exec('SET NAMES UTF8'); //установка кодировки
$stm = $dbh->prepare('INSERT INTO users (`email`, `name`) VALUES (:email, :name)'); //создание подготовленного запроса
$stm->bindValue('email', 'x100@php.zone'); //установка значения
$stm->bindValue('name', 'Вячеслав'); //установка значения
$stm->execute(); //выполнение запроса

$allUsers = $stm->fetchAll(); //получение результата запроса в виде массива
var_dump($allUsers);
```

# SQL Команды основные
Ссылки:  
[sql-ex](https://www.sql-ex.ru/site_rules.php)  
[Уроки SQL (средние)](https://office-menu.ru/uroki-sql)  
[Учебник SQL](https://myrusakov.ru/sql-osnovy.html)
[Как думать на SQL](https://habr.com/ru/post/305926/)  
[Памятка о SQL](https://habr.com/ru/post/564390/)  
[Шпаргалка SQL](https://websitesetup.org/wp-content/uploads/2020/08/SQL-Cheat-Sheet-Summary-Full.png)  
[20 советов по оптимальному использованию MySQL](https://ruseller.com/lessons.php?id=692)

## Синтаксис запроса

SELECT [DISTINCT | ALL - по умолчанию] поля_таблиц   
FROM список_таблиц   
[WHERE условия_на_ограничения_строк]  
[GROUP BY условия_группировки]  
[HAVING условия_на_ограничения_строк_после_группировки]  
[ORDER BY порядок_сортировки [ASC - по умолчанию | DESC]]  
[LIMIT ограничение_количества_записей]  
В описанной структуре запроса необязательные параметры указаны в квадратных скобках.
		
Логический порядок обработки инструкции SELECT:
1. `FROM`
1. `WHERE`
1. `GROUP BY`
1. `HAVING`
1. `SELECT`
1. `DISTINCT`
1. `ORDER BY`
1. `LIMIT`
		
* `DISTINCT` используется для исключения повторяющихся строк из результата  
* `ALL` - (по умолчанию) используется для получения всех данных, в том числе и повторений  
* `FROM` перечисляет используемые в запросе таблицы из базы данных  
* `WHERE` — это условный оператор, который используется для ограничения строк по какому-либо условию  
* `GROUP BY` используется для группировки строк  
* `HAVING` применяется после группировки строк для фильтрации по значениям агрегатных функций  
* `ORDER BY` используется для сортировки. У него есть два параметра:  
        * `ASC` (по умолчанию) используется для сортировки по возрастанию  
        * `DESC` — по убыванию  
* `LIMIT` используется для ограничения количества строк для вывода
		
## SELECT
```sql
SELECT * FROM имя_таблицы WHERE условие_по_которому_следует_выбрать_строки;
SELECT * FROM workers WHERE id > 0
```

### SELECT INTO - копирует данные из одной таблицы в другую.
Условие WHERE не является обязательным, если его не указать - будут выбраны все записи.  
- `SELECT * INTO в_какую_таблицу FROM из_какой_таблицы [WHERE условие]`  
- `SELECT * INTO в_какую_таблицу IN другая_база_данных FROM из_какой_таблицы [WHERE условие]`  
Пример:  
Команду SELECT INTO можно использовать для того, чтобы создать новую пустую таблицу по образцу старой.  
Для этого в WHERE нужно передать условие, которое не выберет ни одной записи:  
`SELECT * INTO новая_таблица FROM старая_таблица WHERE 1=0`

			
## WHERE
WHERE - если запись удовлетворяет этому условию, то попадает в результат, иначе 	отбрасывается.
```sql	
SELECT поля_таблиц FROM список_таблиц WHERE условия_на_ограничения_строк [логический_оператор другое_условия_на_ограничения_строк];
```

### Дополнительные условия в WHERE
`OR` и `AND`
```sql
SELECT * FROM workers WHERE salary=500 AND age=23
SELECT * FROM workers WHERE salary=500 OR age=23
```	

## ORDER BY
ORDER BY - сортировка по полю
```sql
SELECT поля_таблиц FROM список_таблиц ORDER BY столбец_1 (или номер столбца из порядка в SELECT) [ASC | DESC][, столбец_n [ASC | DESC]];
```
				
- сортировка строковых данных осуществляется в лексикографическом (алфавитном) порядке.
- DESC — сортировка по убыванию
- ASC (по умолчанию) — сортировка по возрастанию
	
```sql
SELECT * FROM workers WHERE id>0 ORDER BY age
SELECT * FROM workers WHERE id>0 ORDER BY age DESC - обр.порядок
```

## GROUP BY
GROUP BY - позволяет группировать результаты при выборке из базы данных. К сгруппированным результатам можно применять любые функции (смотрите примеры).  			
В SELECT можно выбирать любое число столбцов. Но при этом в GROUP BY должны быть перечислены все столбцы из списка SELECT, которые не находятся под агрегатной функцией. А если у тебя нет агрегатной функции, тогда зачем GROUP BY? 
		
Иногда требуется узнать информацию не о самих объектах, а об определенных группах, которые они образуют. Для этого используется оператор GROUP BY и агрегатные функции.
```sql		
SELECT [константы, агрегатные_функции, поля_группировки] 
FROM имя_таблицы 
GROUP BY поля_группировки;
```

- Следует иметь в виду, что для GROUP BY все значения NULL трактуются как равные, т.е. при группировке по полю, содержащему NULL-значения, все такие строки попадут в одну группу.
			
### Агрегатные функции
Агрегатные функции: агрегатные функции применяются для значений, не равных NULL.  
Агрегатная функция выполняет вычисление на наборе значений и возвращает одиночное значение.
Исключением является функция COUNT().  
				
* SUM(поле_таблицы)
* AVG(поле_таблицы)
* COUNT(поле_таблицы)
* MIN(поле_таблицы)
* MAX(поле_таблицы)

## HAVING 
HAVING - используется для фильтрации строк по значениям агрегатных функций, после GROUP BY
```sql
SELECT [константы, агрегатные_функции, поля_группировки] 
FROM имя_таблицы 
GROUP BY поля_группировки
HAVING условие_на_ограничение_строк_после_группировки
```
				
Примеры:
```sql
SELECT age, COUNT(*) as count FROM employees GROUP BY age HAVING count<=2 или аналог
SELECT age, COUNT(*) as count FROM employees GROUP BY age HAVING count IN(1,2) или аналог
SELECT age, COUNT(*) as count FROM employees GROUP BY age HAVING count BETWEEN 1 AND 2
```

## LIMIT
LIMIT - позволяет извлечь определённый диапазон записей из одной или нескольких таблиц.  
```sql
SELECT поля_выборки FROM список_таблиц LIMIT [количество_пропущенных_записей,] количество_записей_для_вывода;
```
			
- если не указать количество пропущенных записей, то их отсчёт будет вестись с начала таблицы.
- оператор LIMIT реализован не во всех СУБД, например, в MSSQL для вывода записей с начала таблицы используется оператор TOP, а для тех случаев, когда необходимо сделать отступ от начала таблицы, предназначена конструкция OFFSET FETCH.

## AS
`AS` - для создания псевдонимов (SQL псевдонима) используется оператор AS
		
## JOIN		
```sql
SELECT поля_таблиц
FROM таблица_1 
[INNER] | [[LEFT | RIGHT | FULL][OUTER]] JOIN таблица_2 
ON условие_соединения
[[INNER] | [[LEFT | RIGHT | FULL][OUTER]] JOIN таблица_n 
ON условие_соединения]
```			
Соединение бывает:
* внутренним (`INNER`) (возвращает только совпадающие строки)
* внешним (`OUTER`), при этом внешнее соединение делится:  
        - на левое (`LEFT`) (возвращает все строки из левой таблицы),  
        - правое (`RIGHT`) (возвращает все строки из правой таблицы)  
        - и полное (`FULL`) (возвращает все строки из обоих таблиц) - по умолчанию оно является полным.
				
- по умолчанию, если не указаны какие-либо параметры, `JOIN` выполняется как `INNER JOIN`, то есть как внутреннее (перекрёстное) соединение таблиц. Внутреннее соединение — соединение двух таблиц, при котором каждая запись из первой таблицы соединяется с каждой записью второй таблицы, создавая тем самым все возможные комбинации записей обеих таблиц (декартово произведение).
Для внутреннего соединения таблиц также можно использовать оператор `WHERE`. Например, вышеприведённый запрос, написанный с помощью `INNER JOIN`, будет выглядеть так:
```sql
SELECT *
FROM Payments, FamilyMembers
WHERE family_member = member_id;
```				
			
- соединение `FULL JOIN` реализовано не во всех СУБД. Например, в MySQL оно отсутствует, однако его можно очень просто эмулировать:
```sql
SELECT * 
FROM левая_таблица 
LEFT JOIN правая_таблица ON правая_таблица.ключ = левая_таблица.ключ
UNION ALL
SELECT * 
FROM левая_таблица 
RIGHT JOIN правая_таблица ON правая_таблица.ключ = левая_таблица.ключ
WHERE левая_таблица.key IS NULL
```

## Подзапросы
Вложенный запрос — это запрос на выборку, который используется внутри инструкции `SELECT`, `INSERT`, `UPDATE` или `DELETE` или внутри другого вложенного запроса.  
Подзапрос может быть использован везде, где разрешены выражения.  
Подзапрос может возвращать скаляр (одно значение), одну строку, один столбец или таблицу (одну или несколько строк из одного или нескольких столбцов). Они называются скалярными, столбцовыми, строковыми и табличными подзапросами.  
Скалярный подзапрос — запрос, возвращающий единственное скалярное значение (строку, число и т.д.).
			
Может быть вызван в:
FROM вместе с AS - любое значение
WHERE - возвращает скаляр или сроковый подзапрос
SELECT - должен возвращать только скаляр
			
Вложенные подзапросы обрабатываются «снизу вверх». То есть сначала обрабатывается вложенный запрос самого нижнего уровня. Далее значения, полученные по результату его выполнения, передаются и используются при реализации подзапроса более высокого уровня и т.д.
			
### Подзапросы с ANY, IN, ALL
`ANY` — ключевое слово, которое должно следовать за операцией сравнения (>, <, <>, = и т.д.), возвращающее TRUE, если хотя бы одно из значений столбца подзапроса удовлетворяет обозначенному условию.
```sql
SELECT поля_таблицы_1 
FROM таблица_1 
WHERE поле_таблицы_1 <= ANY (SELECT поле_таблицы_2 FROM таблица_2);
```	

`ALL` — ключевое слово, которое должно следовать за операцией сравнения, возвращающее TRUE, если все значения столбца подзапроса удовлетворяет обозначенному условию.
```sql
SELECT поля_таблицы_1 
FROM таблица_1 
WHERE поле_таблицы_1 > ALL (SELECT поле_таблицы_2 FROM таблица_2);
```

`IN` — ключевое слово, являющееся псевдонимом ключевому слову ANY с оператором сравнения = (эквивалентность), либо <> ALL для NOT IN. Например, следующие запросы равнозначны:
```sql
WHERE поле_таблицы_1 = ANY (SELECT поле_таблицы_2 FROM таблица_2);
WHERE поле_таблицы_1 IN (SELECT поле_таблицы_2 FROM таблица_2);
```
				
### Связанные подзапросы:
Связанным подзапросом является подзапрос, который содержит ссылку на таблицу, которая была объявлена во внешнем запросе. Здесь вложенный запрос ссылается на внешюю таблицу "таблица_1":
```sql
SELECT поля_таблицы_1 FROM таблица_1
WHERE поле_таблицы_1 IN 
(
        SELECT поле_таблицы_2 FROM таблица_2
	WHERE таблица_2.поле_таблицы_2 = таблица_1.поле_таблицы_1
);
```
		
## UNION
UNION - объединение SQL запросов.
```sql
SELECT поля_таблиц FROM список_таблиц ...  
UNION [ALL]  
SELECT поля_таблиц FROM список_таблиц ... ;
```
			
> UNION по умолчанию убирает повторения в результирующей таблице. Для отображения с повторением есть необязательный параметр ALL.

- Не путайте операции объединения запросов с операциями объединения таблиц. Для этого служит оператор `JOIN`.
- Не путайте операции объединения запросов с подзапросами. Подзапросы выполняются для связанных таблиц.
			
Объединение таблиц оператором UNION выполняется для таблиц никак не связанных, но со схожей структурой.  
Для того, чтобы UNION корректно сработал нужно: чтобы результирующие таблицы каждого из SQL запросов имели одинаковое число столбцов, с одним и тем же типом данных и в той же самой последовательности.  
Существует два других оператора, чьё поведение крайне схоже с `UNION`:
* `INTERSECT` - комбинирует два запроса `SELECT`, но возвращает записи только первого `SELECT`, которые имеют совпадения во втором элементе `SELECT`.
* `EXCEPT` - комбинирует два запроса `SELECT`, но возвращает записи только первого `SELECT`, которые не имеют совпадения во втором элементе `SELECT`.

## INSERT	
`INSERT` - вставка данных в БД
```sql
INSERT INTO имя_таблицы SET поле1=значение1, поле2=значение2, поле3=значение3...;
INSERT INTO workers SET name='Гена', age=30, salary=1000
```

Другой синтаксис `INSERT`
```sql
INSERT INTO workers (поле1, поле2...) VALUES (значение1, значение2...)
INSERT INTO workers (name, age, salary) VALUES ('Гена', 30, 1000)
```
                
Массовая вставка через `INSERT`
```sql
INSERT INTO имя_таблицы (поле1, поле2...) VALUES (значение1, значение2...), (значение1, значение2...)...
INSERT INTO workers (name, age, salary) VALUES ('Гена', 30, 1000), ('Вася', 25, 500), ('Иван', 27, 1500)
```

## DELETE
`DELETE` - удаление записей
```sql
DELETE FROM имя_таблицы WHERE условие_по_которому_следует_удалять_строки
DELETE FROM workers WHERE id=6
```

## UPDATE
`UPDATE` - обновление значений записей
```sql
UPDATE workers SET salary=1000 WHERE name='Дима'
```

## LIMIT
`LIMIT` — ограничение количества
```sql
SELECT * FROM workers WHERE id>0 LIMIT 2 - выберем первых двух юзеров
SELECT * FROM workers WHERE id>0 LIMIT 2,5 - со 2-ой строки 5 штук
```
        
## COUNT
`COUNT` — считаем количество
```sql
SELECT COUNT(*) as count FROM workers WHERE id>0
```

## Команды дополнительные
Кавычки `` - проблемные слова следует брать в косые кавычки
```sql
SELECT * FROM `from`
```
        
`AS` - задает новое имя полям или таблицам при выборке (то есть в самой базе изменения не происходят).
1. `SELECT поле as его_новое_имя FROM имя_таблицы`
1. `SELECT * FROM имя_таблицы as новое_имя_таблицы`
        
`BETWEEN` - задает диапазон значений, по которому выбираются записи из базы данных.  
```sql
`SELECT * FROM имя_таблицы WHERE поле BETWEEN от AND до`
```

`IN` - выбирает записи из базы данных по определенным значениям поля.
```sql
SELECT * FROM имя_таблицы WHERE поле IN (значение1, значение2...)
```

`EXISTS` - принимает значение TRUE, если подзапрос содержит любое количество строк, иначе его значение равно FALSE. 
        
`DISTINCT` - позволяет выбирать только уникальные значения из базы данных.
1. `SELECT DISTINCT поле FROM имя_таблицы WHERE условие`
1. `SELECT COUNT(DISTINCT поле) FROM имя_таблицы WHERE условие`
1. `SELECT SUM(DISTINCT поле) FROM имя_таблицы WHERE условие`

`LIKE` - реализуем поиск
```sql
SELECT * FROM workers WHERE name LIKE '%я'
//ВЫБРАТЬ все ИЗ таблицы ГДЕ имя ПОДОБНО любой_строке_заканчивающейся_на_я
```

`NOT` - задает отрицание для других команд: вместо IN можно написать NOT IN, вместо BETWEEN - NOT BETWEEN и так далее.
1. NOT IN (значение1, значение2...)
1. NOT BETWEEN значение1 AND значение2
1. NOT LIKE шаблон 
```sql
SELECT * FROM employees WHERE id NOT IN (1, 3, 5);
```   
`IS NOT NULL` - проверяет поле на не NULL.
```sql
WHERE поле IS NOT NULL
SELECT * FROM employees WHERE salary IS NOT NULL
```

`IS NULL` - проверяет поле на NULL.
```sql
WHERE поле IS NULL
SELECT * FROM employees WHERE salary IS NULL
```

`CAST` - явное преобразование типа данных CAST(<выражение> AS <тип данных>)

### Математические функции
`MIN` - возвращает минимальное значение поля среди найденных строк.  
- `SELECT MIN(поле) FROM имя_таблицы WHERE условие`
        
`MAX` - возвращает максимальное значение поля среди найденных строк.  
- `SELECT MAX(поле) FROM имя_таблицы WHERE условие`

`SUM` - суммирует значения указанного поля по всем выбранным строкам.  
- `SELECT SUM(поле) FROM имя_таблицы WHERE условие`

`AVG` - возвращает среднее арифметическое по всем найденным записям.  
- `SELECT AVG(поле) FROM имя_таблицы WHERE условие`

`ROUND` - используется для округления дробей до нужного знака в дробной части.
- `SELECT ROUND(поле) FROM имя_таблицы WHERE условие`
- `SELECT ROUND(поле, сколько_знаков_оставить) FROM имя_таблицы WHERE условие`
- `SELECT *, ROUND(salary, 1) as salary FROM employees`

`FLOOR` - используется для округления дробей до целого в меньшую сторону.  
- `SELECT FLOOR(поле) FROM имя_таблицы WHERE условие`

`CEILING` - используется для округления дробей до целого в большую сторону.  
- `SELECT CEILING(поле) FROM имя_таблицы WHERE условие`

`TRUNCATE` - округляет число до определенного знака, но не по правилам математического округления, а просто отбрасывая лишние знаки.  
- `SELECT TRUNCATE(поле, сколько_знаков_оставить) FROM имя_таблицы WHERE условие`

`ABS` - находит модуль числа, то есть из отрицательного делает положительное.  
- `SELECT ABS(поле) FROM имя_таблицы WHERE условие`  
- `SELECT *, ABS(temperature) as temperature FROM weather`

`SIGN` - определяет знак числа. Если число больше нуля - функция вернет 1, если меньше нуля - вернет -1, а если равно нулю - вернет 0.
- `SELECT SIGN(поле) FROM имя_таблицы WHERE условие`
- `SELECT *, SIGN(temperature) as sign FROM weather`

`MOD` - находит остаток от деления одного числа на другое. Вместо MOD можно использовать операцию %, которая делает то же самое.
- `SELECT MOD(что_делить, на_что_делить) FROM имя_таблицы WHERE условие`
- `SELECT *, MOD(number, 3) as mod FROM numbers`
- `SELECT *, MOD(number1, number2) as mod FROM numbers`
- `SELECT * FROM numbers WHERE MOD(number1, number2)<=2`

`POW` - возводит число в заданную степень.
- `SELECT POW(число, степень_числа) FROM имя_таблицы WHERE условие`
- `SELECT *, POW(number1, number2) as pow FROM numbers`
        
`SQRT` - находит квадратный корень из числа.
- `SELECT SQRT(положительное_число) FROM имя_таблицы WHERE условие`
- `SELECT *, SQRT(number) as sqrt FROM numbers`

`RAND` - возвращает случайное дробное число от 0 до 1. 
- `SELECT RAND() FROM имя_таблицы WHERE условие`
- `SELECT RAND(число) FROM имя_таблицы WHERE условие`

`LEAST` - выбирает минимальное из значений. Значениями могут выступать поля, а также строки и числа. 
- `SELECT LEAST(число1, число2...) FROM имя_таблицы WHERE условие`
- `SELECT id, LEAST(number1, number2, number3) as number FROM numbers`

`GREATEST` - выбирает максимальное из значений. Значениями могут выступать поля, а также строки и числа. 
- `SELECT GREATEST(число1, число2...) FROM имя_таблицы WHERE условие`
- `SELECT id, GREATEST(number1, number2, number3) as number FROM numbers`

### Текстовые функции
`REPLACE` - позволяет производить поиск и замену одних частей строки на другие.
- `SELECT REPLACE(поле, что_менять, на_что_менять) FROM имя_таблицы WHERE условие`
        
`POSITION` - осуществляет поиск подстроки в строке, возвращает позицию ее первого символа. Учтите, что нумерация символов начинается с 1.
- `SELECT POSITION(что_ищем IN поле) FROM имя_таблицы WHERE условие`
- `SELECT *, POSITION('длинный' IN text) as pos FROM texts`

`LOCATE` - осуществляет поиск подстроки в строке, возвращает позицию ее первого символа. Учтите, что нумерация символов начинается с 1. В отличие от функции POSITION функция LOCATE может начинать поиск не с начала строки, а с определенного места. 
- `SELECT LOCATE(что_ищем, поле) FROM имя_таблицы WHERE условие`
- `SELECT LOCATE(что_ищем, поле, начало_поиска) FROM имя_таблицы WHERE условие`

`INSTR` - осуществляет поиск подстроки в строке, возвращает позицию ее первого символа. Учтите, что нумерация символов начинается с 1. В отличие от функции POSITION функция INSTR имеет обратный порядок параметров.
- `SELECT INSTR(поле, что_ищем) FROM имя_таблицы WHERE условие`

`LEFT` - вырезает и возвращает заданное количество символов с начала строки.
- `SELECT LEFT(поле, сколько_символов_взять) FROM имя_таблицы WHERE условие`
- `SELECT id, LEFT(text, 6) as text FROM texts`
        
`RIGHT` - вырезает и возвращает заданное количество символов с конца строки.
`SELECT RIGHT(поле, сколько_символов_взять) FROM имя_таблицы WHERE условие`

`SUBSTRING` - вырезает и возвращает заданное количество символов из строки. Первым параметром функция принимает поле или строку, вторым параметром - с какой позиции начинать вырезания (нумерация символов начинается с 1), третьем параметром - сколько символов брать. Третий параметр не является обязательным. Если он не указан, текст будет вырезан с указанной позиции и до конца строки.
- `SELECT SUBSTRING(поле, откуда_отрезать, сколько_символов_взять) FROM имя_таблицы WHERE условие`
- `SELECT SUBSTRING(поле FROM откуда_отрезать FOR сколько_символов_взять) FROM имя_таблицы WHERE условие`

`MID` - вырезает и возвращает заданное количество символов из строки. Первым параметром функция принимает поле или строку, вторым параметром - с какой позиции начинать вырезания (нумерация символов начинается с 1), третьем параметром - сколько символов брать. 
Третий параметр не является обязательным. Если он не указан, текст будет вырезан с указанной позиции и до конца строки.
- `SELECT MID(поле, откуда_отрезать, сколько_символов_взять) FROM имя_таблицы WHERE условие`

`SUBSTRING_INDEX` - возвращает подстроку из строки перед появлениям N вхождений разделителя. Если N положителен, то возвращается все, что находится слева от последнего разделителя (считая слева). Если N отрицателен, то возвращается все, что находится справа от последнего разделителя (считая справа).
- `SELECT SUBSTRING_INDEX(поле, разделитель, количество_разделителей) FROM имя_таблицы WHERE условие`                
- `SELECT *, SUBSTRING_INDEX(text, '-', 1) as text FROM texts`

`LPAD` - дополняет строку до нужного размера добавляя заданные символы в начало строки.
`SELECT LPAD(поле, новый_размер_поля, чем_дополнить) FROM имя_таблицы WHERE условие`

`RPAD` - дополняет строку до нужного размера добавляя заданные символы в конец строки.
`SELECT RPAD(поле, новый_размер_поля, чем_дополнить) FROM имя_таблицы WHERE условие`

`REVERSE` - переворачивает заданную строку так, чтобы ее символы шли в обратном порядке.
`SELECT REVERSE(поле) FROM имя_таблицы WHERE условие`

`REPEAT` - повторяет заданную строку нужное количество раз.
`SELECT REPEAT(поле, количество_повторений) FROM имя_таблицы WHERE условие`
        
`CONCAT` - предназначена для сложения строк при выборке из базы данных. Строками обычно выступают поля таблиц.
- `SELECT CONCAT(поле1, поле2...) FROM имя_таблицы WHERE условие`
- `SELECT *, CONCAT(age, name, salary) as concat FROM employees`

`CONCAT_WS` - предназначена для сложения строк при выборке из базы данных с использованием разделителя. Строками обычно выступают поля таблиц.
`SELECT CONCAT_WS(разделитель, поле1, поле2...) FROM имя_таблицы WHERE условие`

`GROUP_CONCAT` - складывает (как строки) содержимое одного поля из разных строк, вставляя между ними разделитель (по умолчанию это запятая).  
К примеру, можно получить список всех выбранных имен через запятую или другой разделитель. 
У этой функции есть ограничение на объем выводимых данных. По умолчанию 1024 символа для каждого объединения - для каждой выводимой строки. Если размер склеенных данных больше, то он будет урезаться. Чтобы расширить размер нужно выполнить команду  
`SET group_concat_max_len = 4096;`   
Если у вас есть привилегии, то вы расширите объем получаемых данных до 4096, можно и больше. Но чаще всего на обычных хостингах таких привилегий нет.  

Без указания разделителя (по умолчанию это будет запятая):
- `SELECT GROUP_CONCAT(поле) FROM имя_таблицы WHERE условие`  

С указанием разделителя:
- `SELECT GROUP_CONCAT(поле SEPARATOR разделитель) FROM имя_таблицы WHERE условие`
        
`LOWER` - переводит строку в нижний регистр (то есть из больших букв делает маленькие). 
- `SELECT LOWER(поле) FROM имя_таблицы WHERE условие`

`LCASE` - переводит строку в нижний регистр (то есть из больших букв делает маленькие).
`SELECT LCASE(поле) FROM имя_таблицы WHERE условие`

`UPPER` - переводит строку в верхний регистр (то есть из маленьких букв делает большие).
`SELECT UPPER(поле) FROM имя_таблицы WHERE условие`

`UCASE` - переводит строку в верхний регистр (то есть из маленьких букв делает большие).
- `SELECT UCASE(поле) FROM имя_таблицы WHERE условие`

`TRIM` - обрезает пробелы по краям строки.  
`LTRIM` - обрезает пробелы, которые стоят в начале строки.  
`RTRIM` - обрезает пробелы, которые стоят в конце строки.  
При выборке:
- `SELECT TRIM(поле) FROM имя_таблицы WHERE условие`  
При вставке:
- `INSERT INTO имя_таблицы SET имя_поля=TRIM(значение_поля)`

`SPACE` - создает строку, состоящую из заданного количества пробелов.
`SELECT SPACE(количество_пробелов) FROM имя_таблицы WHERE условие`

`ELT` - выбирает одно из полей по его номеру (нумерация полей с единицы).
Номер поля задается первым параметром, а остальными параметрами задаются имена полей. 
Выглядит это примерно так: ELT(номер, поле1, поле2, поле2). Если, к примеру, вместо номера передать 1 - то выберется значение поля1, если 2 - значение поля2, если 3 - значение поля 3. Вместо полей могут быть строки или числа, например, так: ELT(номер, 'строка1', 2, 'строка3'). Можно также комбинировать строки, числа и поля: ELT(номер, 'строка1', 2, поле1). Если номер меньше, чем 1 или больше, чем число полей, возвращается NULL.
- `SELECT ELT(число, поле1, поле2...) FROM имя_таблицы WHERE условие`

`FIELD` - ищет поле, которое содержит в себе заданный текст, и возвращает его номер (нумерация с единицы). Текст передается первым параметром, а поля, в которых искать - остальными параметрами. Вместо полей могут быть строки или числа. Если строка не найдена, возвращается 0.
- `SELECT FIELD(строка, поле1, поле2...) FROM имя_таблицы WHERE условие`
        
`LENGTH` - используется для подсчета количества символов в строках.
- `SELECT LENGTH(поле) FROM имя_таблицы WHERE условие`

### [Ссылка на функции работы с датой](https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html)
