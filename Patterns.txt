Front-Controller (Фронт контроллер) - все запросы напрявляються в один файл обычно это index.php.
    Настраивается Front-Controller, c помощью Nginx и/или Apache.
    Apache:
        #Включает или выключает работу механизма преобразования
        RewriteEngine On
        #-Дополнительные условия для ReqwriteRule
        #Пропускать существующие папки
        RewriteCond %{SCRIPT_FILENAME} !-d
        #Пропускать существующие файлы
        RewriteCond %{SCRIPT_FILENAME} !-f
        #Условия преобразования
        #Флаг qsappend|QSA - значит добавить в конец нового URI исходную строку GET параметров запроса QUERY_STRING, которая содержится в серверной переменной %{QUERY_STRING}
        #Флаг last|L - последнее правило, что означает - остановить процесс преобразования на этом месте и не применять больше никаких следующих правил преобразований для URL.
        RewriteRule ^(.*)$ ./index.php?route=$1 [QSA,L]

https://github.com/codedokode/pasta/blob/master/arch/di.md
https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D1%80%D0%BE%D0%B6%D0%B4%D0%B0%D1%8E%D1%89%D0%B8%D0%B5_%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F

Singleton (одиночка)
--------------------
    Порождающий шаблон проектирования, гарантирующий, что в однопоточном приложении будет единственный экземпляр некоторого класса, 
    и предоставляющий глобальную точку доступа к этому экземпляру.

    <?php
        trait Singleton {
            private static $instance = null;

            private function __construct() { /* ... @return Singleton */ }  // Защищаем от создания через new Singleton
            private function __clone() { /* ... @return Singleton */ }  // Защищаем от создания через клонирование
            private function __wakeup() { /* ... @return Singleton */ }  // Защищаем от создания через unserialize

            public static function getInstance() {
                return 
                self::$instance===null
                    ? self::$instance = new static() // Если $instance равен 'null', то создаем объект new self()
                    : self::$instance; // Иначе возвращаем существующий объект 
            }
        }

        /**
        * Class Foo
        * @method static Foo getInstance()
        */
        class Foo {
            use Singleton;

            private $bar = 0;

            public function incBar() {
                $this->bar++;
            }

            public function getBar() {
                return $this->bar;
            }
        }

        /*
        Применение
        */

        $foo = Foo::getInstance();
        $foo->incBar();

        var_dump($foo->getBar());

        $foo = Foo::getInstance();
        $foo->incBar();

        var_dump($foo->getBar());
    ?>

Utility Class (вспомогательный класс, класс-утилиты)
----------------------------------------------------
    Класс статический функций (методов, процедур, действий), которые ни к чему не привязаны. Они созданы чтобы возварщать какой-то результат работы функции.
    Пример: функция перевода градусов в радианы, функция, генерирующая случайный пароль или определяющая расширение по имени файла.

Зависимости (dependency):
    Если мы разбили код на классы, то может оказаться, что одному из них нужен другой. Ну например, если у нас есть класс авторизации, 
    а в нем метод, проверяющий логин и пароль пользователя на правильность, которые хранятся в базе данных, ему понадобится класс, достающий их оттуда.
    В таких случаях говорят, что класс A зависит от класса B, или B является зависимостью (dependency) класса A.
    Зависимости бывают обязательные (без которых класс работать не может) и необязательные. 
    Пример необязательной зависимости - это класс-логгер. Он может быть нужен только при отладке кода, а на боевом сервере не требуется.

Dependency injection (DI, внедрение зависимостей)
-------------------------------------------------
    Это передача зависимостей в класс снаружи. 
    Внедрять их можно через конструктор или отдельный метод-сеттер ("сеттером" его называют, так как его название начинается с set - "установить", "задать").
    Хорошая функция получает нужные ей значения через аргументы, а хороший класс получает свои обязательные зависимости через конструктор.
    Необязательные зависимости обычно либо передают через отдельный метод-сеттер (вроде setLogger(Logger $logger)), 
    либо через конструктор с указанием null в качестве значения по умолчанию.
    Это имеет такие преимущества:
        - нельзя забыть передать зависимость при создании класса
        - зависимости легко увидеть, глянув на конструктор
        - мы выбираем, какую зависимость с какими настройками передать
        - можно создать несколько объектов с разными настройками
        - можно передать в качестве зависимости не только требуемый класс, но и его наследника, с измененным нами поведением

    IoC, inversion of control (инверсия управления)
    -----------------------------------------------
         Передача зависимости снаружи, а не класс сам ищет их, это называется инверсия управления.
         Пример:
            Вот пример передачи зависимостей классу-валидатору:

            class UserValidator
            {
                public function __construct(UserTableGateway $userTableGateway) { ... }
                public function setLogger(Logger $logger) { ... }
                ...
            }

            А вот пример того, как мы можем создать 2 разных валидатора, использующих разные объекты работы с БД, один - настоящий, 
            а другой - тестовый, который возвращает заранее подготовленные данные. Эти валидаторы полностью независимы друг от друга и 
            не влияют на остальной код:

            $realUserTableGateway = new UserTableGateway(...);
            $realValidator = new UserValidator($realUserTableGateway);

            $testUserGateway = new TestUserGateway();
            $testValidator = new UserValidator($testUserGateway);

            Как мы видим, внедрение зависимостей дает нам максимальную гибкость использования и позволяет сделать классы слабо связанными друг с другом, 
            так, что изменение в одном не потребует переделки другого.
            В данном случае TestUserGateway должен быть наследником UserTableGateway, чтобы пройти проверку в тайп-хинте. 
            Чтобы избежать необходимости применять наследование, мы можем добавить интерфейс UserTableGatewayInterface и указать его как тайп-хинт.

    Registry (реестр)
    -----------------
        Это класс, как правило, со статическими методами, который хранит в себе другие объекты. 
        В начале скрипта мы помещаем объекты в Registry, и затем другие классы могут оттуда их брать. 
        Как правило, класс Registry доступен глобально, из любой точки кода, за счет использования статических методов.

        Недостатки Registry:
            - классы связаны намертво и подменить или настроить зависимости одного класса нельзя. Registry это по сути набор глобальных переменных и статических методов со всеми их недостатками.
            - зависимости класса не видны явно. Непонятно без изучения кода, что надо положить в Registry, чтобы этот конкретный объект работал.
            - у всех классов появляется лишняя зависимость от класса Registry. Их не получится использовать без него. Я бы сказал, что Registry заражает код, распространяясь как вирус.
            - объекты в Registry приходится добавлять в определенном порядке, иначе может оказаться, что какой-то из зависимостей объекта там еще нет.
            - так как статические методы доступны из любой точки кода, мы не можем ограничить доступ к Registry только определенными классами

    ServiceLocator (локатор сервисов) https://bashka.github.io/posts/service-locator/?ysclid=li8hvy247z993373042
    
        Это объект, способный находить или создавать другие объекты (сервисы). 
        Мы создаем объект ServiceLocator, заполняем его объектами (либо указываем, как их создавать), и передаем классу в конструктор, 
        а класс может взять из него то, что ему требуется:


        Этот подход исправляет часть недостатков Registry (например, он доступен только в тех классах, куда мы его передали), но имеет такие недостатки:
            - зависимости класса не видны. Непонятно, какие сервисы должны быть добавлены в ServiceLocator
            - ServiceLocator "отравляет" код и становится лишней зависимостью каждого класса

        Однако, использование ServiceLocator иногда оправданно. В некоторых фреймворках объект ServiceLocator (в качестве которого выступает DI Container) 
        передается в конструктор контроллера, чтобы тот мог найти и вызвать нужные ему сервисы. Это проще, чем передавать каждый по отдельности в конструктор. 
        Контроллер является чем-то вроде стартовой точки обработки запроса, так что там это может быть приемлемо.

    DI container (DI контейнеры)
    ----------------------------
        При использовании DI в небольшом приложении мы можем вручную создать все нужные объекты в самом начале:

        $a = new A;
        $b = new B($a);
        $c = new C;

        Но когда классов становится много, код усложняется. Мы должны создавать объекты в правильном порядке, и нам приходится создавать все объекты, 
        даже если часть из них нам далее не понадобится. Для решения этой проблемы придуманы DI контейнеры. 
        Это класс, отвечающий за создание нужных нам сервисов. В нем мы описываем классы и их зависимости (например, как функции для создания каждого объекта), 
        и после этого можем получать эти объекты из контейнера.

        Объект контейнера позволяет работать с ним, используя синтаксис доступа к массиву (хотя он и не является массивом), за счет реализации интерфейса ArrayAccess.

        DI container внешне напоминает ServiceLocator. 
        Но если присмотреться, то между ними есть принципиальная разница: 
        при использовании ServiceLocator все классы начинают зависеть от него, так как мы передаем им в конструктор этот самый ServiceLocator. 
        Когда класс хочет получить объект, он сам вызывает методы ServiceLocator. 
        В случае же с DI container классы о нем ничего не знают, и получают от него в конструктор только нужные им объекты-сервисы. 
        Потому DI container не имеет недостатков ServiceLocator. Ты можешь использовать DI контейнер с любыми классами, в них не надо специально что-то дописывать.
